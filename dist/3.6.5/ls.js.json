{"components":["menubar","knob","menu"],"content":[{"segment":"default","content":["\nString.prototype.replaceAll||(String.prototype.replaceAll=function(a,b){return\"[object regexp]\"===Object.prototype.toString.call(a).toLowerCase()?this.replace(a,b):this.replace(new RegExp(a,\"g\"),b)});\n\nif(!LS){\n    const global = typeof window !== 'undefined'? window : global || globalThis;\n\n    var LS = {\n        isWeb: typeof window !== 'undefined',\n\n        Util: {\n            resolveElements(...array){\n\n                // Takes a list of elements or element-like structure and cleans the array to a definite array of elements\n\n                return array.flat(Infinity).map(element => {\n                    if(element && element.tagName) return element;\n\n                    return [...N(\"temp\", element).childNodes];\n                }).flat();\n            },\n\n            params(get = null){\n                let url = location.href;\n\n                if(!url.includes('?')){\n                    return get? null : {}\n                }\n\n                let result = {},\n                    params = url.replaceAll(/(.*?)\\?/gi, '').split('&')\n                ;\n                \n                for(let param of params){\n                    param = param.split(\"=\");\n                    result[param[0]] = decodeURIComponent(param[1] || \"\").replace(/#(.*)/g,\"\")\n                }\n\n                return get? result[get] : result\n            },\n\n            touchHandle(element, options = {}){\n                let legacyHandle = LS.Util.RegisterMouseDrag(element, options.exclude || false, options, false);\n                return legacyHandle;\n            },\n\n            RegisterMouseDrag(handle, exclude = false, options = {}, old = true){\n                if(!handle || !O(handle)) throw \"Invalid handle!\";\n\n                if(old) console.warn(\"Note: You are using LS.Util.RegisterMouseDrag - this has been replaced by LS.Util.touchHandle. It is recommended to migrate. Backwards compatibility so far is supported.\")\n\n                let events = new LS.EventHandler, cancelled = false;\n\n                options = {\n                    buttons: [0, 1, 2],\n                    ...options\n                }\n\n                if(options.cursor) events.cursor = options.cursor;\n                \n                events.target = handle //The target will change based on the event target!\n\n                let [pointerLockPreviousX, pointerLockPreviousY] = [0, 0];\n\n                function move(event) {\n                    if(cancelled) return;\n\n                    let x, y, isTouchEvent = event.type == \"touchmove\";\n\n                    if(!isTouchEvent) event.preventDefault()\n\n                    if(!events.pointerLockActive) {\n                        x = isTouchEvent? event.touches[0].clientX : event.clientX\n                        y = isTouchEvent? event.touches[0].clientY : event.clientY\n                    }\n\n                    if(options.pointerLock){\n                        // The following adds seamles fallback for pointerlock on touch devices and emulates absolute mouse position for pointerlock!\n                        // This allows you to easily enable/disable pointerlock without losing any functionality or having to write custom fallbacks, on both touch and mouse devices!\n\n                        if(events.pointerLockActive){\n                            x = pointerLockPreviousX += !isNaN(event.movementX)? event.movementX: 0\n                            y = pointerLockPreviousY += !isNaN(event.movementY)? event.movementY: 0\n                        } else if(isTouchEvent){\n                            event.movementX = Math.round(x - pointerLockPreviousX)\n                            event.movementY = Math.round(y - pointerLockPreviousY)\n                            pointerLockPreviousX = x\n                            pointerLockPreviousY = y\n                        }\n                    }\n\n                    if(options.onMove) options.onMove(x, y, event, cancel)\n\n                    events.invoke(\"move\", x, y, event, cancel)\n                }\n\n                function cancel() {\n                    cancelled = true\n                }\n\n                function pointerLockChangeWatch(){\n                    events.pointerLockActive = document.pointerLockElement === handle;\n                }\n\n                document.addEventListener('pointerlockchange',  pointerLockChangeWatch);\n    \n                function release(evt) {\n                    events.seeking = false;\n                    cancelled = false;\n    \n                    handle.class(\"is-dragging\", 0)\n                    events.target.class(\"ls-drag-target\", 0)\n                    document.documentElement.class(\"ls-dragging\",0)\n                    document.removeEventListener(\"mousemove\", move);\n                    document.removeEventListener(\"mouseup\", release);\n                    document.removeEventListener(\"touchmove\", move);\n                    document.removeEventListener(\"touchend\", release);\n                    document.documentElement.style.cursor = \"\";\n    \n                    events.invoke(evt.type == \"destroy\"? \"destroy\" : \"end\", evt)\n\n                    if(events.pointerLockActive){\n                        document.exitPointerLock();\n                    }\n\n                    if(evt.type == \"destroy\")\n                        if(options.onDestroy) options.onDestroy(evt);\n                    else \n                        if(options.onEnd) options.onEnd(evt);\n                }\n\n                function start(event){\n                    if(typeof exclude == \"string\" && event.target.matches(exclude)) return;\n                    if(!exclude && event.target !== handle) return;\n\n                    event.preventDefault()\n\n                    if(event.type == \"mousedown\" && !options.buttons.includes(event.button)) return;\n                    \n                    events.seeking = true;\n\n                    let x = event.type == \"touchstart\"? event.touches[0].clientX : M.x, y = event.type == \"touchstart\"? event.touches[0].clientY : M.y;\n\n                    events.invoke(\"start\", event, cancel, x, y)\n                    if(options.onStart) options.onStart(event, cancel, x, y)\n\n                    if(cancelled) return events.seeking = false;\n\n                    if(options.pointerLock && event.type !== \"touchstart\") {\n\n                        pointerLockPreviousX = M.x\n                        pointerLockPreviousY = M.y\n\n                        if (event.type !== \"touchstart\") handle.requestPointerLock();\n                    }\n\n                    events.target = O(event.target);\n                    events.target.class(\"ls-drag-target\")\n\n                    handle.class(\"is-dragging\")\n                    document.documentElement.class(\"ls-dragging\")\n                    document.addEventListener(\"mousemove\", move);\n                    document.addEventListener(\"mouseup\", release);\n                    document.addEventListener(\"touchmove\", move);\n                    document.addEventListener(\"touchend\", release);\n                    document.documentElement.style.cursor = events.cursor || \"grab\";\n                }\n\n                handle.on(\"mousedown\", \"touchstart\", ...(options.startEvents || []), start)\n\n                events.destroy = function (){\n                    release({type: \"destroy\"})\n                    handle.off(\"mousedown\", \"touchstart\", start)\n                    document.removeEventListener('pointerlockchange',  pointerLockChangeWatch);\n                    cancelled = true;\n                    events.destroy = () => false;\n                    events.destroyed = true\n                    return true\n                }\n\n                return events\n            },\n\n            flatten(obj){\n\n            },\n\n            defaults(defaults, target = {}) {\n                if(typeof target !== \"object\") throw \"The target must be an object\";\n\n                for (const [key, value] of Object.entries(defaults)) {\n                    if (!(key in target)) {\n                        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(defaults, key));\n                    }\n                }\n                return target\n            },\n\n            copy(text) {\n                return new Promise(resolve => {\n                    if (navigator.clipboard && navigator.clipboard.writeText) {\n                        navigator.clipboard.writeText(text)\n                            .then(() => {\n                                resolve()\n                            })\n                            .catch(error => {\n                                resolve(error)\n                            })\n                    } else {\n                        // Old method\n\n                        let temp = N('textarea', {value: text})\n\n                        O().add(temp)\n                        temp.select()\n                        document.execCommand('copy')\n                        \n                        O().removeChild(temp)\n                        resolve()\n                    }\n                })\n            },\n\n            ",{"segment":"manipulator","content":["Manipulate(str,mapper=\" *:\",options){\n    if(!mapper)return [str];\n    //Many of you may be confused on what this is.\n    //Remember the pain of learning regexp?\n    \n    //#~\\n{$>+\": \"} splits string by \\n, for each segment, add a \": \"\n    \">?/::/,\\\\*:/,[/+]*:/\";\n    let d=\"\";\n    let opt={\n        regMatch:/\\[(.*?)\\]/g,\n        blockMatch:/\\{(.*?)\\}/g,\n        stringMatch:/\"(.*?)\"|'(.*?)'|\\[\\[(.*?)\\]\\]/g,\n        bracketID:/\\((.*?)\\)/,\n        cases:{\n            a:\"toLowerCase\",\n            A:\"toUpperCase\",\n            b4:(str)=>btoa(str),\n            Aa:(str)=>str.split(\".\").map(s=>s.replace(/[a-zA-Z]/,l=>l.toUpperCase())).join(\".\"),\n            n:(str)=>+(str.match(/[0-9-]/g)||['0']).join(''),\n            uE:(str)=>encodeURIComponent(str),\n            uD:(str)=>decodeURIComponent(str),\n        },\n        ...options\n    };\n\n    function matchingBracket(){\n\n    }\n\n    let rx={};\n    \n    function getRegex(id,flags){\n        let m=id.match(opt.bracketID);\n        if(m)id=m[1];\n        return new RegExp(rx[id],flags)\n    }\n\n    function parseMapper(mapperString){\n        let _rx=mapperString.match(opt.regMatch),i=[],j=0;\n        _rx=_rx?_rx.map(e=>e.slice(1,-1)):[];\n        for(const regexp of _rx){\n            let id=M.GlobalID;\n            rx[id]=regexp;\n            i.push(id);\n        }\n        console.log(rx);\n        mapperString=mapperString.split(\",\").map(o=>o.replace(opt.stringMatch,()=>'$S('+(i[j++])+')')).map(o=>o.replace(opt.regMatch,()=>'$R('+(i[j++])+')'));\n        return mapperString\n    }\n\n    function block(o,str){\n        console.log(o);\n        if(o.length<1)return str;\n        if(o==\"t\"){\n            return str.trim();\n        }\n        if(opt.cases[o]){\n            if(typeof opt.cases[o]==\"function\"){\n                return str=opt.cases[o](str);\n            }\n            /*-->explanation*/d+=opt.cases[o]+\"\\n\";\n            return str=str[opt.cases[o]]();\n        }\n        if(['>','<','*'].includes(o[0])&&o[1]!=\":\"){\n            if(o[1]==\"?\"){\n                let c=o.slice(2).split(\":\"),i=str[o[0]==\">\"?\"startsWith\":\"endsWith\"](c[0]),r=str[o[0]==\">\"?\"indexOf\":\"lastIndexOf\"](c[0]);\n                if(o[0]==\">\"){\n                    str=str.slice(r<0?0:r);\n                    str=(i?c[1]:c[2])+str\n                }\n                if(o[0]==\"<\"){\n                    str=str.slice(0,r<0?Infinity:r+1)\n                    str+=i?c[1]:c[2];\n                }\n            }\n            return str;\n        }\n        if(o.startsWith(\"at(\")){\n            return str.at(opt.cases.n(o))\n        }\n        let cmd=\"replace\";\n        if(o[0]==\"-\"){\n            if(o[1]==\"*\"){\n                cmd=\"replaceAll\";\n                o=o.slice(1);\n            }\n            o=[o.slice(1),'']\n        }else{\n            o=o.split(\":\");\n            if(o[0].at(-1)==\"*\"){\n                cmd=\"replaceAll\";\n                o[0]=o[0].slice(0,-1);\n            }\n        }\n        if(o[0].startsWith(\"$R\"))o[0]=getRegex(o[0],cmd==\"replaceAll\"?\"g\":\"\");\n        \n        /*-->explanation*/d+=cmd+\" '\"+o[0]+\"' with '\"+o[1]+\"'\\n\";\n        str=str[cmd](o[0],o[1])\n        return str\n    }\n\n    for(const o of parseMapper(mapper)){\n        str=block(o,str);\n    }\n    return str||[str,d]\n}"],"from":"ls-js/deprecated/manipulator.js"},"\n        },\n        ",{"segment":"tiny","content":["\n        TinyFactory(r){\n            let __variablesProxyObject\n\n            return {\n                _affected: true,\n                isElement: true,\n\n                attr(get = false, set = false){\n                    if(set){\n                        r.setAttribute(get, set);\n                        return set\n                    }\n\n                    if(get) return r.getAttribute(get);\n\n                    let a = r.attributes,\n                        c = {}\n                    ;\n\n                    Object.keys(a).map(b => c[a[b].nodeName] = a[b].nodeValue);\n                    return get ? c[get] : c\n                },\n\n                attrAssign(a){\n                    if(typeof a == \"string\") a = {Array: [a]};\n                    if(Array.isArray(a)) a = {Array: a};\n\n                    for(const k in a){\n                        if(!a.hasOwnProperty(k)) continue;\n                        if(k == 'Array'){\n                            for(let attr of a[k]){\n                                if(typeof attr == \"object\"){\n                                    r.attrAssign(attr)\n                                    continue\n                                }\n                                if(attr) r.setAttribute(attr, '');\n                            }\n                            continue\n                        }\n                        ;(k && r.setAttribute(k, a[k] || ''));\n                    }\n\n                    return r\n                },\n\n                hasAttr: r.hasAttribute,\n\n                delAttr(...attribute){\n                    attribute = attribute.flat(2);\n                    attribute.forEach(a => r.removeAttribute(a))\n\n                    return r\n                },\n\n                class(names, action = 1){\n                    if(typeof names == \"undefined\") return [...r.classList];\n                    if(typeof names == \"string\") names = names.split(\" \");\n                    for(let className of names){\n                        if(typeof className !== \"string\" || className.length < 1)continue;\n                        r.classList[(action == \"add\" || (!!action && action !== \"remove\"))? (action == 2 || action == \"toggle\")? \"toggle\": \"add\": \"remove\"] (className)\n                    }\n                    return r\n                },\n\n                hasClass(...names){\n                    let h = !0;\n                    names = names.flatMap(c=>{\n                        if(!r.classList.contains(c)) h=!1\n                    })\n                    return h\n                },\n\n                get(selector = '*'){\n                    return O(r, selector)\n                },\n\n                getAll(t = '*'){\n                    return Q(r, t)\n                },\n\n                getChildern(){\n                    return [...r.children]\n                },\n\n                child(i){\n                    return r.children[i||0]\n                },\n\n                add(...a){\n                    r.append(...LS.Util.resolveElements(...a));\n                    return r.self\n                },\n\n                addBefore(a){\n                    LS.Util.resolveElements(a).forEach(e=>r.parentNode.insertBefore(e,r))\n                    return r\n                },\n\n                addAfter(a){\n                    LS.Util.resolveElements(a).forEach(e=>r.parentNode.insertBefore(e,r.nextSibling))\n                    return r\n                },\n\n                addTo(a){\n                    O(a).add(r)\n                    return r\n                },\n\n                setTo(a){\n                    O(a).set(r)\n                    return r\n                },\n\n                wrapIn(e){\n                    r.addAfter(O(e));\n                    e.appendChild(r);\n                    return r\n                },\n\n                isInView(){\n                    var rect = r.getBoundingClientRect();\n\n                    return rect.top < (window.innerHeight || document.documentElement.clientHeight) && rect.left < (window.innerWidth || document.documentElement.clientWidth) && rect.bottom > 0 && rect.right > 0\n                },\n\n                isEntirelyInView(){\n                    var rect = r.getBoundingClientRect();\n\n                    return (\n                        rect.top >= 0 &&\n                        rect.left >= 0 &&\n                        rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n                        rect.right <= (window.innerWidth || document.documentElement.clientWidth)\n                    );\n                },\n\n                addOnce(a){\n                    console.warn(\"element.addOnce is deprecated, do not rely on it\")\n                    if (!O(r, '#' + a.id)) r.add(a)\n                },\n\n                on(...events){\n                    let func = events.find(e => typeof e == \"function\");\n                    for (const evt of events) {\n                        if (typeof evt != \"string\") continue;\n                        r.addEventListener(evt, func);\n                    }\n\n                    return r.self\n                },\n\n                off(...events){\n                    let func = events.find(e => typeof e == \"function\");\n                    for (const evt of events) {\n                        if (typeof evt != \"string\") continue;\n                        r.removeEventListener(evt, func);\n                    }\n\n                    return r.self\n                },\n\n                get firstFocusable(){\n                    return r.get('a[href], button, input, select, textarea, [tabindex]:not([tabindex=\"-1\"])')\n                },\n\n                hide(){\n                    let current = getComputedStyle(r).display;\n\n                    r.attrAssign({\n                        \"ls-hide-originaldisplay\": current == \"none\"? \"block\": current\n                    })\n\n                    r.style.display = \"none\";\n                    return r\n                },\n\n                show(displayOverride){\n                    // \"ls-hide-originaldisplay\" is kind of ugly, is there a better way?\n\n                    r.style.display = displayOverride || r.attr(\"ls-hide-originaldisplay\") || \"inherit\";\n                    return r\n                },\n\n                applyStyle(rules){\n                    if(typeof rules !== \"object\") throw new Error(\"First attribute of \\\"applyStyle\\\" must be an object\");\n\n                    for(let rule in rules){\n                        if(!rules.hasOwnProperty(rule)) continue;\n\n                        let value = rules[rule];\n\n                        if(!rule.startsWith(\"--\")) rule = rule.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n\n                        r.style.setProperty(rule, value)\n                    }\n                },\n\n                get cssVariables(){\n                    if(!__variablesProxyObject) __variablesProxyObject = new Proxy({}, {\n                        get(target, key){\n                            return r.style.getPropertyValue(`--${key}`)\n                        },\n    \n                        set(target, key, value){\n                            return r.style.setProperty(`--${key}`, value)\n                        }\n                    })\n\n                    return __variablesProxyObject\n                },\n\n                getStyle(){\n                    throw \".getStyle should not be used, use getComputedStyle(element) instead.\"\n                    return getComputedStyle(r)\n                },\n\n                set(...elements){\n                    r.innerHTML = '';\n\n                    return r.add(...elements)\n                },\n\n                clear(){\n                    r.innerHTML = '';\n\n                    return r\n                },\n\n                has(...a){\n                    return !!a.find(l => r.get(l))\n                },\n\n                parent: (n = 0) => r.tagName == 'BODY' ? r.parentElement : (n > 0 ? O(r.parentElement).parent(n - 1) : r.parentElement),\n\n                self: r,\n\n                findPath () {\n                    let path = [r];\n                    \n                    for(let i = 0; path.at(-1)?.tagName != \"HTML\"; i++){\n                        path.push(r.parent(i));\n                        i++\n                    }\n\n                    return path.reverse()\n                }\n            }\n        },\n\n        Tiny:{\n            Q(e, q) {\n                let elements = (e?.tagName && !q ? [e] : [...(e?.tagName ? e : document).querySelectorAll(e?.tagName ? !q ? '*' : q : typeof e == 'string' ? e : '*')])?.map(r => {\n                    if(!r._affected){\n\n                        let methods = LS.TinyFactory(r);\n                        \n                        Object.defineProperties(r, Object.getOwnPropertyDescriptors(methods))\n\n                        if(r.tagName == \"BR\") r.removeAttribute(\"clear\"); // Fixes a bug (i think?)\n                    }\n                    return r.self\n                })\n\n                return Object.assign(elements, {\n                    all(callback){\n                        if(callback) {\n                            for(const [i, a] of elements.entries()) {\n                                callback(a, i)\n                            }\n\n                            return\n                        }\n\n                        function each(func,...attr){\n                            for(const element of elements) {\n                                element[func](...attr)\n                            }\n                        }\n\n                        return new Proxy({}, {\n                            get(target, key){\n                                return (...attr) => each(key, ...attr)\n                            }\n                        })\n                    },\n\n                    allChildern(){\n\n                    }\n                })\n            },\n\n            O(...selector){\n                return LS.Tiny.Q(...selector.length < 1? ['body'] : selector)[0]\n            },\n\n            N(tagName = 'div', content){\n                if(typeof tagName != \"string\"){\n                    content = tagName;\n                    tagName = \"div\";\n                }\n\n                content = (typeof content == 'string'? {innerHTML: content} : Array.isArray(content)? {inner: content} : content) || {};\n\n                let temporary = {};\n\n                if(content.class){\n                    temporary.class = content.class;\n                    delete content.class\n                }\n\n                if(content.tooltip){\n                    temporary.tooltip = content.tooltip;\n                    delete content.tooltip\n                }\n\n                if(content.ns){\n                    temporary.ns = content.ns;\n                    delete content.ns\n                }\n\n                let element = O(Object.assign(\n                    document[temporary.ns? \"createElementNS\" : \"createElement\"] (temporary.ns? temporary.ns : tagName, temporary.ns? tagName : null),\n                    content\n                ));\n\n                if(content.accent){\n                    element.attrAssign({\"ls-accent\": content.accent})\n                    delete content.accent\n                }\n\n                if(content.attr) element.attrAssign(content.attr);\n\n                if(temporary.tooltip) {\n                    if(!LS.Tooltips){\n                        element.attrAssign({\"title\": temporary.tooltip})\n                    }else{\n                        element.attrAssign({\"ls-tooltip\": temporary.tooltip})\n                        LS.Tooltips.addElements([{target: element, attributeName: \"ls-tooltip\"}])\n                    }\n                }\n\n                if(temporary.class && element.class) element.class(temporary.class);\n\n                if(typeof content.style == \"object\") element.applyStyle(content.style);\n\n                if(content.inner || content.content) element.add(content.inner || content.content);\n\n                return element\n            },\n\n            C(r, g, b, a = 1){\n\n                if(typeof r == \"string\"){\n                    let div = N({style: \"display:none;color:\" + r}), m;\n                    O().add(div)\n                    m = getComputedStyle(div).color.match(/^rgb\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$/i);\n                    div.remove()\n            \n                    if(m) return C(+m[1], +m[2], + m[3]); else throw new Error(\"Colour \"+r+\" could not be parsed.\");\n                }\n            \n                if(r === null || typeof r == \"undefined\") r = 255;\n                if(g === null || typeof g == \"undefined\") g = 255;\n                if(b === null || typeof b == \"undefined\") b = 255;\n            \n                r = Math.round(Math.min(255, Math.max(0, r)));\n                g = Math.round(Math.min(255, Math.max(0, g)));\n                b = Math.round(Math.min(255, Math.max(0, b)));\n                a = Math.min(1, Math.max(0, a));\n            \n                let tools = {\n                    get hex(){\n                        return \"#\" + (1 << 24 | r << 16 | g << 8 | b).toString(16).slice(1);\n                    },\n\n                    get rgb(){\n                        return `rgb(${r}, ${g}, ${b})`\n                    },\n\n                    get rgba(){\n                        return `rgba(${r}, ${g}, ${b}, ${a})`\n                    },\n\n                    get hsl(){\n                        let _r = r / 255;\n                        let _g = g / 255;\n                        let _b = b / 255;\n\n                        // Find the minimum and maximum values of R, G and B\n                        let max = Math.max(_r, _g, _b);\n                        let min = Math.min(_r, _g, _b);\n\n                        // Calculate the luminance\n                        let l = (max + min) / 2;\n\n                        let h, s;\n\n                        if (max === min) {\n                            // Achromatic case (gray)\n                            h = s = 0;\n                        } else {\n                            let delta = max - min;\n\n                            // Calculate the saturation\n                            s = l > 0.5 ? delta / (2 - max - min) : delta / (max + min);\n\n                            // Calculate the hue\n                            switch (max) {\n                                case _r:\n                                    h = (_g - _b) / delta + (_g < _b ? 6 : 0);\n                                    break;\n                                case _g:\n                                    h = (_b - _r) / delta + 2;\n                                    break;\n                                case _b:\n                                    h = (_r - _g) / delta + 4;\n                                    break;\n                            }\n                            h /= 6;\n                        }\n\n                        // Convert H, S, and L to percentages\n                        h = Math.round(h * 360);\n                        s = Math.round(s * 100);\n                        l = Math.round(l * 100);\n\n                        return [h, s, l]\n                    },\n            \n                    fromHSL(h, s, l){\n            \n                        s /= 100;\n                        l /= 100;\n            \n                        let k = n => (n + h / 30) % 12,\n                            a = s * Math.min(l, 1 - l),\n                            f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));\n            \n                        return C(255 * f(0), 255 * f(8), 255 * f(4));\n                    },\n\n                    get color(){\n                        return[r, g, b, a]\n                    },\n\n                    get pixel(){\n                        return[r, g, b, a * 255]\n                    },\n\n                    get brightness(){\n                        return Math.sqrt(\n                            0.299 * (r * r) +\n                            0.587 * (g * g) +\n                            0.114 * (b * b)\n                        )\n                    },\n\n                    get isDark(){\n                        return tools.brightness < 127.5\n                    },\n\n                    hue(hue){\n                        let [h, s, l] = tools.hsl;\n\n                        l = Math.max(Math.min(hue, 360), 0)\n\n                        return C().fromHSL(h, s, l)\n                    },\n\n                    saturation(percent){\n                        let [h, s, l] = tools.hsl;\n\n                        s = Math.max(Math.min(percent, 100), 0)\n\n                        return C().fromHSL(h, s, l)\n                    },\n\n                    lighten(percent){\n                        let [h, s, l] = tools.hsl;\n\n                        l = Math.max(Math.min(l + percent, 100), 0)\n\n                        return C().fromHSL(h, s, l)\n                    },\n\n                    darken(percent){\n                        let [h, s, l] = tools.hsl;\n\n                        l = Math.max(Math.min(l - percent, 100), 0);\n\n                        return C().fromHSL(h, s, l)\n                    },\n\n                    // lighten(percent){\n                    //     let [h, s, l] = tools.hsl;\n\n                    //     l = Math.min(l + percent, 1);\n\n                    //     return C().fromHSL(h, s, l)\n                    // },\n                    \n                    hueShift(deg){\n                        let [h, s, l] = tools.hsl;\n                        \n                        h = (h + deg) % 360;\n                        \n                        return C().fromHSL(h, s, l)\n                    },\n\n                    multiply(r2, g2, b2, a2){\n                        let color = C(r2, g2, b2, a2).color;\n\n                        return C(r * color[0], g * color[1], b * color[2], a * color[3])\n                    },\n\n                    divide(r2, g2, b2, a2){\n                        let color = C(r2, g2, b2, a2).color;\n\n                        return C(r / color[0], g / color[1], b / color[2], a / color[3])\n                    },\n\n                    add(r2, g2, b2, a2){\n                        let color = C(r2, g2, b2, a2).color;\n\n                        return C(r + color[0], g + color[1], b + color[2], a + color[3])\n                    },\n\n                    substract(r2, g2, b2, a2){\n                        let color = C(r2, g2, b2, a2).color;\n\n                        return C(r - color[0], g - color[1], b - color[2], a - color[3])\n                    },\n\n                    alpha(v){\n                        return C(r, g, b, v)\n                    },\n\n                    random(){\n                        return C(Math.floor(Math.random() * 256), Math.floor(Math.random() * 256), Math.floor(Math.random() * 256))\n                    }\n                }\n            \n                return tools;\n            },\n\n            M: {\n                x: 0,\n                y: 0,\n\n                _GlobalID: {\n                    count: 0,\n                    prefix: Math.round(Math.random() * 1e3).toString(36) + Math.round(Math.random() * 1e3).toString(36)\n                },\n\n                lastKey: null,\n\n                ShiftDown: false,\n                ControlDown: false,\n\n                mouseDown: false,\n\n                on(...events){\n                    let func = events.find(e => typeof e == \"function\");\n                    for(const evt of events){\n                        if(typeof evt != \"string\") continue;\n                        global.addEventListener(evt, func)\n                    }\n                    return M\n                },\n\n                get GlobalID(){\n                    // return M.GlobalIndex.toString(36)\n\n                    M._GlobalID.count++;\n\n                    return `${Date.now().toString(36)}-${(M._GlobalID.count).toString(36)}-${M._GlobalID.prefix}`\n                },\n\n                uid(){\n                    return M.GlobalID + \"-\" + crypto.getRandomValues(new Uint32Array(1))[0].toString(36)\n                },\n\n                payloadSignature(title, dataArray = [], paddingSize = 128, base = 16){\n                    if(dataArray.length > paddingSize){\n                        throw \"The length of data cannot exceed the padding size\"\n                    }\n\n                    if(base < 16 || base > 36) throw \"base must be a number between 16 and 36\";\n\n                    let encoder = new TextEncoder();\n\n                    for(let i = 0; i < dataArray.length; i++){\n                        if(!(dataArray[i] instanceof Uint8Array) && typeof dataArray[i] !== \"string\") throw \"Data can only be a string or an Uint8Array.\";\n                        dataArray[i] = typeof dataArray[i] === \"string\"? encoder.encode(dataArray[i]): dataArray[i];\n                    }\n\n                    dataArray.push(crypto.getRandomValues(new Uint8Array(paddingSize - dataArray.length)));\n\n                    let data = dataArray.map(data => [...data].map(value => value.toString(base).padStart(2, \"0\")).join(\"\")).join(\":\") + \"0\" + (base -1).toString(base)\n\n                    return `---signature block start \"${M.uid()}${title? \"-\"+ title: \"\"}\"---\\n${data}\\n---signature block end---`\n                },\n\n                parsePayloadSignature(signature){\n                    if(!signature.startsWith(\"---signature block start\") || !signature.endsWith(\"\\n---signature block end---\")) throw \"Invalid signature data\";\n\n                    let header = signature.match(/---signature block start \"(.*?)\"---\\n/)[1].split(\"-\"), timestamp, id, instanceID;\n\n                    timestamp = parseInt(header[0], 36)\n                    id = parseInt(header[1], 36)\n                    instanceID = parseInt(header[2], 36)\n                    header = header[4] || null\n\n                    function decodeBody(hexString) {\n                        const byteArray = new Uint8Array(hexString.length / 2);\n\n                        for (let i = 0; i < hexString.length; i += 2) {\n                            byteArray[i / 2] = parseInt(hexString.substring(i, i + 2), base);\n                        }\n                        \n                        return byteArray;\n                    }\n\n                    let rawBody = signature.match(/['\"t]---\\n(.*?)\\n---signature block end/s)[1], base = parseInt(rawBody.slice(-2), 36) +1;\n                    \n                    let body = rawBody.split(\":\").map(payload => decodeBody(payload));\n                    \n                    let padding = body.pop()\n\n                    return { header, body, padding, timestamp, id, instanceID }\n                },\n\n                Style(url, callback){\n                    return new Promise((resolve, reject)=>{\n                        O(\"head\").add(N(\"link\", {\n                            rel: \"stylesheet\",\n                            href: url,\n                            onload(){\n                                if(callback) callback()\n                                resolve()\n                            },\n                            onerror(error){\n                                if(callback) callback(error)\n                                reject(error.toString())\n                            }\n                        }))\n                    })\n                },\n\n                Script(url, callback){\n                    return new Promise((resolve, reject)=>{\n                        LS.Tiny.O(\"head\").add(LS.Tiny.N(\"script\", {\n                            src: url,\n                            onload(){\n                                if(callback) callback()\n                                resolve()\n                            },\n                            onerror(error){\n                                if(callback) callback(error)\n                                reject(error.toString())\n                            }\n                        }))\n                    })\n                },\n\n                GetDocument(url, callback){\n                    return new Promise((resolve, reject) => {\n                        fetch(url)\n                            .then(async response => {\n                                let data = N(\"div\", await response.text());\n\n                                if(callback) callback(null, data);\n                                resolve(data)\n                            })\n                            .catch(error => {\n                                let message = error.toString();\n\n                                if(callback) callback(message);\n                                reject(message)\n                            })\n                    })\n                },\n\n                loop(times, ...functions){\n                    for(let i = 0; i < times; i++){\n                        for(const fn of functions){\n                            fn(i)\n                        }\n                    }\n                }\n            }\n        },\n        "]},"\n        LoadComponents(components){\n            for(const name in components){\n                if(!components.hasOwnProperty(name)) continue;\n\n                if(LS[name]) {\n                    console.warn(`[LS Framework] Duplicate component name ${name}, import was ignored!`);\n                    continue\n                }\n\n                LS[name] = function ComponentInstance(id, ...attributes){\n                    if(LS[name].conf.isFunction) return (LS[name].class({})) (id, ...attributes);\n                    return (LS[name].list[id || \"default\"]) || (LS[name].new(id, ...attributes));\n                }\n\n                LS[name].new = function (id, ...attributes){\n                    if(id instanceof Element) {\n                        attributes.unshift(id);\n                        id = id.id || \"default\"\n                    }\n\n                    if(typeof id === \"object\" && id !== null) {\n                        attributes.unshift(id);\n                        id = (id && id.id) || \"default\"\n                    }\n\n                    if(attributes[0] instanceof Element){\n                        attributes[0] = O(attributes[0]);\n\n                        if(id && attributes[0].attr(\"ls-component\") === id.toLowerCase()) {\n                            let previous = LS[name].list[id]\n                            if(previous) return previous\n                        }\n\n                        attributes[0].attr(\"ls-component\", name.toLowerCase())\n                    }\n\n                    let ClassInstance = new((LS[name].class)({})) (id, ...attributes);\n\n                    if(LS[name].conf.events) ClassInstance.Events = new LS.EventHandler(ClassInstance);\n\n                    if(id) {\n                        ClassInstance.id = id;\n                        LS[name].list[id] = ClassInstance;\n                    }\n\n                    if(ClassInstance._init) ClassInstance._init();\n                    return ClassInstance\n                }\n\n                LS[name].set = function (key, value){\n                    LS[name][key] = value\n                }\n\n                LS[name].list = LS[name].conf = {};\n\n                LS[name].class = ((components[name]) (LS[name]));\n\n                let dependencies = LS[name].conf? LS[name].conf.requires : null;\n\n                if(Array.isArray(dependencies)){\n                    for(const dependency of dependencies){\n                        if(!LS[dependency] || !components[dependency]){\n                            delete LS[name];\n                            LS[name] = false;\n                            console.error(`[LS Framework] Unmet dependency of \"${name}\": \"${dependency}\" ${ dependencies.length > 1? `(All dependencies are: ${dependencies.map(dependency => '\"' + dependency + '\"').join(\", \")})` : '' }\\nThis component will not work until the dependencies are met.`);\n                            break\n                        }\n                    }\n                    if(!LS[name]) continue;\n                }\n\n                // Component config\n                LS[name].conf = {\n                    batch: true,\n                    events: true,\n                    ... LS[name].conf\n                };\n\n                if(LS[name].conf.events) LS[name].Events = new LS.EventHandler(LS[name]);\n\n                if(LS[name].conf.singular){\n\n                    if(LS[name].conf.becomeClass) {\n                        LS[name] = LS[name].class;\n                        continue\n                    }\n\n                    LS[name] = LS[name].new(\"global\");\n\n                }else if(LS[name].conf.batch){\n\n                    LS[name].batch =  function(elements, config, unique = true) {\n                        if(typeof elements == \"string\") elements = Q(elements);\n\n                        if(!Array.isArray(elements)) e = [...O(elements).children];\n\n                        for(const element of elements){\n                            new LS[name].new((unique? element.id : null) || \"auto_\" + M.GlobalID, element, config)\n                        }\n                    }\n\n                    // Legacy\n                    LS[name].registerGroup = LS[name].batch;\n\n                    LS[name].observe = function (selector, previous, parent = O()) {\n                        throw \"LS.Component.observe has been removed\"\n                    }\n\n                    if(LS.invoke){\n                        LS.invoke(\"componentLoad\", name)\n                        LS.invoke(\"componentLoad:\" + name)\n                    }\n                }\n            }\n        }\n    }\n    ",{"segment":"tiny","content":["\n    if(LS.isWeb){\n        // Expose LS.Tiny globally\n        for (let key in LS.Tiny){\n            global[key] = LS.Tiny[key]\n        }\n\n        M.on(\"mousemove\", \"touchmove\", \"touchstart\", e =>{\n            let source = (e.type !== \"mousemove\" ? e.touches[0] : e);\n            M.x = source.clientX\n            M.y = source.clientY\n        })\n\n        M.on(\"keydown\", e => {\n            M.lastKey = e.key;\n            if(e.key == \"Shift\") M.ShiftDown = true;\n            if(e.key == \"Control\") M.ControlDown = true;\n        })\n\n        M.on(\"keyup\", e => {\n            M.lastKey = e.key;\n            if(e.key == \"Shift\") M.ShiftDown = false;\n            if(e.key == \"Control\") M.ControlDown = false;\n        })\n\n        M.on(\"mousedown\", () => M.mouseDown = true)\n        M.on(\"mouseup\", () => M.mouseDown = false);\n\n        O(document.documentElement)\n    }\n    "]},"\n}\n\n"]},"\n\n",{"segment":"eventresolver","content":["\nLS.LoadComponents({\n    ",{"segment":"eventresolver","content":["EventResolver(gl){\n    gl.conf = {\n        batch: false,\n        events: false,\n        singular: true,\n        becomeClass: true\n    }\n\n    return () => {\n        console.warn(\"LS.EventResolver is deprecated; You should migrate to LS.EventHandler\")\n        return LS.EventHandler\n    }\n},"],"from":"ls-js/eventresolver.js"},"\n})\n\nLS.EventHandler = function (target, options) {\n    return ((_this) => new class EventClass {\n        constructor(){\n            this.listeners = [];\n            this.events = {};\n\n            _this = this;\n\n            if(target){\n                for(let key of [\"invoke\", \"on\", \"once\", \"off\"]){\n                    if(!target.hasOwnProperty(key)) target[key] = this[key]\n                }\n\n                this.target = target\n            }\n        }\n\n        prepare(event){\n            if(typeof event == \"string\"){\n                event = {name: event}\n            }\n\n            let name = event.name;\n            delete event.name;\n\n            _this.events[name] = {... (_this.events[name] || null), ...event};\n\n            return event\n        }\n\n        async invoke(name, ...data){\n            _this.prepare(name);\n\n            if(typeof name !== \"string\") name = name.name;\n\n            let ReturnValues = [];\n\n            for(const listener of _this.listeners){\n                if(!listener || listener.for !== name) continue;\n\n                ReturnValues.push(await listener.f(...data));\n\n                if(listener.once) delete _this.listeners[listener.i];\n            }\n\n            return ReturnValues\n        }\n\n        on(type, callback, extra){\n            let index = _this.listeners.length;\n\n            _this.invoke(\"event-listener-added\", index)\n\n            if(_this.events[type]){\n                let evt = _this.events[type];\n                if(evt.completed) callback();\n            }\n\n            _this.listeners.push({\n                for: type,\n                f: callback,\n                i: index,\n                id: M.GlobalID,\n                ...extra\n            })\n\n            return _this.target || _this\n        }\n\n        once(type, callback, extra){\n            _this.on(type, callback, {\n                once: true,\n                ...extra\n            })\n\n            return _this.target || _this\n        }\n\n        off(type, event){\n            if(typeof type === \"function\") event = type;\n\n            for(const listener of _this.listeners){\n                if(listener.f === event) return delete _this.listeners[listener.i];\n            }\n\n            return false\n        }\n\n        completed(event){\n            _this.invoke(event)\n\n            _this.prepare({\n                name: event,\n                completed: true\n            })\n        }\n\n        onChain(...events){\n            let func = events.find(event => typeof event === \"function\");\n\n            for(const event of events){\n                _this.on(event, func);\n            }\n\n            return _this.target || _this\n        }\n\n        destroy(){\n            _this.on = _this.off = _this.invoke = () => {}\n            _this.listeners = []\n            _this.events = []\n            delete _this.target\n            delete _this.listeners\n            delete _this.events\n        }\n    })()\n}\n\nLS.GlobalEvents = new LS.EventHandler(LS)\n\n;(()=>{\n\n    LS.once(\"body-available\", ()=>{\n        LS._topLayer = N({id: \"ls-top-layer\", attr: \"ls\"});\n        LS._topLayerInherit = function (element = document.body) {\n            O(element);\n            LS._topLayer.attrAssign({\n                \"ls-theme\": element.attr(\"ls-theme\"),\n                \"ls-style\": element.attr(\"ls-style\"),\n                \"ls-accent\": element.attr(\"ls-accent\")\n            })\n        }\n\n        LS._topLayerInherit()\n\n        O().addAfter(LS._topLayer)\n\n        LS.GlobalEvents.prepare({\n            name: \"body-available\",\n            completed: true\n        })\n    })\n\n    if(document.body) LS.invoke(\"body-available\"); else M.on(\"load\", () => LS.invoke(\"body-available\"));\n})();\n"]},"\n\n\n",{"segment":"websocket","content":["\nLS.WebSocket = class {\n\n    // LS.WebSocket is a WebSocket client wrapper that modifies the API to be easier to use. It replaces addEventListener with \"on\" and adds some helper features, allows for much easier auto-reconnection etc.\n    // It is backwards-compatible and allows to persist event handlers even after the socket has been closed or re-connected.\n\n    constructor(url, options = {}){\n        if(!url) throw \"No URL specified\";\n\n        if(!url.startsWith(\"ws://\") || !url.startsWith(\"wss://\")) url = (location.protocol === \"https:\"? \"wss://\": \"ws://\") + url;\n\n        this.events = new LS.EventHandler(this);\n\n        this.addEventListener = this.on;\n        this.removeEventListener = this.off;\n\n        if(Array.isArray(options) || typeof options === \"string\"){\n            options = {protocols: options}\n        }\n\n        if(typeof options !== \"object\" || options === null || typeof options === \"undefined\") options = {};\n\n        this.options = LS.Util.defaults({\n            autoReconnect: true,\n            autoConnect: true,\n            delayMessages: true,\n            protocols: null\n        }, options)\n\n        this.waiting = [];\n\n        Object.defineProperty(this, \"readyState\", {\n            get(){\n                return this.socket.readyState\n            }\n        })\n\n        Object.defineProperty(this, \"bufferedAmount\", {\n            get(){\n                return this.socket.bufferedAmount\n            }\n        })\n\n        Object.defineProperty(this, \"protocol\", {\n            get(){\n                return this.socket.protocol\n            }\n        })\n\n        this.url = url;\n        if(this.options.autoConnect) this.connect();\n    }\n\n    connect(){\n        if(this.socket && this.socket.readyState === 1) return;\n\n        this.socket = new WebSocket(this.url, this.options.protocols || null);\n\n        this.socket.addEventListener(\"open\", event => {\n            if(this.waiting.length > 0){\n                for(let message of this.waiting) this.socket.send(message);\n                this.waiting = []\n            }\n\n            this.invoke(\"open\", event)\n        })\n\n        this.socket.addEventListener(\"message\", event => {\n            this.invoke(\"message\", event)\n        })\n\n        this.socket.addEventListener(\"close\", async event => {\n            let prevent = false;\n\n            this.invoke(\"close\", event, () => {\n                prevent = true\n            })\n\n            if(!prevent && this.options.autoReconnect) this.connect();\n        })\n\n        this.socket.addEventListener(\"error\", event => {\n            this.invoke(\"error\", event)\n        })\n    }\n\n    send(data){\n        if(!this.socket || this.socket.readyState !== 1) {\n            if(this.options.delayMessages) this.waiting.push(data)\n            return false\n        }\n\n        this.socket.send(data)\n        return true\n    }\n\n    close(code, message){\n        this.socket.close(code, message)\n    }\n}\n"]},"\n\nLS.LoadComponents({\n    ",{"segment":"modal","content":["Modal(gl){\n    let layer = 50000;\n\n    gl.build = function (template, options){\n        let instance = gl.new(M.GlobalID, null, {open: false, ...options});\n        instance.fromTemplate(template)\n\n        return instance\n    }\n\n    gl.highestModal = function (){\n        let openModals = Object.values(LS.Modal.list).filter(modal => modal.isOpen);\n\n        return openModals.length > 0? openModals.reduce((prev, current) => (prev.layer > current.layer) ? prev : current) : null\n    }\n\n    return(_this) => class LS_Modal{\n        constructor(id, element = N(), options = {}){\n            _this = this;\n\n            this.options = LS.Util.defaults({\n                uncancelable: false,\n                open: false,\n                shade: true,\n                keep: true,\n                animationDelay: 100\n            }, options);\n\n            Object.defineProperty(this, \"isOpen\", {\n                get(){\n                    if(!_this.element) return false;\n                    return (!_this.element.hasAttr('open') || _this.element.attr('open') === \"true\");\n                }\n            })\n\n            Object.defineProperty(this, \"content\", {\n                get(){\n                    if(!_this.element) return false;\n                    return _this.element.get(\".ls-modal-content\")\n                },\n                set(value){\n                    if(!_this.element) return;\n                    return _this.element.get(\".ls-modal-content\").set(value)\n                }\n            })\n\n            Object.defineProperty(this, \"title\", {\n                get(){\n                    if(!_this.element) return false;\n                    return _this.element.get(\".ls-modal-title\")\n                },\n                set(value){\n                    if(!_this.element) return;\n                    return _this.element.get(\".ls-modal-title\").set(value)\n                }\n            })\n\n            this.open = _this.show;\n            this.close = _this.hide;\n\n            _this.closeTimeout = 0;\n\n            if(element) this.setContent(element);\n\n            LS.once(\"body-available\", () => {\n                if(!gl.targetElement){\n                    if(!LS._topLayer.has(\".modals\")) LS._topLayer.add(N({class: \"modals\"}));\n                    gl.targetElement = LS._topLayer.get(\".modals\");\n                }\n\n                if(element) gl.targetElement.add(this.element)\n            })\n        }\n        \n        _init(){\n            if(_this.options.open) _this.open(); else _this.close()\n        }\n\n        setContent(content){\n            _this.element = _this.options.shade? N(\"ls-shade-fixed\", {\n                onclick(){\n                    if(!(_this.options.uncancelable || _this.options.uncancellable) && event.target == this){\n                        _this.hide()\n                    }\n                },\n                inner: content\n            }) : content;\n\n            _this.element.attr(\"open\", \"false\")\n            _this.element.hide()\n        }\n\n        handleKey(event){\n            if(gl.highestModal().id !== _this.id) return;\n\n            let key = event.key;\n\n            switch(key){\n                case \"Enter\":\n\n                break;\n                case \"Escape\":\n                    if(!(_this.options.uncancelable || _this.options.uncancellable)){\n                        _this.close()\n                    }\n                break;\n            }\n        }\n\n        show(){\n            if(_this.isOpen || !_this.element) return false;\n\n            _this.lastFocus = document.activeElement;\n            \n            let firstFocusable = _this.element.firstFocusable;\n\n            if(firstFocusable) firstFocusable.focus();\n\n            window.addEventListener(\"keyup\", _this.handleKey)\n\n            LS.once(\"body-available\", () => {\n                if(_this.closeTimeout > 0) {\n                    clearTimeout(_this.closeTimeout)\n                    _this.closeTimeout = 0;\n                }\n\n                _this.invoke(\"open\");\n\n                _this.element.style.display = null;\n                \n                setTimeout(()=>{\n                    _this.element.attr('open', \"true\");\n                }, 40)\n\n                _this.element.style.zIndex = layer;\n                _this.layer = layer;\n                layer++;\n            })\n        }\n\n        hide(){\n            if(!_this.isOpen || !this.element) return false;\n\n            _this.invoke(\"close\");\n            _this.element.attr('open', \"false\");\n\n            if(_this.lastFocus) _this.lastFocus.focus();\n\n            window.removeEventListener(\"keyup\", this.handleKey)\n\n            _this.closeTimeout = setTimeout(() => {\n                if(!_this.options.keep){\n                    _this.destroy()\n                    return\n                }\n\n                _this.element.style.display = \"none\";\n            }, _this.options.animationDelay)\n        }\n\n        fromTemplate(template){\n            if(typeof template == \"string\") template = {content: template};\n\n            let buttons = []\n            if(template.buttons) for(let button of template.buttons){\n                if(typeof button == \"string\") button = {text: button};\n\n                let element = N(\"button\", {\n                    inner: button.text,\n                    class: \"elevated\"\n                })\n\n                element.onclick = function(...pass){\n                    \n                    if(!button.keep) {\n                        _this.hide()\n                    }\n\n                    if(button.onclick) button.onclick.call(this, ...pass);\n                }\n                \n                if(button.color) element.attr(\"ls-accent\", button.color)\n\n                buttons.push(element)\n            }\n            \n            let modal = N(\"ls-modal\", [\n                N(\"ls-modal-body\", [template.title? N(\"h2\", {inner: template.title, class: \"ls-modal-title\"}): \"\", N({inner: template.content, class: \"ls-modal-content\"})]),\n                N(\"ls-modal-footer\", buttons.length > 0? buttons: \"\")\n            ])\n\n            if(template.uncancelable || template.uncancellable) _this.options.uncancelable = true;\n\n            _this.setContent(modal)\n\n            _this.element.style.display = \"none\";\n\n            LS.once(\"body-available\", () => {\n                gl.targetElement.add(_this.element)\n            })\n        }\n\n        destroy(){\n            _this.element.remove()\n            _this.element = null\n        }\n    }\n},"],"from":"ls-js/modal.js"},{"segment":"tabs","content":["Tabs(gl){\n    return(_this) => class Tabs{\n        constructor(id, element = O(\"tabs\"), options = {}){\n            _this = this;\n            this.element = O(element);\n            this.wrapper = O(element);\n\n            if(!this.element) throw new Error(\"No element provided\");\n\n            this.tabs = {};\n            this.order = [];\n            this.uniqueIDList = [];\n\n            this.options = {\n                list: true,\n                listClass: \"\",\n                listItemClass: \"\",\n                listClickable: true,\n                hide: true,\n                noStyle: false,\n                mode: \"default\",\n                listElement: null,\n                infinite: true,\n                ...options\n            }\n\n            if(this.options.listElement) O(_this.options.listElement).class([\"tablist\", _this.options.listClass]);\n\n            if(this.options.list){\n                this.list = {};\n                this.listElement = _this.options.listElement || N(\"div\", {\n                    class: \"tablist \" + _this.options.listClass + (_this.options.noStyle?\"\":\" tablist-style\")\n                })\n\n                if(this.options.dragDrop) {\n                    this.dragDrop = LS.DragDrop(id + \"_tabs_drag\", {\n                        animate: false,\n                        relativeMouse: true,\n                        dropPreview: true,\n                        absoluteX: true,\n                        container: this.listElement,\n                        sameParent: true,\n                        strictDrop: false,\n                        scrollY: false,\n                        outsideParent: true\n                    })\n    \n                    this.dragDrop.enableDrop(this.listElement)\n                }\n\n                this.wrapper = N({class: \"ls-tabs-wrapper\"})\n\n                for(let child of this.element.getChildern()){\n                    this.wrapper.add(child)\n                }\n\n                this.element.class(\"ls-tabs-with-list\")\n                this.element.add(this.wrapper)\n\n                if(!this.options.listElement) O(element).prepend(this.listElement)\n            }\n\n            this.rescan()\n        }\n\n        _init(){\n            _this.setActive(0);\n        }\n\n        setActive(tab, force=false){\n            if(typeof tab==\"number\"){\n                tab = _this.order[tab]\n            }\n\n            let element = _this.tabs[tab],\n                index = _this.order.indexOf(tab)\n\n            if(!element)return false;\n            if(_this.activeTab == tab && !force) return true;\n\n            if(_this.options.list){\n                Object.keys(_this.list).forEach(t=>{\n                    _this.list[t].class(\"active\", tab == t)\n                })\n            }\n\n            for(const _tab in _this.tabs){\n                let _element = O(_this.tabs[_tab]);\n                if(!_element || _tab == tab){\n                    continue\n                }\n                _element.class(\"tab-active\",0)\n                if(_this.options.hide && _this.options.mode != \"presentation\") _element.hide()\n            }\n\n            element.style.display = \"\"\n            element.class(\"tab-active\")\n\n            _this.element.attr(\"active-tab\", tab)\n            _this.activeTab = tab\n            _this.tab = index\n            _this.invoke(\"tab_changed\", index, tab)\n            return true\n        }\n\n        rescan(){\n            (\n                _this.options.select? O(_this.wrapper).getAll(_this.options.select) : [...O(_this.wrapper).children]\n            ).forEach(element => {\n\n                if(O(element).hasClass(\"tablist\")) return; // Deprecated\n\n                if(element.uniqueTabID && _this.uniqueIDList.includes(element.uniqueTabID)) return;\n\n                element.uniqueTabID = M.GlobalID;\n                _this.uniqueIDList.push(element.uniqueTabID);\n                _this.addExisting(element)\n\n            })\n        }\n\n        addExisting(element, opt = {}){\n            return _this.add(null, element, {isReady: true, ...opt})\n        }\n\n        add(title, content = N(), opt = {}){\n            let element = opt.isReady&&content ?O(content): N(\"ls-tab\",{\n                inner: content,\n                attr: {\"tab-title\": title}\n            });\n\n            if(!element.hasAttr(\"tab-title\")) element.attr(\"tab-title\", title)\n\n            let id = opt.id||(typeof opt == \"string\"&&opt) || content.id || element.attr(\"tab-id\") || \"tab_\"+M.GlobalID;\n            element.attr(\"tab-id\", id)\n\n            if(!opt.isReady)_this.wrapper.add(element);\n            _this.tabs[id] = element;\n            _this.order.push(id);\n\n            _this.addToList(id);\n            return id;\n        }\n\n        addToList(tab){\n            //FIXME: Make it more like \"updateList\" that updates the order\n            if(!_this.options.list) return;\n\n            let element = _this.tabs[tab], tabHandle = N(\"div\",{\n                innerHTML:element.attr(\"tab-title\")||tab,\n                attr:{for:tab},\n                className:\"_tab \"+(_this.options.noStyle?\"\":\"_tab_style \")+_this.options.listItemClass,\n                onclick(){if(_this.options.listClickable)_this.setActive(tab)}\n            });\n\n            if(this.options.dragDrop) this.dragDrop.enableDrag(tabHandle);\n            _this.list[tab] = tabHandle\n            _this.listElement.add(tabHandle)\n        }\n\n        remove(id){\n            // TODO: Maybe make this work\n        }\n\n        next(){\n            _this.tab = _this.tab > _this.length() - 2? _this.options.infinite? 0 : _this.tab : _this.tab + 1;\n            _this.setActive(_this.tab)\n        }\n\n        previous(){\n            _this.tab=_this.tab < 1? _this.options.infinite? _this.length() - 1 : _this.tab : _this.tab - 1;\n            _this.setActive(_this.tab)\n        }\n\n        length(){\n            return _this.tabs.length\n        }\n    }\n},"],"from":"ls-js/tabs.js"},{"segment":"dragdrop","content":["DragDrop(gl){\n    let initialX = 0, prevX = 0, velocityX = 0, initialY = 0, prevY = 0, velocityY = 0, activeInstance, relative, scrollAllowed = false, prevMargin, boundX, boundY, target = null, snapValues;\n    function frame(){\n\n        let x = M.x,\n            y = M.y\n        ;\n\n        let parentBox = getParentBox(), scrollBox = getParentBox(true);\n\n        if(activeInstance.options.relativeMouse){\n            x -= relative.x\n            y -= relative.y\n        }\n        \n        if(gl.firstFrame){\n            gl.firstFrame = false;\n            prevX = x\n            prevY = y\n        }\n\n        if(M.ShiftDown && prevX !== null || activeInstance.options.lockX) x = prevX;\n\n        if(activeInstance.options.lockY) y = prevY;\n\n        if(Array.isArray(snapValues)){\n            for(let value of snapValues){\n                if(value - x > -activeInstance.options.snapArea && value - x < activeInstance.options.snapArea) {x = value; break};\n            }\n        }\n\n        if(!activeInstance.options.lockX) gl.dragArea.style.left = x +\"px\"\n        if(!activeInstance.options.lockY) gl.dragArea.style.top = y +\"px\"\n\n        if(activeInstance.options.animate){\n            if(x !== prevX) {velocityX = x - prevX} else {if(velocityX > 0) {velocityX--} else {velocityX++}}\n            if(y !== prevY) {velocityY = prevY - y} else {if(velocityY > 0) {velocityY--} else {velocityY++}}\n            \n            gl.dragArea.style.transform = `translate(${activeInstance.options.relativeMouse? \"0\" : \"-50%\"}, ${velocityY}px) rotate(${velocityX}deg)`\n        }\n\n        prevX = x\n        prevY = y\n\n        if(activeInstance.options.absoluteX) {\n            boundX = (gl.current.getBoundingClientRect().left - parentBox.left) + getParent().scrollLeft;\n            if(!activeInstance.options.overflow && boundX < 0){\n                boundX = 0\n            }\n            if(activeInstance.options.dropPreview){\n                gl.previewBox.style.left = boundX + \"px\"\n            }\n        }\n\n        if(activeInstance.options.absoluteY) {\n            boundY = (gl.current.getBoundingClientRect().top - parentBox.top) + getParent().scrollTop;\n            if(!activeInstance.options.overflow && boundY < 0){\n                boundY = 0\n            }\n            if(activeInstance.options.dropPreview){\n                gl.previewBox.style.top = boundY + \"px\"\n            }\n        }\n\n        if(scrollAllowed){\n            if(activeInstance.options.scrollY) {\n                if(M.y > scrollBox.bottom) getParent(true).scrollBy(null, Math.min(40, M.y - scrollBox.bottom))\n                if(M.y < scrollBox.top) getParent(true).scrollBy(null, Math.min(40, -(scrollBox.top - M.y)))\n            }\n\n            if(activeInstance.options.scrollX) {\n                if(M.x > (scrollBox.right - 20)) getParent(true).scrollBy(Math.min(40, (M.x - (scrollBox.right - 20))/2), null)\n                if(M.x < (scrollBox.left + 20)) getParent(true).scrollBy(Math.min(40, -(((scrollBox.left + 20)) - M.x)/2), null)\n            }\n        }\n\n        if(gl.moving && gl.dragArea) requestAnimationFrame(frame);\n    }\n\n    function getParentBox(scrollBox, instance = activeInstance){\n        return getParent(scrollBox, instance).getBoundingClientRect()\n    }\n\n    function getParent(scroll, instance = activeInstance){\n        return O((scroll? instance.options.scrollContainer : instance.options.container) || instance.options.container || (gl.current? gl.current.parentElement: instance.element))\n    }\n\n    function isAllowed(source, target){\n        // TODO: Check for groups\n        return target.lsDropTarget === activeInstance.id || activeInstance.options.allowedTargets.includes(target.lsDropTarget) || target === getParent()\n    }\n\n    function dropHover(drop){\n        if(!isAllowed(gl.current, drop)) return;\n\n        aX = gl.previewBox.getBoundingClientRect().left;\n\n        target = drop;\n\n        if(gl.moving && gl.dragArea && activeInstance.options.dropPreview){\n            gl.previewBox.style = `\n                height: ${gl.current.clientHeight}px;\n                width: ${gl.current.clientWidth}px;\n                margin: ${prevMargin};\n                border-radius: ${getComputedStyle(gl.current).borderRadius};x\n                display: ${getComputedStyle(gl.current).display};\n                position: absolute;\n            `\n\n            if(activeInstance.options.absoluteX) gl.previewBox.style.marginRight = gl.previewBox.style.marginLeft = \"0px\";\n            if(activeInstance.options.absoluteY) gl.previewBox.style.marginTop = gl.previewBox.style.marginBottom = \"0px\";\n\n            drop.add(gl.previewBox)\n        }\n    }\n\n    function waitForIt(){\n        if(!gl.engaged) return;\n        \n        if(Math.abs(initialX - M.x) < activeInstance.options.tolerance && Math.abs(initialY - M.y) < activeInstance.options.tolerance) {\n            return setTimeout(waitForIt, 1)\n        }\n\n        if(activeInstance.options.outsideParent && gl.current.parentElement.matches(\":hover\")) return setTimeout(waitForIt, 1);\n\n        // Start the actual drag\n        dropHover(activeInstance.options.sameParent? getParent() : gl.current.parent)\n\n        scrollAllowed = getParent().matches(\":hover\");\n\n        gl.moving = true\n        gl.dragArea.clear()\n        gl.dragArea.style.transform = \"\";\n        \n        if(activeInstance.options.clone){\n            gl.current = N({innerHTML: gl.current.outerHTML}).get(\"*\")\n        }else{\n            gl.current.style.margin = \"0\";\n        }\n\n        gl.current.class(\"ls-held\")\n\n        let snap = activeInstance.options.getters.snapAt;\n        if(Array.isArray(snap)){\n            snapValues = [];\n            for(let element of snap){\n                let box = element.getBoundingClientRect(),\n                    sub = [\n                        box.left,\n                        box.right,\n                        box.left - gl.current.clientWidth,\n                        box.right - gl.current.clientWidth,\n                    ]\n                ;\n\n                snapValues.push(...sub)\n            }\n        }\n\n        requestAnimationFrame(frame)\n        \n        gl.dragArea.add(gl.current)\n\n        if(activeInstance.options.absoluteX){\n            gl.current.style.left = \"0\";\n        }\n\n        if(activeInstance.options.preserveHeight){\n            gl.dragArea.style.height = relative.box.height +\"px\"\n        }\n\n        if(activeInstance.options.sameParent){\n            dropHover(getParent())\n        }\n\n        gl.dragArea.show()\n\n        activeInstance.invoke(\"drag\", gl.current)\n    }\n\n    async function end(){\n        if(gl.moving && gl.dragArea){\n            gl.moving = false\n\n            let drop = activeInstance.options.movementOnly? gl.parent : (!activeInstance.options.strictDrop ? target : O(document.elementsFromPoint(M.x, M.y).reverse().find(e => e.lsDrop)));\n            \n            if(drop && drop.lsDrop && isAllowed(gl.current, drop)){\n                \n                // Dropped sucessfully\n                let push = true, morph = true, event = {\n                    cancelPush(){\n                        push = false\n                    },\n                    cancelMorph(){\n                        morph = false\n                    },\n                    source: activeInstance.id,\n                    target: drop.lsDropTarget,\n                    boundX,\n                    boundY,\n                    boundWidth: gl.current.clientWidth,\n                    boundHeight: gl.current.clientHeight\n                };\n                \n                \n                let instance = LS.DragDrop.list[drop.lsDropTarget] || activeInstance;\n                \n                await instance.invoke(\"drop\", gl.current, drop, event)\n\n                if(morph && activeInstance.options.absoluteX){\n                    gl.current.style.left = boundX + \"px\";\n                }\n\n                if(morph && activeInstance.options.absoluteY){\n                    gl.current.style.top = boundY + \"px\";\n                }\n                \n                if(push) {\n                    if(activeInstance.options.swap){\n                        drop.add(gl.current)\n                        let swap = drop.getAll(\"*\").find(e => e.lsDrag);\n                        if(!swap) return;\n                        gl.parent.add(swap)\n                    } else {\n                        drop.add(gl.current)\n                    }\n                }\n\n                delete event.cancelPush;\n                instance.invoke(\"dropDone\", gl.current, drop, event)\n            }else if(!activeInstance.options.clone){\n\n                activeInstance.invoke(\"cancel\", gl.current)\n                gl.parent.add(gl.current)\n\n            }else{\n\n                // When is a clone and not to be dropped\n                activeInstance.invoke(\"cancel\")\n                gl.current.remove()\n\n            }\n\n            gl.current.style.margin = prevMargin;\n\n            gl.current.class(\"ls-held\", 0)\n            gl.previewBox.remove()\n            gl.moving = false\n            gl.engaged = false\n            gl.dragArea.hide()\n        }\n    }\n\n    M.on(\"mouseup\", ()=>{\n        gl.engaged = false\n        end()\n    })\n\n    if(!gl.dragArea){\n        LS.once(\"body-available\", ()=>{\n            gl.dragArea = N({class: \"ls-drag-area\"})\n            LS._topLayer.add(gl.dragArea)\n        })\n    }\n\n    gl.previewBox = N({class: \"ls-drop-preview\"})\n\n    return _this=>class LS_Drag{\n        constructor(id, options = {}){\n            _this = this;\n            this.id = id;\n\n            this.options = {\n                outsideParent: false,\n                relativeMouse: false,\n                animate: true,\n                dropPreview: true,\n                absoluteX: false,\n                absoluteY: false,\n                preserveHeight: true,\n                overflow: false,\n                container: null,\n                scrollContainer: null,\n                sameParent: false,\n                strictDrop: true,\n                dropFindY: false,\n                movementOnly: false,\n                lockX: false,\n                lockY: false,\n                scrollY: true,\n                scrollX: true,\n                clone: false,\n                allowedTargets: [],\n                getters: {},\n                snapArea: 5,\n                tolerance: 5,\n                ...options\n            };\n\n            // Scrolling is initially disabled till the user hovers over the element\n            getParent(true, this).on(\"mouseenter\", ()=>{\n                scrollAllowed = true\n            })\n        }\n\n        enableDrag(element, handle){\n            element.lsDrag = true\n            element.lsDropTarget = _this.id\n\n            O(handle || element).on(\"mousedown\", async (evt)=>{\n                if(evt.button !== 0) return;\n\n                let enable = true;\n\n                await _this.invoke(\"dragStart\", element, evt, ()=>{\n                    enable = false;\n                })\n\n                if(!element.lsDrag || !enable) return;\n                prevX = M.x;\n                initialX = M.x;\n                velocityX = 0;\n                initialY = M.y;\n                prevY = initialY;\n                velocityY = 0;\n\n                let box = element.getBoundingClientRect();\n\n                relative = {\n                    box,\n                    x: initialX - box.left,\n                    y: initialY - box.top\n                }\n\n                gl.dragArea.style.top = box.top + \"px\";\n                gl.dragArea.style.left = box.left + \"px\";\n\n                prevMargin = getComputedStyle(element).margin\n\n                gl.parent = O(element.parentElement)\n                gl.engaged = true\n                gl.current = element\n                gl.firstFrame = true\n                activeInstance = _this\n\n                //Wait for when the drag should start or be aborted.\n                waitForIt()\n            })\n        }\n\n        disableDrag(element){\n            element.lsDrag = false\n        }\n\n        enableDrop(element){\n            O(element);\n\n            element.lsDrop = true\n            element.lsDropTarget = _this.id\n            element.class(\"ls-drop\")\n            element.on(\"mouseenter\", ()=>{\n                if(!gl.moving || (activeInstance && activeInstance.options.movementOnly)) return;\n\n                dropHover(element)\n            })\n        }\n        \n        disableDrop(element){\n            element.lsDrop = false\n            element.class(\"ls-drop\", 0)\n        }\n    }\n},"],"from":"ls-js/dragdrop.js"},{"segment":"timeline","content":["Timeline(gl){\n    return _this=>class LS_Timeline{\n        constructor(id, element, options = {}){\n            _this = this;\n            this.id = id;\n            this.options = options;\n            this.element = element;\n            this.items = [];\n\n            this.timelines = [{\n                items: {},\n                labels: []\n            }]\n\n            this.areaElement = element.get(\"ls-timeline-area\");\n            this.container = element.get(\"ls-timeline-container\");\n            this.markers = element.get(\"ls-timeline-markers\");\n            this.pointer = element.get(\"ls-timeline-pointer\");\n            this.blackout = element.get(\"ls-timeline-blackout\");\n            this.labels = element.get(\"ls-timeline-labels\");\n            \n            if(!this.pointer){\n                this.pointer = N(\"ls-timeline-pointer\")\n                this.container.add(this.pointer)\n            }\n            \n            if(!this.blackout){\n                this.blackout = N(\"ls-timeline-blackout\")\n                this.areaElement.add(this.blackout)\n            }\n\n            this._zoom = _this.options.zoom || 1;\n            this._position = _this.options.position || 0;\n            this._playerLength = _this.options.length || 5000;\n            this._currentTimeline = _this.options.timeline || 0;\n            _this.zoomMultiplier = 1;\n\n            Object.defineProperty(this, \"timeline\", {\n                get(){\n                    return _this.timelines[_this._currentTimeline]\n                }\n            })\n\n            Object.defineProperty(this, \"currentTimeline\", {\n                get(){\n                    return _this._currentTimeline\n                },\n                set(value){\n                    if(_this._currentTimeline == value) return;\n\n                    for(let item in _this.timeline.items) {\n                        if(!_this.timeline.items.hasOwnProperty(item)) continue;\n\n                        _this.timeline.items[item].element.hide()\n                    }\n\n                    _this._currentTimeline = value\n                    if(!_this.timelines[value]) _this.timelines[value] = {\n                        items: {},\n                        labels: []\n                    }\n\n                    for(let item in _this.timeline.items) {\n                        if(!_this.timeline.items.hasOwnProperty(item)) continue;\n\n                        _this.timeline.items[item].element.show(\"flex\")\n                    }\n\n                    _this.updateLabels()\n                }\n            })\n\n            Object.defineProperty(this, \"rows\", {\n                get(){\n                    return _this.container.getAll(\"ls-timeline-row\").length\n                }\n            })\n\n            Object.defineProperty(this, \"position\", {\n                get(){\n                    return _this._position\n                },\n                set(value){\n                    _this._position = Math.max(0, Math.min(value, _this.playerLength))\n                    updatePointer()\n                }\n            })\n\n            Object.defineProperty(this, \"playerLength\", {\n                get(){\n                    return _this._playerLength\n                },\n                set(value){\n                    _this._playerLength = Math.min(Math.max(_this.options.min || 0, value), _this.options.max || Infinity)\n                    scroll()\n                }\n            })\n\n            if(!_this.options.minZoom) _this.options.minZoom = .004;\n            if(!_this.options.maxZoom) _this.options.maxZoom = 15;\n\n            Object.defineProperty(this, \"zoom\", {\n                get(){\n                    return _this._zoom\n                },\n                set(value){\n                    _this._zoom = Math.max(_this.options.minZoom, Math.min(value, _this.options.maxZoom))\n\n                    let i = 0;\n\n                    // TODO:FIXME: I mean, just look at this\n                    _this.zoomMultiplier = _this.zoom < .005 ? 512 : _this.zoom < .01 ? 256 : _this.zoom < .015 ? 128 : _this.zoom < .02 ? 64 : _this.zoom < .05 ? 32 : _this.zoom < .10 ? 16 : _this.zoom < .25 ? 8 : _this.zoom < .5 ? 4 : _this.zoom < 10 ? 1 : .5;\n\n                    _this.areaElement.style.setProperty(\"--column-width\", (_this.zoom * (_this.options.baseValue || 10) * _this.zoomMultiplier) +\"px\")\n\n                    for(const object of Object.values(_this.timeline.items)){\n                        object.start = object.start;\n                        object.length = object.length;\n                    }\n\n                    updatePointer()\n                    scroll()\n                }\n            })\n\n            document.addEventListener('wheel', (event) => {\n                if (event.ctrlKey && this.areaElement.matches(\":hover\")) {\n                    event.preventDefault();\n\n                    let zoomFactor = this.zoom * .16\n                    this.zoom = this.zoom - (event.deltaY > 0 ? zoomFactor : -zoomFactor)\n                }\n            }, { passive: false });\n\n            O(this.areaElement).class(\"ls-timeline\")\n\n            let handle = LS.Util.touchHandle(this.areaElement, {exclude: \".ls-timeline-item, .ls-timeline-item *\", buttons: [0]}), prevSeek;\n            this.handle = handle;\n\n            handle.on(\"start\", ()=>{\n                requestAnimationFrame(scrollBounds)\n            })\n\n            function scrollBounds(){\n                let scrollBox = _this.container.getBoundingClientRect();\n\n                _this.position = (_this.container.scrollLeft + (M.x - scrollBox.left)) / _this.zoom\n\n                if(prevSeek !== _this.position) _this.invoke(\"seek\", _this.position)\n                prevSeek = _this.position;\n\n                if(M.x > (scrollBox.right - 20)) _this.container.scrollBy(Math.min(40, (M.x - (scrollBox.right - 20))/2), null)\n                if(M.x < (scrollBox.left + 20)) _this.container.scrollBy(Math.min(40, -(((scrollBox.left + 20)) - M.x)/2), null)\n\n                updatePointer()\n                if(handle.seeking) requestAnimationFrame(scrollBounds)\n            }\n\n            this.dragDrop = LS.DragDrop(id + \"_timeline_drag\", {\n                animate: false,\n                relativeMouse: true,\n                dropPreview: true,\n                absoluteX: true,\n                container: this.container,\n                strictDrop: false,\n                sameParent: true,\n                ...this.options.disableCrossing? {\n                    movementOnly: true,\n                    lockY: true,\n                }: {},\n                getters: {\n                    get snapAt(){\n                        return [..._this.items.filter(e=>!e.hasClass(\"ls-held\")), _this.blackout]\n                    }\n                }\n            })\n\n            this.dragDrop.on(\"dragStart\", (element, event, cancel)=>{\n                if(event.target.classList.contains(\"ls-resize-bar\")) cancel()\n            })\n\n            this.dragDrop.on(\"drop\", (source, target, event) => {\n                if(event.source == _this.dragDrop.id){\n                    event.cancelMorph();\n                    let id = source.attr(\"data-timeline-id\");\n\n                    _this.timeline.items[id].start = event.boundX / _this.zoom\n                }\n            })\n\n            this.dragDrop.on(\"dropDone\", (source, target, event)=>{\n                if(event.source == _this.dragDrop.id){\n                    let id = source.attr(\"data-timeline-id\");\n                    \n                    if(_this.timeline.items[id].row == _this.rows -1) _this.addRow();\n                    _this.invoke(\"rowchange\", source, id)\n                }\n            })\n\n            let prevSection = null, prevMultiplier = _this.zoomMultiplier;\n\n            let markers = [];\n\n            for(let i = 0; i < 100; i++){\n                let marker = N()\n                markers.push(marker)\n                _this.markers.add(marker)\n            }\n\n            function scroll(){\n                // Temporary solution\n                _this.container.style.setProperty(\"--scroll-width\", Math.max(_this.container.clientWidth, _this.container.scrollWidth) +\"px\")\n\n                let scroll = _this.container.scrollLeft,\n                    section = Math.floor(scroll / (3000 * _this.zoom))\n                ;\n\n                if(prevSection !== section || _this.zoomMultiplier !== prevMultiplier){\n                    let value = section * 50, values = _this.options.label? _this.options.label(value, markers.length, _this.zoomMultiplier, scroll) : null;\n                    let i = 0;\n                    for(let marker of markers){\n                        marker.set(values? values[i] : value + i)\n                        i++\n                    }\n                    prevMultiplier = _this.zoomMultiplier\n                }\n\n                scroll -= section * (3000 * _this.zoom);\n\n                _this.markers.style.transform = \"translateX(\"+ (-scroll) +\"px)\"\n\n                if(_this.labels){\n                    _this.labels.scroll(0, _this.container.scrollTop)\n                }\n\n                prevSection = section;\n                updatePointer()\n            }\n            \n            function updatePointer(){\n                _this.pointer.style.left = ((-_this.container.scrollLeft / _this.zoom) + _this.position) * _this.zoom +\"px\"\n                _this.blackout.style.left = -_this.container.scrollLeft + (_this.playerLength * _this.zoom) +\"px\"\n            }\n\n            scroll()\n            this.container.on(\"scroll\", scroll)\n\n            for(let row of this.areaElement.getAll(\"ls-timeline-row\")){\n                this.dragDrop.enableDrop(row)\n            }\n\n            this.zoom = _this._zoom;\n            this.playerLength = _this._playerLength;\n            this.position = _this._position;\n        }\n\n        addRow(label){\n            let row = N(\"ls-timeline-row\");\n            _this.container.add(row)\n            this.dragDrop.enableDrop(row)\n\n            _this.timeline.labels[_this.rows] = label || \"\"\n\n            _this.updateLabels()\n\n            return row\n        }\n\n        item(element, id = M.GlobalID, options){\n            if(element.hasClass(\"ls-timeline-item\")) return;\n\n            if(_this.options.resize !== false){\n                LS.Resize(_this.id + \"_timeline_item_resize_\" + id, element, [0, 0, 1, 1], {set: false, absolute: true}).on(\"resize\", (side, values)=>{\n                    if(values.left) _this.timeline.items[id].start = values.left / _this.zoom;\n                    if(values.width) _this.timeline.items[id].length = values.width / _this.zoom;\n                });\n            }\n\n            _this.dragDrop.enableDrag(element)\n\n            element.class(\"ls-timeline-item\")\n            element.id = _this.id + \"_timeline_\" + id;\n            element.attr(\"data-timeline-id\", id);\n            \n            element.on(\"click\", (event)=>{\n                _this.invoke(\"select\", element, id, _this.timeline.items[id], event)\n            })\n\n            _this.items.push(element)\n\n            let start = 0, length = 0;\n\n            _this.timelines[_this._currentTimeline].items[id] = {\n                element,\n\n                get start(){\n                    return start\n                },\n\n                get zoomedStart(){\n                    return start / _this.zoom\n                },\n\n                set start(value){\n                    start = value;\n                    element.style.left = start * _this.zoom + \"px\"\n                },\n\n                get end(){\n                    return (_this.options.singlePoint? start : (start + length))\n                },\n\n                get zoomedEnd(){\n                    return (_this.options.singlePoint? start : (start + length)) / _this.zoom\n                },\n\n                get length(){\n                    return length\n                },\n\n                get zoomedLength(){\n                    return length / _this.zoom\n                },\n\n                set length(value){\n                    length = value;\n                    if(!_this.options.singlePoint) element.style.width = length * _this.zoom + \"px\"\n                },\n\n                get row(){\n                    return Array.prototype.indexOf.call(element.parentElement.parentElement.children, element.parentElement)\n                },\n\n                set row(value){\n                    if(value < 0) return;\n\n                    let parent = _this.container.getAll(\"ls-timeline-row\")[value];\n                    if(!parent){\n                        parent = _this.addRow()\n                    }\n                    parent.add(element)\n\n                    _this.invoke(\"rowchange\", element, id)\n                }\n            }\n\n            return id\n        }\n\n        intersectingAt(time){\n            time = time;\n\n            let result = [];\n            for(const id in _this.timeline.items){\n                if(!_this.timeline.items.hasOwnProperty(id)) continue;\n                let item = _this.timeline.items[id];\n\n                if(time >= item.start && time <= item.end) result.push(id)\n            }\n            return result;\n        }\n\n        contentLength(){\n            let data = Object.values(_this.timeline.items), result = data.reduce((maxEnd, currentObject) => {\n                return currentObject.end > maxEnd.end ? currentObject : maxEnd;\n            }, data[0]);\n\n            return result? result.end : 0;\n        }\n\n        updateLabels(){\n            [..._this.labels.childNodes].forEach(element => element.remove())\n\n            let i = -1;\n            for(let label of _this.timeline.labels) {\n                i++;\n\n                if(typeof label == \"string\"){\n                    _this.timeline.labels[i] = label = N(\"ls-timeline-row-label\", label);\n                }\n\n                _this.labels.add(label)\n            }\n        }\n    }\n},"],"from":"ls-js/timeline.js"},{"segment":"nav","content":["Nav(gl){\n    return(_this) => class Nav{\n        constructor(id, element){\n\n            _this = this;\n            this.id = id;\n\n            this.element = element\n            this.menu = {}\n\n            _this.active = false\n\n            if(this.element) LS.once(\"body-available\", ()=>{\n                element.getAll(\"ls-dropdown\").all(dropdown => {\n                    this.addMenu(dropdown, dropdown.get(\"ls-menu\"))\n                })\n            })\n\n            gl.on(\"nav-open\", (source, menu)=>{\n                this.hide(null, id == source, menu)\n            })\n        }\n\n        contextMenu(target, menu){\n            let id = _this.virtualMenu(menu, null, ()=>{\n                return [M.x, M.y]\n            })\n            \n            O(target).on('contextmenu', function(event) {\n                event.preventDefault();\n                _this.show(id)\n            })\n        }\n\n        virtualMenu(menuElement, id, virtualHandle = () => [0,0]){\n            if(!menuElement)throw \"Invalid menu element\";\n            return _this.addMenu(null, menuElement, id, virtualHandle)\n        }\n\n        addMenu(handle, menuElement, _id = null, virtualHandle = null){\n            let id = _id || (menuElement && menuElement.id) || M.GlobalID;\n\n            if(menuElement){\n                if(handle) O(handle).attr(\"menu\", id)\n                LS._topLayer.add(menuElement)\n                menuElement.id = id;\n                \n                this.menu[id] = {\n                    element: O(menuElement),\n                    handle: handle || virtualHandle,\n                    id,\n                    shown: false\n                }\n            }\n\n            this.setup(handle, id, virtualHandle)\n            return id;\n        }\n\n        setup(trigger, id, virtualHandle = null){\n            let hasMenu = !!_this.menu[id];\n\n            if(!hasMenu){\n                trigger\n                    .on(\"mouseenter\", ()=>{\n                        if(_this.active) _this.hide(null, true)\n                    })\n                return\n            }\n\n            if(trigger) trigger\n                .on(\"mouseenter\", ()=>{\n                    if(_this.active) _this.show(id)\n                })\n                .on(\"mousedown\", () => _this.toggle(id))\n                .on(\"keydown\", (e)=>{\n                    switch(e.keyCode){\n                        case 27: _this.hide(id); break\n                        case 13: _this.toggle(id); break\n                    }\n                });\n\n            O().on(\"mousedown\", (e)=>{\n                if(_this.menu[id].shown && e.target !== _this.menu[id].handle){\n                    let r = _this.menu[id].element.getBoundingClientRect();\n                    if(!(M.x>r.left&&M.x<r.right&&M.y>r.top&&M.y<r.bottom)) _this.hide(id)\n                }\n            })\n\n            M.on(\"resize\", ()=>{if(_this.menu[id].shown) _this.position(_this.menu[id].handle, _this.menu[id].element)})\n            // M.on(\"scroll\", ()=>{if(_this.menu[id].shown) _this.position(_this.menu[id].handle, _this.menu[id].element)}, true)\n\n            _this.menu[id].sub = [];\n            _this.menu[id].element.getAll(\"ls-option\").all(option =>{\n                let subMenu = option.get(\":scope > ls-menu\")\n\n                if(subMenu){\n                    _this.menu[id].sub.push({ menu: subMenu, handle: option });\n                    option.class(\"has-submenu\");\n\n                    option.on(\"mouseenter\", ()=>{\n                        if(option.parentElement == _this.menu[id].element) _this.clearSubmenus(id);\n                        option.class(\"submenu-visible\")\n                        _this.position(option, subMenu, true)\n                    })\n                } else {\n                    option.on(\"click\", ()=>{\n                        _this.invoke(\"selected\", id, option)\n                        _this.hide(id)\n                    })\n                }\n            })\n        }\n\n        clearSubmenus(id){\n            for(let a of _this.menu[id].sub){\n                a.menu.hide()\n                a.handle.class(\"submenu-visible\", 0)\n            }\n        }\n\n        toggle(menu){\n            _this[_this.menu[menu].shown? \"hide\" : \"show\"](menu)\n        }\n\n        show(id){\n            let menu = _this.menu[id];\n            if(!menu || menu.shown) return;\n\n            _this.clearSubmenus(id);\n            _this.active = true;\n\n            gl.invoke(\"nav-open\", _this.id, id);\n\n            menu.element.show()\n            menu.shown = true;\n            \n            _this.position(menu.handle, menu.element);\n\n            if(typeof menu.handle !== \"function\") menu.handle.class(\"open\")\n        }\n\n        position(handle, menu, sub){\n            if(typeof handle === \"function\") handle = handle();\n\n            let left, top, right;\n\n            if(Array.isArray(handle)){\n                return menu.style = `left:${handle[0]}px;top:${handle[1]}px`;\n            }\n\n            menu.show()\n            menu.applyStyle({\n                left: `0`,\n                top: `0`,\n                maxHeight: `unset`,\n                opacity: \"0\"\n            })\n\n            let handleRect = handle.getBoundingClientRect(), menuRect = menu.getBoundingClientRect();\n\n            menu.applyStyle({\n                left: `${sub? handleRect.right : Math.max(handleRect.left + menuRect.width > innerWidth? innerWidth - menuRect.width : handleRect.left, 0)}px`,\n                top: `${sub? handleRect.top : handleRect.top + handleRect.height}px`,\n                maxHeight: `${Math.min(innerHeight-(handleRect.top + handleRect.height+20),600)}px`,\n                opacity: \"1\"\n            })\n        }\n\n        hide(id, own, source){\n            if(!id){\n                for(let m in this.menu){\n                    if(source == m)continue;\n                    m = this.menu[m];\n                    if(m.shown) this.hide(m.id, own)\n                }\n                return;\n            }\n\n            let menu = _this.menu[id];\n\n            if(!menu || !menu.shown) return;\n\n            if(!own) _this.active = false;\n\n            menu.shown = false;\n            menu.element.hide()\n\n            if(typeof menu.handle !== \"function\") {\n                menu.handle.focus()\n                menu.handle.class(\"open\", 0)\n            }\n        }\n    }\n},"],"from":"ls-js/nav.js"},{"segment":"list","content":["List(gl){\n    return (_this) => class InfiniteList {\n\n        constructor(id, element, options){\n            _this = this;\n            \n            options = LS.Util.defaults({\n                lineHeight: 16, // Fixed height of each item\n                overheadLines: 16, // Scroll overhead. Must be divisible by two. Eg. 16 = each side of the scroll will have 8 extra rendered items. Lower values might create performance issues when scrolling fast, higher values will consume a more memory and slow down all scrolling. Recommended range is 8 to 32.\n                scrollArea: 400, // Scroll area, this also defines the maximum scroll speed per frame\n                scrollSensitivity: 2, // More = more effort needed to start scrolling, less = less effort needed to start scrolling. Not recommended to set below 1.\n                bottomScrollPadding: 200, // Extra space at the bottom of the scroll in pixels,\n                minimumScroll: 0, // Minimum that can be scrolled. Can be below 0.\n                layoutOnNoDifference: false, // Disabling this might improve performance a bit, but can cause issues in specific scenarios.\n                minimalDifference: 0, // If the difference is smaller than this, do not perform a layout. Higher values can improove load but will cause lagging.\n        \n                realScroll: false, // If enabled, the scroller will use absolute scroll position and create a filler element, instead of tracking scroll events relatively. This may negatively impact performance but allows you to use the native scrollbar.\n                dualScrollbar: false // Incompatible with realScroll - this creates an alternative scrollbar on the left, which uses the browser native scrollbar, but still allows you to use relative scrolling. This might still have a slight negative impact on performance.\n            }, options)\n\n\n            this.element = O(element) || N();\n\n            this.options = options;\n\n            this.scrollContainer = N({\n                class: \"ls-listScrollContainer\"\n            })\n\n            this.itemContainer = N({\n                class: \"ls-listItemContainer\"\n            })\n\n            this.scrollFilter = N({\n                class: \"ls-listScrollFilter\"\n            })\n\n            this.items = []\n\n            this.scrollContainer.add(this.itemContainer, this.scrollFilter)\n            this.element.add(this.scrollContainer)\n            this.element.class(\"ls-listContainer\")\n\n            this.scrollY = 0;\n            this.previousEtape = null;\n            this.previousY = null;\n\n            this.scrollContainer.on(\"scroll\", event => {\n\n                let diff = _this.scrollContainer.scrollTop - _this.options.scrollArea;\n            \n                if (diff < _this.options.scrollSensitivity && diff > -_this.options.scrollSensitivity) return;\n            \n                _this.scrollContainer.scrollTop = _this.options.scrollArea\n            \n                _this.scrollY += diff;\n                _this.scrollY = Math.max(_this.options.minimumScroll, Math.min((_this.items.length * _this.options.lineHeight) - _this.element.clientHeight + _this.options.bottomScrollPadding, _this.scrollY));\n            \n                if (!_this.options.layoutOnNoDifference && Math.floor(_this.previousY) == Math.floor(_this.scrollY)) return;\n                if (_this.options.minimalDifference && Math.abs(_this.scrollY - _this.previousY) < _this.options.minimalDifference) return;\n            \n                _this.previousY = _this.scrollY\n            \n                return _this.updateList()\n            })\n\n            this.init()\n        }\n\n        init() {\n            _this.itemContainer.clear()\n\n            _this.element.style.setProperty(\"--ls-list-lineHeight\", _this.options.lineHeight + \"px\")\n\n            _this.scrollY = 0\n            _this.scrollContainer.scrollTop = _this.options.scrollArea\n\n            _this.itemContainer.set(Array(Math.floor(_this.element.clientHeight / _this.options.lineHeight) + _this.options.overheadLines).fill().map((line, i) => N({\n                class: \"ls-listItem\",\n                inner: _this.getItem(_this.items[i])\n            })))\n\n            _this.updateList()\n        }\n\n        getItem(item){\n            return _this.options.template? _this.options.template(item) : (typeof item === \"string\")? N({textContent: item}) : item\n        }\n\n        scroll(x, y) {\n            scrollY = y\n            _this.previousY = y\n            _this.itemContainer.scrollLeft = x\n            _this.updateList()\n        }\n\n        scrollBy(x, y) {\n            _this.scrollContainer.scrollBy(x, y)\n        }\n\n        updateList() {\n            let etapeHeight = _this.options.overheadLines * _this.options.lineHeight,\n                etape = Math.floor(_this.scrollY / etapeHeight),\n                transform = _this.scrollY % etapeHeight\n            ;\n\n\n            // console.log(\"Previous etape:\", _this.previousEtape, \"Etape:\", etape, \"Scroll:\", _this.scrollY, \"Transform:\", transform);\n\n            // if(etape > _this.previousEtape){\n            //     console.log(\"Shifting bottom\");\n\n            //     for(let i = 0; i < _this.options.overheadLines; i++){\n            //         let location = (etape * _this.options.overheadLines) + i,\n            //             target = _this.itemContainer.child(0)\n            //         ;\n\n            //         _this.itemContainer.add(target)\n\n            //         if(location < _this.items.length){\n            //             target.class(\"hidden\", 0)\n            //             target.set(_this.items[location])\n            //         } else {\n            //             target.class(\"hidden\")\n            //         }\n            //     }\n            // }\n\n            // if(etape < _this.previousEtape){\n            //     console.log(\"Shifting top\");\n\n            //     for(let i = 0; i < _this.options.overheadLines; i++){\n            //         _this.itemContainer.child(0).addBefore(_this.itemContainer.lastChild.set(_this.items[(etape * _this.options.overheadLines) + (_this.options.overheadLines - i - 1)]))\n            //     }\n            // }\n\n            if (etape != _this.previousEtape) {\n                for (let i = 0; i < _this.itemContainer.children.length; i++) {\n                    let location = (etape * _this.options.overheadLines) + i, target = _this.itemContainer.children[i];\n\n                    if (location < _this.items.length) {\n                        target.set(_this.getItem(_this.items[location])).class(\"hidden\", 0)\n                    } else {\n                        target.class(\"hidden\")\n                    }\n                }\n            }\n\n            // console.log(_this.scrollY, transform, (Math.floor(_this.scrollY / etapeHeight) * etapeHeight), etapeHeight);\n\n            _this.itemContainer.style.transform = \"translateY(\" + (-transform) + \"px)\"\n            _this.previousEtape = etape;\n        }\n    }\n},"],"from":"ls-js/list.js"},{"segment":"select","content":["Select(gl){\n\n    /*\n\n        LS Code quality rating: 6/10\n        This component needs changes\n    \n    */\n\n\n    gl.fromNative = function (selectElement) {\n        let select = LS.Select(N(\"ls-select\", {attr: [\"compatibility\"]}))\n\n        select.loadFromElement(selectElement)\n        select.updateElements()\n\n        select.set(selectElement.value)\n\n        if(selectElement.onchange){\n            select.on(\"change\", selectElement.onchange)\n        }\n\n        selectElement.remove()\n\n        return select\n    }\n\n    return(_this) => class Select {\n        constructor(id, element, options = {}){\n            element = O(element);\n\n            if(!element) throw \"No element provided for the select component!\";\n\n            _this = this;\n\n            this.id = id;\n            this.value = null\n\n            this.uniqueSet = new Set;\n\n            if(Array.isArray(options)){\n                options = {values: options}\n            }\n\n            this.options = LS.Util.defaults({\n                search: true,\n                handleClickEvents: true,\n                values: []\n            }, options)\n\n            if(element.tagName === \"SELECT\") return gl.fromNative(element);\n\n            this.element = element;\n\n            this.element.attrAssign({\n                tabindex: 2\n            })\n\n            if(this.element.has(\"ls-menu\")){\n                this.menuElement = this.element.get(\"ls-menu\")\n            }\n\n            _this.menuElementContainer = (this.menuElement && this.menuElement.has(\".ls-select-options\"))? this.menuElement.get(\".ls-select-options\"): N({class: \"ls-select-options\"});\n\n            if(!this.menuElement) this.menuElement = N(\"ls-menu\");\n\n            _this.menuElement.class(\"has-top-handle\")\n\n            if(this.options.search){\n                _this.menuElement.prepend(N(\"input\", {\n                    placeholder: \"Search\",\n\n                    oninput(){\n                        _this.search(this.value)\n                    }\n                }), N(\"hr\", { style: {marginTop: \"0\"} }))\n            }\n\n            _this.menuElement.add(_this.menuElementContainer)\n\n            O(options.rootElement || LS._topLayer).add(this.menuElement);\n\n            M.on(\"resize\", () => {if(this.open) this.position()})\n            M.on(\"wheel\", \"touchmove\", () => {if(this.open) this.position()}, true)\n\n            this.open = false;\n\n            this.element\n                .on(\"mousedown\", () => this.toggle())\n                .on(\"keydown\", event => {\n                    switch(event.keyCode){\n                        case 27: this.hide(); break\n                        case 13: this.toggle(); break\n                        case 40: case 9: this.show(); this.getOptions()[0].element.focus(); break\n                    }\n                });\n\n            O(options.rootElement || document.body).on(\"mousedown\", event => {\n                if(this.open && event.target !== this.element){\n                    let box = this.menuElement.getBoundingClientRect();\n                    if(!(event.clientX > box.left && event.clientX < box.right && event.clientY > box.top && event.clientY < box.bottom)) this.hide()\n                }\n            })\n            \n            this.loadFromElement();\n\n            this.updateElements()\n            this.selectFirst()\n        }\n\n        selectFirst(){\n            if(_this.options.values.length > 0) _this.set(_this.options.values[0])\n        }\n\n        set(option){\n            if(typeof option === \"string\") option = _this.options.values.find(_option => _option.value === option);\n            else if (typeof option === \"number\") option = _this.options.values[option];\n\n            if(!option || !option.value) return false;\n            \n            _this.value = option.value;\n            _this.element.set(_this.options.getLabel? _this.options.getLabel(option): (option.label || option.element || option.value));\n\n            if(option.listElement) O(option.listElement).attrAssign(\"selected\");\n\n            if(_this.invoke) _this.invoke(\"change\", option.value, option)\n            return true\n        }\n\n        removeOption(index){\n            if(typeof index === \"string\") index = _this.options.values.findIndex(_option => _option.value === index);\n\n            // TODO: add an unique ID set, and handle element removal/memory cleanup by checking for difference in arrays\n            this.options.values[index].listElement.remove()\n\n            this.options.values[index] = null\n            _this.updateElements()\n        }\n\n        clearOptions(){\n            this.options.values = []\n            _this.updateElements()\n        }\n\n        updateElements(values){\n            let i = -1;\n            for(const option of _this.options.values){\n                i++\n\n                if(!option || typeof option !== \"object\") continue;\n\n                if(typeof option == \"string\"){\n                    // let label = N(\"ls-label\", {attr: {title: option}, innerText: option});\n                    // _this.menuElementContainer.add(label)\n                    // _this.options[i] = {type: \"label\", element: label}\n                    continue\n                }\n\n                if(!option.type) option.type = \"option\";\n\n                let optionElement = option.listElement || N(\"ls-option\");\n\n                if(!option.listElement) option.listElement = optionElement;\n\n                let optionContent = option.element || option.value;\n\n                optionElement.set(optionContent)\n\n                if(option.type == \"option\"){\n                    optionElement.attrAssign({ tabindex: \"1\" });\n\n                    optionElement.onmouseup = () => {\n                        if(!_this.options.handleClickEvents) return;\n\n                        _this.hide(); _this.set(option)\n                    }\n\n                    optionElement.onkeydown = event => {\n                        if(!_this.options.handleClickEvents) return;\n\n                        _this.hide()\n                        if(event.keyCode == 13) _this.set(option)\n                    }\n                }\n\n                _this.menuElementContainer.add(optionElement)\n            }\n        }\n\n        loadFromElement(source = _this.menuElementContainer){\n            // _this.options.values = []\n\n            for(const element of source.getAll()){\n                let parent = element.parentElement.tagName;\n\n                // if(!parent.includes(\"SELECT\") && !parent.includes(\"OPTGROUP\")) continue;\n\n                let option =\n                    element.tagName === \"OPTGROUP\"? { type: \"label\", value: element.attr(\"label\") }:\n                    element.tagName === \"OPTION\"? {\n                        type: \"option\",\n                        element: element.children.length > 0? [...element.children]: null,\n                        value: element.attr(\"value\") || element.innerHTML\n                    } : null\n                ;\n\n                _this.options.values.push(option)\n            }\n        }\n\n        addOption(option){\n            let index = _this.options.values.push(option)\n            _this.updateElements()\n            return index -1\n        }\n\n        toggle(){\n            _this[_this.open? \"hide\" : \"show\"]()\n        }\n\n        show(){\n            if(_this.open) return;\n            _this.open = true;\n\n            _this.position();\n            _this.element.class(\"open\")\n        }\n\n        position(){\n            let box = _this.element.getBoundingClientRect();\n\n            _this.menuElement.applyStyle({\n                left: box.left + \"px\",\n                width: box.width + \"px\",\n                top: (box.top + box.height) + \"px\",\n                maxHeight: Math.min(innerHeight - (box.top + box.height + 20), 400) + \"px\",\n                display: \"block\"\n            })\n        }\n\n        hide(){\n            if(!_this.open) return;\n            _this.open = false;\n\n            _this.element.focus()\n            _this.element.class(\"open\", false)\n            _this.menuElement.style.display = \"none\";\n        }\n\n        get(){\n            return _this.value\n        }\n\n        search(value){\n            function fuzz(string){\n                return string.toLowerCase().trim().replace(/[\\s\\n\\t\\r:|_]/g, \"\")\n            }\n\n            _this.menuElement.getAll(\".ls-select-options > *\").forEach(element => element.style.display = fuzz(element.innerText).includes(fuzz(value))? \"block\" : \"none\")\n        }\n    }\n},"],"from":"ls-js/select.js"},{"segment":"tooltips","content":["Tooltips(gl){\n    if(!LS.isWeb)return;\n    gl.conf={\n        batch: false,\n        singular: true\n    }\n    return(_this)=>class Tooltips{\n        constructor(){\n            _this = this;\n\n            this.element = N({class:\"ls-tootlip-layer\"});\n            this.contentElement = N({class:\"ls-tooltip-content\"});\n            this.element.add(this.contentElement);\n\n            this.attributes = ['ls-tooltip', 'ui-tooltip', 'ls-hint', 'tooltip'];\n            this.observer = new MutationObserver(this.addElements);\n\n            function add() {\n                LS._topLayer.add(_this.element)\n\n                _this.rescan()\n\n                _this.observer.observe(document.documentElement, {\n                    attributes: true,\n                    // childList: true,\n                    subtree: true,\n                    attributeFilter: _this.attributes\n                })\n            }\n\n            LS.once(\"body-available\", ()=>{\n                add()\n            })\n        }\n\n        position(x, y){\n            let box;\n\n            if(x instanceof Element) {\n                box = x.getBoundingClientRect()\n            } else if(typeof x == \"number\") box = {x}\n\n            let cbox = _this.contentElement.getBoundingClientRect(),\n                pos_top = box.top - cbox.height,\n                pos_bottom = box.top + box.height\n            ;\n\n            _this.contentElement.applyStyle({\n                left:(\n                    box.width ? Math.min(Math.max(box.left+(box.width/2)-(cbox.width/2),4),innerWidth-(cbox.width)) : box.x\n                ) + \"px\",\n\n                maxWidth:(innerWidth - 8)+\"px\",\n\n                top: typeof y === \"number\"? y + \"px\": `calc(${pos_top < 20? pos_bottom : pos_top}px ${pos_top < 0? \"+\" : \"-\"} var(--ui-tooltip-rise, 5px))`\n            })\n        }\n\n        set(text){\n            _this.contentElement.set(text);\n        }\n\n        show(){\n            _this.element.class(\"shown\");\n            LS._topLayerInherit();\n        }\n\n        hide(){\n            _this.element.class(\"shown\", 0)\n        }\n\n        addElements(mutations){\n            if(!Array.isArray(mutations)) mutations = [mutations];\n\n            for(let mutation of mutations.reverse()) {\n                if(typeof mutation !== \"object\" || !mutation || !mutation.target) continue;\n\n                let e = O(mutation.target), attr = mutation.attributeName;\n\n                e.hasTooltip = e.hasAttr(attr);\n                e.tooltip_value = e.attr(attr);\n                e.tooltip_hint = e.hasAttr(\"ls-hint\");\n\n                if(!e._tt)! _this.setup(e);\n            }\n        }\n\n        rescan(){\n            _this.addElements(Q(_this.attributes.map(a=>`[${a}]`).join(\",\")).map(e=>{\n                return {\n                    target: e,\n                    attributeName: Object.keys(e.attr()).find(a=>_this.attributes.includes(a))\n                }\n            }))\n        }\n\n        setup(element){\n            element._tt = true;\n            element.on(\"mouseenter\", ()=>{\n                if(!element.hasTooltip) return;\n                _this.invoke(\"set\", element.tooltip_value);\n\n                if(element.tooltip_hint) return;\n\n                _this.set(element.tooltip_value)\n                _this.show()\n\n                _this.position(element)\n            })\n\n            element.on(\"mousemove\", () => _this.position(element))\n\n            element.on(\"mouseleave\", () => {\n                if(!element.hasTooltip) return;\n                _this.invoke(\"leave\", element.tooltip_value);\n                _this.hide()\n            })\n        }\n    }\n},"],"from":"ls-js/tooltips.js"},{"segment":"present","content":["Present(gl){\n\n    return(_this)=>class PresentationView{\n        constructor(id, element = O(\"present\"), options = {}){\n            element = O(element);\n\n            if(!element) throw\"No element found for the presentation.\";\n\n            _this = this;\n\n            if(!options.resolution) options.resolution = [1280, 720];\n            if(!options.select) options.select = \"ls-slide\";\n\n            this.options = options;\n\n            element.class(\"ls-present-container\");\n\n            this.element = element.wrapIn(N({class: \"ls-present-body\"}));\n\n            if(!options.frameOnly) {\n                this.tabs = LS.Tabs(\"LS.Present.\" + id, this.element, {\n                    list: false,\n                    select: options.select || \"ls-slide\",\n                    mode: \"presentation\"\n                })\n\n                // This is for legacy applications, since this used to be forwarded through LS.Steps in the past.\n                this.steps = {\n                    tabs: this.tabs\n                }\n            }\n\n            this.setResolution()\n\n            M.on(\"resize\", this.fixResolution);\n\n            (options.fullscreen? O() : element).on(\"keydown\", \"wheel\", this.handleEvent);\n            element.on(\"click\", this.handleEvent)\n        }\n\n        handleEvent(e){\n            if(_this.options.ignoreEvents || (_this.lastTimer&&(Date.now() - _this.lastTimer) < ((+_this.slideElement().attr(\"min-time\")) || 500)))return;\n            if(_this.options.canContinue && typeof _this.options.canContinue == \"function\"){\n                let canContinue = _this.options.canContinue(e)\n            }\n\n            if(!canContinue) return;\n\n            _this.lastTimer = Date.now();\n\n            if(\n                (e.type==\"wheel\" && e.deltaY<=0)||\n                (e.type==\"keydown\" && [\"ArrowLeft\",\"ArrowUp\"].includes(e.key))\n            ){\n                _this.navigate(-1,false,true);\n                return\n            }\n\n            _this.navigate(1,false,true);\n        }\n\n        slideElement(id = null){\n            return _this.tabs.tabs[_this.tabs.order[id || _this.tabs.tab]]\n        }\n\n        fixResolution(){\n            let e = _this.element,\n            scale = Math.min(\n                (_this.options.containerWidth || Number(window.innerWidth)) / _this.options.resolution[0],    \n                (_this.options.containerHeight || Number(window.innerHeight)) / _this.options.resolution[1]\n            );\n            _this.scale = scale\n            e.style.transform=`translate(-50%,-50%) scale(${scale})`;\n        }\n\n        setResolution(w, h){\n            if(typeof w === \"undefined\" && typeof h === \"undefined\") {\n                w = _this.options.resolution[0];\n                h = _this.options.resolution[1];\n            }\n            \n            let aspectRatio = _this.options.resolution[0] / _this.options.resolution[1];\n            if(typeof w === \"undefined\") w = Math.round(h * aspectRatio);\n            if(typeof h === \"undefined\") h = Math.round(w / aspectRatio);\n            \n            _this.options.resolution[0] = w;\n            _this.options.resolution[1] = h;\n            \n            _this.element.applyStyle({width: w +\"px\", height: h +\"px\"});\n            _this.fixResolution()\n\n           if(_this.invoke) _this.invoke(\"resolution-changed\", w, h, aspectRatio)\n        }\n\n        navigate(direction, jump = false, key=false){\n            if(!jump && direction == 0) return;\n            if(!jump && typeof direction == \"string\") {\n                direction = _this.tabs.order.indexOf(direction)\n                jump = true\n            }\n\n            let element = _this.slideElement();\n            if(!element) return false;\n\n            let stages = (element.attr(\"stages\") || \"\").split(\";\").map(stage=>{\n                let obj = {};\n\n                for(let key of stage.split(\",\")){\n                    if(key.length < 1) continue;\n\n                    key = key.split(\":\");\n                    obj[key[0]] = key[1];\n                }\n\n                return Object.keys(obj).length < 1? null : obj;\n            }).filter(garbage => garbage), hold = false;\n\n            if(stages.length > 0 && !jump){\n                let stage = element.attr(\"stage\");\n                stage = +(stage || 0);\n\n                console.log(stage, stages.length, stages, direction);\n\n                if(\n                    direction > 0?\n                        stage != stages.length\n                    :\n                        stage > 0\n                ){\n                    element.attrAssign({stage: stage + direction})\n                    hold = true\n                }\n            }\n\n            if(!hold){\n                if(direction ==1 && key && element.hasAttr(\"no-action\")) return false;\n\n                if(jump){\n                    _this.tabs.setActive(direction);\n                }else{\n                    _this.tabs[direction > 0? \"next\" : \"previous\"]();\n                }\n            }else{\n                _this.invoke(\"stage\", _this.tabs.activeTab, direction, jump);\n            }\n\n            _this.invoke(\"change\", _this.tabs.activeTab, _this.tabs.order.length, direction, jump);\n\n            return true\n        }\n\n        set(tab){\n            return _this.tabs.setActive(tab)\n        }\n\n        next(){\n            return _this.navigate(1)\n        }\n\n        slide(slide = 0){\n            return _this.navigate(slide, true)\n        }\n\n        back(){\n            return _this.navigate(-1)\n        }\n\n        fullscreen(){\n            return this.element.requestFullscreen()\n        }\n    }\n},"],"from":"ls-js/present.js"},{"segment":"resize","content":["Resize(gl){\n    let directions = [\"top\", \"bottom\", \"left\", \"right\", \"topleft\", \"topright\", \"bottomleft\", \"bottomright\"],\n        cursor = [\"ns-resize\", \"ns-resize\", \"ew-resize\", \"ew-resize\"],\n        values = [\"height\", \"height\", \"width\", \"width\"]\n    ;\n\n    return(_this)=>class Resize{\n        constructor(id, element, sides = [1, 1, 1, 1, 0, 0, 0, 0], options = {}){\n            _this = this;\n            this.sides = sides;\n            this.values = [0, 0, 0, 0];\n\n            this.options = {\n                snap: false,\n                snapArea: 140,\n                snapTarget: 4,\n                set: true,\n                absolute: false,\n                ...options\n            };\n\n            this.element = O(element);\n\n            this.update();\n        }\n\n        update(sides = this.sides){\n            _this.sides = Array.isArray(sides)? sides.length < 8 ? [...sides, ...Array(8 - sides.length).fill(0)] : sides.slice(0, 8) : [1, 1, 1, 1, 0, 0, 0, 0];\n\n            sides = _this.sides;\n\n            for(const [i,s] of sides.entries()){\n                if(i > 7) break;\n                this[s? \"addHandle\" : \"removeHandle\"](i)\n            }\n        }\n\n        addHandle(side){\n            let direction = directions[side];\n\n            if(!direction) throw new Error(\"Invalid resize direction\");\n\n            if((side > 8 || side < 0) || _this.element.has(\".ls-resize-bar-\" + direction)) return;\n\n            let handleElement = N({\n                class: \"ls-resize-bar ls-resize-bar-\" + direction\n            });\n\n            let handle = LS.Util.touchHandle(handleElement, {buttons: [0]}), initialX, initialY, initialBox, top, left;\n\n            handle.on(\"move\", (x, y)=>{\n\n                let realSides = [side], properties = {};\n\n                if(side > 3) switch(side){\n                    case 4: realSides = [0, 2]; break;\n                    case 5: realSides = [0, 3]; break;\n                    case 6: realSides = [1, 2]; break;\n                    case 7: realSides = [1, 3]; break;\n                }\n\n                for(const side of realSides){\n                    let value, realValue, box = _this.element.getBoundingClientRect();\n    \n                    switch(side){\n                        case 0: // Top\n                            // TODO: Make work with all scenarios\n                            if(this.options.absolute){\n                                realValue = initialBox.height - (y - initialY)\n                            }else{\n                                realValue = innerHeight - y\n                            }\n                        break;\n                        case 1: // Bottom\n                            if(this.options.absolute){\n                                realValue = y - box.top\n                            }else{\n                                // TODO: FIX!\n                                // value = initialBox.height - (y - initialY)\n                                // if(value < 0) value = 0;\n                                // _this.element.style.top = top - (value - initialBox.height) +\"px\"\n                            }\n                        break;\n                        case 2: // Left\n                            // TODO: Make work with all scenarios\n                            realValue = initialBox.width - (x - initialX)\n                        break;\n                        case 3: // Right\n                            // TODO: Make work with all scenarios\n                            realValue = x - box.left\n                        break;\n                    }\n    \n                    value = realValue;\n                    if(value < 0) value = 0;\n    \n                    if(_this.options.snap){\n                        if(realValue < _this.options.snapArea){\n                            value = _this.options.snapArea\n                        }\n                        if(realValue < _this.options.snapArea / 2){\n                            value = _this.options.snapTarget\n                        }\n                    }\n    \n                    if(this.options.absolute){\n                        switch(side){\n                            case 0:\n                                properties.top = top - (value - initialBox.height)\n                            break;\n                            case 2:\n                                properties.left = left - (value - initialBox.width)\n                            break;\n                        }\n                    }\n    \n                    _this.values[side] = value\n                    properties[values[side]] = _this.values[side]\n    \n                    if(_this.options.set) {\n                        for(let property in properties){\n                            if(!properties.hasOwnProperty(property)) continue;\n        \n                            _this.element.style[property] = properties[property] +\"px\"\n                        }\n                    }\n                }\n\n                _this.invoke(\"resize\", direction, properties)\n            })\n\n            handle.on(\"start\", ()=>{\n                initialX = M.x;\n                initialY = M.y;\n                initialBox = _this.element.getBoundingClientRect();\n\n                left = getComputedStyle(_this.element).left.match(/\\d+|[.]/g);\n                left = left? +left.join(\"\"): 0;\n\n                top = getComputedStyle(_this.element).top.match(/\\d+|[.]/g);\n                top = top? +top.join(\"\"): 0;\n\n                handle.cursor = cursor[side]\n                _this.invoke(\"resizestart\", direction)\n            })\n\n            handle.on(\"end\", ()=>{\n                _this.invoke(\"resizeend\", direction)\n            })\n\n            _this.element.add(handleElement)\n        }\n\n        removeHandle(side){\n            let direction = directions[side];\n            if((side>4||side<0) || !_this.element.has(\".ls-resize-bar-\" + direction)) return;\n\n            _this.element.get(\".ls-resize-bar-\" + direction).remove();\n        }\n    }\n},"],"from":"ls-js/resize.js"},{"segment":"progress","content":["Progress(gl){\n    return _this => class ProgressBar{\n        constructor(id, element, options = {}){\n            this.element = element = O(element)\n            if(!element) throw \"No element provided\";\n\n            _this = this;\n\n            this.options = LS.Util.defaults({\n                seeker: element.tagName == \"LS-SEEKER\",\n                styled: true,\n                vertical: false,\n                padding: options.vertical? 16: 0,\n                separator: element.tagName == \"LS-SEEKER\"? \"\" : \"/\",\n                label: true\n            }, options)\n\n            element.class(\"ls-progress\");\n            element.attrAssign(\"chv\");\n\n            if(this.options.seeker) this.element.class(\"ls-seek\");\n            if(this.options.styled) this.element.class(\"ls-progress-styled\");\n\n            element.add(\n                N({class: \"ls-progress-bar\"}),\n\n                this.options.seeker? N({class: \"ls-seeker-thumb\"}) : null,\n                this.options.label?\n\n                N({\n                    class: \"ls-progress-label\",\n                    inner:[\n                        N(\"span\", {class: \"ls-progress-label-left\"}),\n                        N(\"span\", {class: \"ls-progress-label-separator\"}),\n                        N(\"span\", {class: \"ls-progress-label-right\"})\n                    ]\n                }): null\n            )\n\n            if(this.options.label){\n                this.labelLeft = _this.element.get(\".ls-progress-label-left\");\n                this.labelRight = _this.element.get(\".ls-progress-label-right\");\n                this.labelSeparator = _this.element.get(\".ls-progress-label-separator\");\n            }\n\n            _this._min = this.options.min || +element.attr(\"min\") || 0;\n            _this._max = this.options.max || +element.attr(\"max\") || 100;\n            _this.step = this.options.step || +element.attr(\"step\") || 1;\n\n            _this._progress = this.options.progress || 0;\n            _this._value = Math.min(_this._max, Math.max(_this._min, this.options.value || +element.attr(\"value\") || 0));\n\n            if(!_this.options.metric && element.attr(\"metric\")) _this.options.metric = element.attr(\"metric\");\n\n            this.define(this)\n\n            if(this.options.progress && this.options.value)throw(\"You can't define both the progress and value.\")\n        }\n\n        _init(){\n            _this.bar = _this.element.get(\".ls-progress-bar\");\n\n            if(_this.options.label) _this.label = _this.element.get(\".ls-progress-label\");\n\n            if(_this.options.seeker){\n                _this.thumb = _this.element.get(\".ls-seeker-thumb\");\n\n                let handle = LS.Util.touchHandle(_this.element, {exclude: \".ls-progress-label-left\"});\n\n                if(_this.options.label) {\n                    _this.labelLeft.style.userSelect = \"\";\n    \n                    _this.labelLeft.on(\"dblclick\", ()=>{\n                        _this.labelLeft.attrAssign({\"contenteditable\": \"true\", \"tabindex\": \"5\"})\n                        _this.labelLeft.focus()\n                    })\n    \n                    _this.labelLeft.on(\"blur\", ()=>{\n                        _this.labelLeft.delAttr(\"contenteditable\")\n                        let value = Math.max(_this._min, Math.min(_this._max, +_this.labelLeft.innerText));\n                        console.log(value);\n    \n                        if(isNaN(value))return _this.labelLeft.set(_this._value);\n    \n                        _this._value = value;\n                        _this.update(false, true);\n                    })\n    \n                    _this.labelLeft.on(\"keypress\", (e) => {\n                        if(e.key == \"Enter\") _this.labelLeft.blur()\n                    })\n                }\n\n                _this.handle = handle;\n\n                handle.on(\"start\", (e, cancel)=>{\n                    if(_this.element.hasAttr(\"disabled\")) return;\n                    _this.seeking = true;\n                    _this.invoke(\"seekstart\", _this._value, _this._max, _this._progress)\n                    if(LS.Tooltips) LS.Tooltips.show();\n                })\n                \n                handle.on(\"move\", (x, y, event) => {\n                    let rect = _this.element.getBoundingClientRect(),\n                        offset = (_this.options.vertical ? (y - rect.top) : (x - rect.left)) / _this.step,\n                        range = _this.max - _this._min,\n                        newValue = Math.round(((_this.options.vertical ? rect.height - offset : offset) / (_this.options.vertical ? rect.height : rect.width)) * range)\n                    ;\n\n                    newValue = Math.floor(newValue * _this.step) + _this._min;\n\n                    if (newValue >= _this._min && newValue <= _this.max) {\n                        if (LS.Tooltips) {\n                            LS.Tooltips.set(String(newValue));\n                            LS.Tooltips.position(_this.thumb);\n                        }\n                \n                        _this._value = newValue;\n                        _this.update(false, true);\n                    }\n                });                \n\n                handle.on(\"end\", ()=>{\n                    _this.seeking = false;\n\n                    _this.invoke(\"seekend\", _this._value, _this._max, _this._progress)\n\n                    if(LS.Tooltips) LS.Tooltips.hide();\n                })\n            }\n\n            _this.update(_this.options.progress && !_this.options.value);\n        }\n\n        define(scope){\n\n            Object.defineProperties(scope, {\n                progress: {\n                    get(){\n                        return _this._progress\n                    },\n\n                    set(value){\n                        _this._progress = value\n                        _this.update(true)\n                    }\n                },\n                value: {\n                    get(){\n                        return _this._value\n                    },\n\n                    set(value){\n                        _this._value = value\n                        _this.update()\n                    }\n                },\n                max: {\n                    get(){\n                        return _this._max\n                    },\n\n                    set(value){\n                        _this._max = value\n                        _this.update()\n                    }\n                },\n                min: {\n                    get(){\n                        return _this._min\n                    },\n\n                    set(value){\n                        _this._min = value\n                        _this.update()\n                    }\n                }\n            })\n        }\n\n        update(setPercentage, isSeeking) {\n            if (_this.seeking && !isSeeking) return;\n        \n            // Adjust calculations to account for _this._min\n            const range = _this.max - _this._min; // The range between min and max\n        \n            if (!setPercentage) {\n                // Calculate progress considering the minimum value\n                _this._progress = ((_this.value - _this._min) / range) * 100;\n            } else {\n                // Calculate value considering the progress and minimum value\n                _this._value = (_this._progress * range) / 100 + _this._min;\n            }\n        \n            if (_this.options.seeker) {\n                // Set the thumb position based on progress\n                _this.thumb.style[_this.options.vertical ? \"bottom\" : \"left\"] = _this.options.padding \n                    ? `calc(${_this.progress}%)` \n                    : (_this.progress + \"%\");\n        \n                // Invoke \"seek\" event if the user is seeking\n                if (isSeeking) _this.invoke(\"seek\", _this._value, _this._max, _this._progress);\n            }\n        \n            // Invoke \"change\" event whenever the value changes\n            _this.invoke(\"change\", _this._value, _this._max, _this._progress);\n        \n            // Update the progress bar width/height based on progress\n            _this.bar.style[_this.options.vertical ? \"height\" : \"width\"] = _this.progress + \"%\";\n        \n            // Update labels if label options are enabled\n            if (_this.options.label) {\n                _this.labelLeft.set(String(_this.value));\n                _this.labelSeparator.set(_this.options.separator);\n                _this.labelRight.set(String(_this.max) + (_this.options.metric ? \" \" + _this.options.metric : \"\"));\n            }\n        }        \n    }\n},"],"from":"ls-js/progress.js"},{"segment":"color","content":["Color(gl){\n    gl.conf = {\n        batch: false,\n        singular: true\n    }\n\n    return _this => class Color{\n        constructor(){\n            _this = this;\n\n            // Default colors and themes available out of the box\n            this.default = {\n                colors: [\"auto\", \"rich-black\", \"navy\", \"blue\", \"lapis\", \"pastel-indigo\", \"teal\", \"pastel-teal\", \"aquamarine\", \"mint\", \"green\" ,\"lime\", \"neon\", \"yellow\", \"orange\", \"deep-orange\", \"red\", \"rusty-red\", \"pink\", \"hotpink\", \"purple\", \"soap\", \"burple\", \"gray\", \"gray-light\", \"white\", \"black\", \"sand\", \"cozy\", \"icepop\", \"sport\"],\n                themes: [\"dark\", \"light\", \"amoled\"]\n            }\n            \n            // Custom colors and themes\n            this.colors = {};\n            this.themes = {};\n\n            // Style tag to manage\n            this.style = O(\"#ls-colors\");\n\n            if(!this.style){\n                LS.once(\"body-available\", ()=>{\n                    this.style = N(\"style\", {id: \"ls-colors\"});\n\n                    O(\"#ls-top-layer\").add(this.style)\n                })\n            }\n\n            Object.defineProperties(this, {\n                lightModePreffered: {\n                    get(){\n                        return window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches\n                    }\n                }\n            })\n\n            if(window.matchMedia) {\n                window.matchMedia('(prefers-color-scheme: light)').addListener(thing => {\n                    _this.invoke(\"scheme-changed\", thing.matches)\n                })\n            }\n        }\n\n        add(name, r, g, b){\n            if(_this.default.colors.includes(name) || _this.colors[name]) return false;\n\n            let color = C(r, g, b), values = color.color\n\n            _this.colors[name] = values;\n\n            _this.style.add(`[ls-accent=\"${name}\"]{--accent-raw:${values[0]},${values[1]},${values[2]};--accent-dark-raw:${color.darken(10).color.slice(0, 3).join(\",\")};--accent-background-raw:${color.darken(20).saturation(20).color.slice(0, 3).join(\",\")};--accent-light-raw:${color.lighten(10).color.slice(0, 3).join(\",\")};--color-bg:${color.hsl[2] > 50? \"#222\": \"#eee\"}}`)\n            return true\n        }\n\n        setAccent(accent){\n            O().setAttribute(\"ls-accent\", accent)\n            LS._topLayerInherit()\n        }\n\n        setTheme(theme){\n            O().setAttribute(\"ls-theme\", theme)\n            _this.invoke(\"theme-changed\", theme)\n\n            LS._topLayerInherit()\n        }\n\n        adaptiveTheme(amoled){\n            LS.Color.setTheme(_this.lightModePreffered? \"light\": amoled? \"amoled\" : \"dark\")\n        }\n\n        watchScheme(amoled){\n            LS.once(\"body-available\", () => {\n                _this.adaptiveTheme();\n                _this.on(\"scheme-changed\", () => _this.adaptiveTheme())\n            })\n        }\n\n        all(){\n            return [..._this.default.colors, ...Object.keys(_this.colors)]\n        }\n\n        random(){\n            return C(Math.floor(Math.random() * 256), Math.floor(Math.random() * 256), Math.floor(Math.random() * 256))\n        }\n\n        randomAccent(){\n            let colors = _this.all();\n            return colors[Math.floor(Math.random() * colors.length)];\n        }\n\n        getAverageRGB(image, sampleGap = 20){\n            let canvas = N(\"canvas\"),\n                context = canvas.getContext && canvas.getContext(\"2d\"),\n                index = -4,\n                color = [0, 0, 0],\n                sampleCount = 0\n            ;\n\n            if (!context) return C(...color);\n\n            canvas.height = image.naturalHeight || image.offsetHeight || image.height;\n            canvas.width = image.naturalWidth || image.offsetWidth || image.width;\n            \n            context.drawImage(image, 0, 0);\n\n            let imageData;\n            try {\n                imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n            } catch (error) {\n                console.error(error);\n                return C(...color);\n            }\n\n            for (let i = imageData.data.length; (index += sampleGap) < i; ) {\n                ++sampleCount\n                color[0] += imageData.data[index]\n                color[1] += imageData.data[index + 1]\n                color[2] += imageData.data[index + 2]\n            }\n        \n            return (color[0] = ~~(color[0] / sampleCount)), (color[1] = ~~(color[1] / sampleCount)), (color[2] = ~~(color[2] / sampleCount)), C(...color);\n        }\n    }\n},"],"from":"ls-js/color.js"},{"segment":"graphgl","content":["GraphGL(gl){\n    return _this=>class GraphGL{\n        constructor(id,element,_options={}){\n            _this=this;\n            this.id=id;\n            let options=Object.assign({\n                height:100,\n                width:300,\n                default:{shadow:{inner:{}}},\n                charts:[],\n                tooltip:true,\n                blur:20\n            },_options);\n            this.ns=\"http://www.w3.org/2000/svg\";\n            this.options=options;\n            this.element=O(element);\n            this.charts={};\n            this.container=N('div',{inner:[\n                N(\"svg\",{ns:this.ns,id:\"graphgl_graph_\"+id,class:\"ls-chart-vector\",attr:{viewBox:`0 0 ${options.width} ${options.height}`,width:options.width,height:options.height,xmlns:this.ns}}),\n                N({class:\"ls-chart-line\",attr:\"ns\"}),\n                N({class:\"ls-chart-tooltip\",attr:[\"ls-box\",\"ns\"],inner:\"some text<br>some more\"}),\n            ],class:\"ls-chart-container\",id:\"ls-chart-\"+id});\n            this.svg=this.container.get(\"svg\")\n            this.tooltip=this.container.get(\".ls-chart-tooltip\")\n            this.svg.add(N(\"defs\",{ns:this.ns,innerHTML:`<filter id=\"gr_blur_${id}\" x=\"-50%\" y=\"-50%\" width=\"200%\" height=\"200%\"><feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"${options.blur||0}\" /></filter>`}))\n            this.defs=this.container.get(\"svg defs\")\n            this.element.add(this.container);\n            this.container.on(\"mousemove\",\"touchmove\",event=>{\n                if(!this.points||!this.options.tooltip)return;\n                let rect=this.container.getBoundingClientRect(),content=[],index=Math.round((event.clientX-rect.left)/(this.options.width/this.points)),x=index*(this.options.width/this.points),y=event.clientY-rect.top;\n                this.container.get(\".ls-chart-line\").style.left=this.tooltip.style.left=x+\"px\"\n                this.tooltip.style.top=y+\"px\";\n                if(this.lastPoint==index)return;\n                this.lastPoint=index\n                if(this.options.labelsX)content.push(\"<div class='ls-chart-tooltip-top'>\"+this.options.labelsX[index]+\"</div>\");\n                for(let chart of Object.values(this.charts)){\n                    let point = this.container.get(\"#graphgl_point_\"+chart.id)\n                    let color = this.container.getAll(\"#gr_grad_\"+chart.id+\" stop\").map(e=>e.attr(\"stop-color\"))[index]\n                    if(point){\n                        point.style.top=chart.points[index][1]+\"px\"\n                        point.style.left=x+\"px\";\n                        point.style.background=color;\n                    }\n                    content.push(options.contentFunction?options.contentFunction(chart,index):`<div style=background:${color} class=ls-chart-dot></div> ${chart.options.values[index]/(chart.options.divide||0)}${chart.options.metric} ${chart.options.name||\"\"}`)\n                    this.tooltip.innerHTML=content.join(\"<br>\");\n                }\n            })\n            for(let g of options.charts){\n                g=Object.assign({\n                    values:[100,20,30,25,60,70,65,75,45,0],\n                    colors:[\"#42CF00\",\"#8DBD00\",\"#A68B00\",\"#A68B00\",\"#955102\",\"#823205\",\"#6D0808\"].reverse(),\n                    colorFunction:(v,i)=>{\n                        this.clamp(Math.round()-1)\n                        return `rgb(${240-(v/this.options.height)*240},${(v/this.options.height)*240},15)`\n                    },\n                    coloringMethod:\"function\",//gradient | function | static\n                    stroke:8,\n                    rounding:20,\n                    fluid: true\n                },options.default,g)\n                g.shadow=Object.assign({allowed:true,spread:7,position:\"0,10\",opacity:.4},g.shadow);\n                g.shadow.inner=Object.assign({allowed:true,y:2,opacity:.4},g.shadow.inner);\n                this.graphFactory(M.GlobalID, g);\n            }\n        }\n        graphFactory(id, options){\n            if(_this.charts[id])return _this.charts[id];\n            let gr;\n            return new(class LineGraph{\n                constructor(){\n                    _this.charts[id]=this;\n                    gr=this;\n                    gr.id=id;\n                    gr.options=options;\nlet chart=`\n<polyline fill=\"none\" id=\"graphgl_poly_${id}\"></polyline>\n<path id=\"graphgl_path_${id}\" fill=\"none\" stroke=\"url(#gr_grad_${id})\" stroke-width=\"${options.stroke}\" stroke-linecap=\"round\"></path>`;\n// _this.svg.innerHTML+=chart;\nlet group = N('g',{ns:_this.ns,innerHTML:chart,class:\"ls-chart-group\",id:\"ls-chart-\"+id});\n_this.svg.add(group)\n_this.defs.innerHTML+=`<linearGradient id=\"gr_grad_${id}\" x1=\"0\" y1=\"0\" x2=\"${_this.options.width}\" y2=\"0\" gradientUnits=\"userSpaceOnUse\">\n${options.values.map((v,i)=>`<stop offset=\"${(1/(options.values.length-1))*i}\" stop-color=\"${options.coloringMethod==\"gradient\"?options.colors[_this.clamp(Math.round((v/_this.options.height)*options.colors.length)-1,0,options.colors.length-1)]:options.coloringMethod==\"static\"?options.colors:options.colorFunction(v,i)}\"></stop>`).join(\"\")}\n</linearGradient>\n${options.shadow.inner.allowed?`<filter id=\"gr_inner_${id}\" x=\"-50%\" y=\"-50%\" width=\"200%\" height=\"200%\" filterUnits=\"userSpaceOnUse\" color-interpolation-filters=\"sRGB\">\n<feFlood flood-opacity=\"0\" result=\"BackgroundImageFix\"></feFlood>\n<feBlend mode=\"normal\" in=\"SourceGraphic\" in2=\"BackgroundImageFix\" result=\"shape\"></feBlend>\n<feColorMatrix in=\"SourceAlpha\" type=\"matrix\" values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0\" result=\"hardAlpha\"></feColorMatrix>\n<feOffset dy=\"${options.shadow.inner.y}\"></feOffset>\n<feComposite in2=\"hardAlpha\" operator=\"arithmetic\" k2=\"-1\" k3=\"1\"></feComposite>\n<feColorMatrix type=\"matrix\" values=\"0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 ${options.shadow.inner.opacity} 0\"></feColorMatrix>\n<feBlend mode=\"normal\" in2=\"shape\" result=\"effect1_innerShadow_253_365\"></feBlend>\n</filter>`:''}`\n                    _this.container.add(N({class:\"ls-chart-point\",attr:\"ns\",id:\"graphgl_point_\"+id}))\n                    gr.group = group;\n                    gr.line = group.get(\"#graphgl_path_\"+id);\n                    gr.poly = group.get(\"#graphgl_poly_\"+id);\n                    _this.points=gr.options.values.length-1;\n                    gr.updatePoints();\n                    gr.updateStyle()\n                }\n                calcPoints(values){\n                    if(values)gr.options.values=values;\n                    gr.maxPoint=gr.options.fluid?Math.max(...gr.options.values):100\n                    return gr.points = gr.options.values.map((v,i)=>[(_this.options.width/(gr.options.values.length-1))*i,_this.options.height-((v/gr.maxPoint)*_this.options.height)])\n                }\n                updatePoints(values){\n                    gr.calcPoints(values);\n                    if(options.poly){\n                        gr.poly.attrAssign({\n                            points: gr.points.join(\" \"),\n                            stroke: \"url(#gr_grad_\"+id+\")\",\n                            \"stroke-width\": options.stroke\n                        })\n                    }else{\n                        gr.path = _this.gPath(gr.points, options.rounding);\n                        gr.line.attr(\"d\",gr.path);\n                    }\n                }\n                updateStyle(){\n                    if(options.shadow.allowed&&!gr.group.get(\"#graphgl_shadow_\"+id)){\n                        gr.group.add({ns:_this.ns,innerHTML:gr.line.outerHTML.replace(\"_path_\",\"_shadow_\")});\n                        gr.shadow=gr.group.get(\"#graphgl_shadow_\"+id);\n                        gr.shadow.attrAssign({\n                            filter: \"url(#gr_blur_\"+_this.id+\")\",\n                            transform: \"translate(\"+options.shadow.position+\")\",\n                            \"stroke-width\":options.shadow.spread,\n                            style: \"opacity:\"+options.shadow.opacity\n                        })\n                    }\n                    gr.line[options.shadow.inner.allowed?\"attr\":\"delAttr\"](\"filter\",options.shadow.inner.allowed?\"url(#gr_inner_\"+id+\")\":0);\n                }\n            })\n        }\n        clamp(num,min,max){return Math.min(Math.max(num,min),max)}\n        gPath(e,b){\n            function getAngle(b,c){let d=c.x-b.x,e=c.y-b.y,f=Math.atan2(e,d);return f}\n            function removeEmptyElements(a){for(let b=0;b<a.length;b++)\"\"==a[b]&&a.splice(b,1);return a}\n            let f=`M${e[0][0]},${e[0][1]}`;\n            for(let d=1;d<e.length-1;d++){\n                let a=d-1,g=d+1,h={};\n                h.x=e[d][0],h.y=e[d][1];\n                let c={x:e[a][0],y:e[a][1]},i={};i.x=e[g][0],i.y=e[g][1];\n                let j=getAngle(h,c),k=getAngle(h,i),l=(h.x+b*Math.cos(j)).toFixed(3),m=(h.y+b*Math.sin(j)).toFixed(3),n=(h.x+b*Math.cos(k)).toFixed(3),o=(h.y+b*Math.sin(k)).toFixed(3);\n                f+=\"L\"+l+\",\"+m+\" Q\"+h.x+\",\"+h.y+\" \"+n+\",\"+o\n            }\n            return f+=`L${e[e.length-1][0]},${e[e.length-1][1]}`\n        }\n    }\n},"],"from":"ls-js/graphgl.js"},{"segment":"patchbay","content":["PatchBay(gl){\n    gl.extends = \"Workspace\";\n    class LS_Node {\n        constructor (options = {}) {\n            if(options instanceof Element) options = {element: options};\n\n            this.id = options.id || M.GlobalID;\n            this.class = options.class || \"\";\n            this.parent = options.parent || null;\n            this.position = options.position || [];\n            this.data = options.data || {}; // CUSTOM DATA TO BE SET BY THE APPLICATION.\n\n            this.element = options.element || N();\n            this.element.class(\"ls-bay-node\")\n\n            let handle = LS.Util.touchHandle(this.element, {exclude: \".ls-patch-source-hitbox, .ls-patch-source-hitbox *\"});\n            handle.cursor = \"none\";\n\n            let _this = this,\n                ox = 0,\n                oy = 0,\n                workspace = null\n            ;\n\n            function drag(){\n                let mouse = workspace.mousePoint;\n                _this.move(mouse.canvasXr - ox, mouse.canvasYr - oy)\n            }\n\n            handle.on(\"start\", ()=>{\n                workspace = _this.parent.workspace;\n\n                let rect = _this.element.getBoundingClientRect(),\n                    mouse = workspace.mousePoint,\n                    point = workspace.relativePoint(rect.x, rect.y)\n                ;\n\n                ox = mouse.x - point.x\n                oy = mouse.y - point.y\n\n                this.parent.globalZ++\n                this.element.style.zIndex = this.parent.globalZ\n                drag()\n            })\n\n            handle.on(\"move\", drag)\n\n            if(options.position)_this.move(...options.position);\n            if(options.onAdded)options.onAdded(this)\n            console.log(options);\n            gl.invoke(\"nodeAdded\", this)\n        }\n\n        move(x, y){\n            if(typeof x != \"number\") x = 0;\n            if(typeof y != \"number\") y = 0;\n\n            this.position = [ x, y ];\n            this.element.style.left = x + \"px\"\n            this.element.style.top = y + \"px\"\n            if(this.parent) this.parent._draw()\n        }\n\n        addSource(element, options = {}){\n            if(!O(element) || !this.parent)return;\n\n            element.class(\"ls-patch-source\")\n            let hitbox = N({class: \"ls-patch-source-hitbox\"});\n            element.wrapIn(hitbox)\n\n            let handle = LS.Util.touchHandle(hitbox);\n            handle.cursor = \"none\";\n            handle.drawTarget = element;\n\n            let _this = this;\n\n            let source = {\n                handle,\n                isInput: !!options.isInput,\n                id: M.GlobalID,\n                node: this.id,\n                class: options.class || element.attr(\"bay-class\") || \"\"\n            }\n\n            element.attrAssign({\"ls-accent\": _this.parent.getAccentColor(source.class)})\n\n            function drag(){\n                let rect = element.getBoundingClientRect()\n                _this.parent.d(_this.parent.dragLine, rect.x + (rect.width / 2), rect.y + (rect.height / 2), M.x, M.y, !source.isInput)\n            }\n            \n            hitbox.id = source.id;\n\n            handle.on(\"start\", ()=>{\n                this.parent.dragLine.show()\n                for(let _source of this.parent.sources){\n                    if((source.class !== _source.class) || hitbox !== _source.handle.target && _source.isInput == source.isInput && !(this.parent.connections[_source.id]||[]).includes(source.id)){\n                        _source.handle.target.style.opacity = \".2\"\n                    }\n                }\n                _this.parent.dragLine.attrAssign({\"ls-accent\": _this.parent.getAccentColor(source.class)})\n                this.parent.svgContainer.getAll(\".ls-bay-line:not(.line-drag)\").all(e => e.style.opacity = \".2\")\n                drag()\n            })\n\n            handle.on(\"move\", drag)\n\n            handle.on(\"end\", (evt)=>{\n                this.parent.svgContainer.style.opacity = \"1\"\n                let target = O(document.elementFromPoint(M.x, M.y))\n                if(target.hasClass(\"ls-patch-source-hitbox\")){\n                    this.parent.connect(...(source.isInput ? [source.id, target.id] : [target.id, source.id]))\n                }\n                this.parent.element.getAll(\".ls-patch-source-hitbox\").all(e => e.style.opacity = \"1\")\n                this.parent.svgContainer.getAll(\".ls-bay-line\").all(e => e.style.opacity = \"1\")\n                this.parent.dragLine.hide()\n            })\n            \n            _this.parent.sources.push(source)\n            return source\n        }\n\n        destroy(){\n            this.svgContainer.remove()\n        }\n    }\n\n    gl.newNode = function (options){\n        return new LS_Node(options)\n    }\n\n    return _this=>class LS_PatchBay{\n        constructor (id, element, options = {}) {\n            if(!LS.Workspace)throw new Error(\"PatchBay requires Workspace to work properly.\");\n\n\n            options = {\n                zoomControls: true,\n                import: {},\n                ...options\n            }\n\n            this.options = options;\n\n            _this = this;\n            this.id = options.id || options.import.id || id || M.GlobalID;\n            this.nodes = [];\n            this.connections = options.import.connections || {};\n            this.classes = {};\n            this.sources = [];\n\n            this.connectionRenderCache = {};\n            this.globalZ = 0;\n            this.element = O(element || N());\n            this.element.class(\"ls-patchbay\")\n            this.svgContainer = O(document.createElementNS('http://www.w3.org/2000/svg', 'svg'));\n\n            this.workspace = LS.Workspace(id + \"-workspace\", element, {...options.workspace || {}})\n\n            // if(options.zoomControls){\n            //     this.workspace.element.add(N(\"ls-group\", {\n            //         attr: [\"join\"],\n            //         inner: [\n            //             N(\"input\"),\n            //             N(\"button\", \"-\"),\n            //             N(\"button\", \"+\"),\n            //         ]\n            //     }))\n            // }\n\n            if(LS.Knob){\n                //TODO: Make this work idk\n                // this.knob = N(\"ls-knob\", {class: \"manual-init\", style: \"display:hidden\"})\n                // this.knob.ls = LS.Knob(this.id+\"_\"+\"knob\", this.knob, \"flat\")\n                // this.element.add(this.knob)\n            }\n\n            if(LS.MultiSelect){\n                LS.MultiSelect(this.id + \"-bayselect\", this.workspace.element, {passthrough: \":not(.ls-patchbay, .ls-workspace)\"})\n            }\n\n            this.svgContainer.class(\"ls-bay-svg\")\n            this.element.add(this.svgContainer)\n\n            this.dragLine = this.addLine()\n            this.dragLine.class(\"line-drag\")\n\n            if(options.import.nodes){\n                for(let node of options.import.nodes){\n                    this.add(new LS_Node(node))\n                }\n            }\n        }\n\n        export(){\n            return {\n                nodes: _this.nodes.map(node => {\n                    return {\n                        id: node.id,\n                        class: node.class,\n                        data: node.data,\n                        position: node.position\n                    }\n                }),\n                id: _this.id,\n                connections: _this.connections,\n                sources: _this.sources.map(source => {\n                    return {\n                        id: source.id,\n                        class: source.class,\n                        node: source.node,\n                        isInput: source.isInput\n                    }\n                })\n            }\n        }\n\n        addLine(opt = {}){\n            let group = O(document.createElementNS('http://www.w3.org/2000/svg', 'g')),\n                arrow = O(document.createElementNS('http://www.w3.org/2000/svg', 'path')),\n                line = O(document.createElementNS('http://www.w3.org/2000/svg', 'path'))\n            ;\n\n            group.add(line, arrow);\n            group.class(\"ls-bay-line\")\n\n            line.class(\"ls-bay-line-connector\")\n            arrow.class(\"ls-bay-line-arrow\")\n\n            if(opt.id){\n                group.id = opt.id\n                delete opt.id\n            }\n\n            opt = {\n                stroke: 'var(--accent)',\n                'stroke-width': 2,\n                fill: 'transparent',\n                ...opt\n            }\n\n            line.attrAssign(opt)\n            arrow.attrAssign({fill: opt.stroke || \"var(--accent)\", d: \"M0 0 L-5 -15 L5 -15 Z\"})\n            _this.svgContainer.add(group);\n            return group\n        }\n\n        add(...nodes) {\n            for(let node of nodes){\n                if(!node)continue;\n                node.parent = _this;\n                _this.nodes.push(node)\n                _this.element.add(node.element)\n                _this.globalZ++\n                node.element.style.zIndex = _this.globalZ\n            }\n        }\n\n        remove(...nodes) {\n\n        }\n\n        newNode(options){\n            return new LS_Node(options)\n        }\n\n        connect(from, to){\n            if(from == to)return;\n            from = _this.sources.find(s=>s.id==from);\n            to = _this.sources.find(s=>s.id==to);\n\n            if(!from||!to)throw new Error(\"Invalid source/destination\");\n            if(from.isInput === to.isInput)return;\n            if(from.class !== to.class)return;\n\n            if(!_this.connections[from.id]) _this.connections[from.id] = [];\n            if(_this.connections[from.id].includes(to.id)) return;\n            _this.connections[from.id].push(to.id)\n\n            _this._draw()\n        }\n\n        getAccentColor(_class){\n            return _this.classes[_class] ? _this.classes[_class].color || \"\" : \"\";\n        }\n\n        _draw(){\n            for(let start of Object.keys(_this.connections)){\n                let source = _this.sources.find(s => s.id == start);\n                if(!source)continue;\n                for(const end of _this.connections[start]){\n                    let target = _this.sources.find(s => s.id == end);\n                    if(!target)continue;\n                    let rect1 = source.handle.drawTarget.getBoundingClientRect()\n                    let rect2 = target.handle.drawTarget.getBoundingClientRect()\n                    let id = `line-${start}-${end}`\n                    if(!_this.connectionRenderCache[id]) _this.connectionRenderCache[id] = {\n                        redraw: false\n                    }\n\n                    ;(_this.svgContainer.get(\"#\" + id) || _this.addLine({\n                        id\n                    })).attrAssign({\"ls-accent\": _this.getAccentColor(target.class)})\n\n                    _this.connectionRenderCache[id].calculated = _this.d(null, rect1.x + (rect1.width / 2), rect1.y + (rect1.height / 2), rect2.x + (rect2.width / 2), rect2.y + (rect2.height / 2), false, true)\n                }\n            }\n            for(const id of Object.keys(_this.connectionRenderCache)){\n                _this.dApply(_this.svgContainer.querySelector(\"#\" + id), _this.connectionRenderCache[id].calculated)\n            }\n        }\n\n        disconnect(from, to){\n\n        }\n\n        calculateCenterPoint(x1, y1, x2, y2, x3, y3) {\n            const t = .5;\n            return { x: (1 - t) * (1 - t) * x1 + 2 * (1 - t) * t * x2 + t * t * x3, y: (1 - t) * (1 - t) * y1 + 2 * (1 - t) * t * y2 + t * t * y3 };\n        }\n\n        d(path, x1, y1, x2, y2, reverse = false, precalc = false){\n            let relative, result = {};\n\n            relative = _this.workspace.relativePoint(x1, y1);\n            x1 = relative.canvasXr\n            y1 = relative.canvasYr\n\n            relative = _this.workspace.relativePoint(x2, y2);\n            x2 = relative.canvasXr\n            y2 = relative.canvasYr\n            \n            let controlX = (x1 + x2) / 2,\n                controlY = (y1 > y2) ? y1 : y2\n            ;\n\n            result.line = `M${x1} ${y1} Q${controlX} ${controlY} ${x2} ${y2}`;\n\n            const deltaX = x2 - x1;\n            const deltaY = y2 - y1;\n\n            let center = this.calculateCenterPoint(x1, y1, controlX, controlY, x2, y2),\n                length = Math.sqrt(deltaX * deltaX + deltaY * deltaY) / 100\n            ;\n\n            if(_this.knob){\n                _this.knob.style.left = center.x + \"px\";\n                _this.knob.style.top = center.y + \"px\";\n            }\n\n            result.arrowPos = `translate(${center.x}, ${center.y}) rotate(${(Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI) + (reverse ? -90 : 90)}) scale(${Math.min(1, length)})`;\n            result.arrowOpacity = Math.min(1, length);\n\n            if(!precalc){\n                _this.dApply(path, result)\n            }\n            return result\n        }\n\n        dApply(path, d){\n            let line = path.get(\".ls-bay-line-connector\"),\n                arrow = path.get(\".ls-bay-line-arrow\")                            \n            ;\n            line.setAttribute('d', d.line);\n            arrow.setAttribute('transform', d.arrowPos);\n            arrow.setAttribute('opacity', d.arrowOpacity);\n        }\n    }\n},"],"from":"ls-js/patchbay.js"},{"segment":"knob","content":["Knob(gl){\n    gl.presets = {\n        default: {\n            pointer: \"dot\"\n        },\n\n        chrome: {\n            arcFill: false,\n            arcWidth: 5,\n            pointer: \"line\",\n            pointerGlow: true\n        },\n\n        flat: {\n            arcFill: false,\n            arcBackground: true\n        },\n\n        progress: {\n            arcGap: [180, 540],\n            arcFill: false\n        }\n    }\n\n    gl.defaultStyles = {\n        arcGap: [220, 500],\n        arc: true,\n        arcSpread: 0,\n        arcWidth: 15,\n        arcRounded: true,\n        pointerGlow: false,\n        arcBackground: false,\n        arcFill: true,\n        pointer: \"none\"\n    }\n\n    function describeArc(x, y, radius, spread, startAngle, endAngle, fill){\n        function polarToCartesian(centerX, centerY, radius, angleInDegrees) {\n            var angleInRadians = (angleInDegrees-90) * Math.PI / 180.0;\n\n            return {\n                x: centerX + (radius * Math.cos(angleInRadians)),\n                y: centerY + (radius * Math.sin(angleInRadians))\n            };\n        }\n\n        var innerStart = polarToCartesian(x, y, radius, endAngle),\n            innerEnd = polarToCartesian(x, y, radius, startAngle),\n            outerStart = polarToCartesian(x, y, radius + spread, endAngle),\n            outerEnd = polarToCartesian(x, y, radius + spread, startAngle),\n            largeArcFlag = endAngle - startAngle <= 180 ? \"0\" : \"1\"\n        ;\n\n        var d = [\n            \"M\", outerStart.x, outerStart.y,\n            \"A\", radius + spread, radius + spread, 0, largeArcFlag, 0, outerEnd.x, outerEnd.y,\n            ...(fill ? [\n                \"L\", innerEnd.x, innerEnd.y, \n                \"A\", radius, radius, 0, largeArcFlag, 1, innerStart.x, innerStart.y, \n                \"L\", outerStart.x, outerStart.y, \"Z\"\n            ] : [])\n        ].join(\" \");\n\n        return d;\n    }\n\n    return _this => class LS_Knob{\n        constructor (id, element, style = \"default\", options = {}) {\n            _this = this;\n\n            if(!element || !O(element))throw new Error(\"No element provided\");\n            this.element = O(element);\n\n            this.setStyle(this.element.attr(\"knob-preset\") || style || \"default\", true);\n\n            this.options = {\n                min: 0,\n                max: 100,\n                step: 1,\n                ...options\n            }\n\n            if(!this.element.has(\"svg\")){\n                this.element.add(O(document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\")))\n            }\n            \n            this.svg = this.element.get(\"svg\");\n\n            this.svg.attrAssign({\n                width: 200,\n                height: 200,\n                viewBox: \"0 0 200 200\"\n            })\n\n            this.arc = this.svg.get(\".ls-knob-arc\")\n            this.rotor = this.element.get(\".ls-knob-rotor\");\n            this.back = this.svg.get(\".ls-knob-back\");\n\n            if(!this.element.has(\".ls-knob-stator\")){\n                this.element.add(N({class:\"ls-knob-stator\"}))\n            }\n\n            Object.defineProperties(this, {\n                value: {\n                    get(){\n                        return _value\n                    },\n\n                    set(value){\n                        _value = Math.max(_this.options.min, Math.min(value, _this.options.max))\n                        _this.draw()\n                    }\n                }\n            })\n\n            let _value = _this.options.value || 0;\n\n            let handle = LS.Util.touchHandle(this.element, {\n                pointerLock: true\n            });\n\n            this.handle = handle;\n            handle.cursor = \"none\";\n            this.enabled = true;\n\n            this.updateStyle()\n\n            handle.on(\"start\", ()=>{\n                _this.drawInit();\n                _this.draw();\n            })\n\n            handle.on(\"move\", (x, y, e) => _this.event(e))\n            \n            // handle.on(\"end\", ()=>{\n\n            // })\n        }\n\n        event(event) {\n            let step = event? event.movementY * _this.options.step : 0;\n\n            _this.value -= step;\n        }\n\n        draw() {\n            _this.percentage = ((_this.value - _this.options.min) / (_this.options.max - _this.options.min)) * 100;\n            _this.arcAngle = (_this.style.arcGap[0] + (_this.percentage / 100) * (_this.style.arcGap[1] - _this.style.arcGap[0]));\n            \n            if(_this.invoke) _this.invoke(\"changed\", _this.value)\n\n\n            if(_this.style.pointer !== \"none\"){\n                _this.rotor.style.transform = `rotate(${_this.arcAngle}deg)`;\n            }\n\n            if(_this.style.arc){\n                _this.arc.setAttribute(\"d\", _this.Arc(_this.style.arcFill))\n            }\n        }\n\n        drawInit(){\n            if(_this.style.pointer !== \"none\"){\n\n                if(!_this.rotor){\n                    _this.rotor = N({class:\"ls-knob-rotor\"});\n                    _this.element.get(\".ls-knob-stator\").add(_this.rotor)\n                }\n                _this.rotor.show()\n\n            } else if(_this.rotor) {\n                _this.rotor.hide()\n            }\n\n            if(_this.style.arc){\n                if(!_this.arc){\n                    _this.arc = O(document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\"))\n                    _this.arc.class(\"ls-knob-arc\")\n                    _this.svg.add(_this.arc)\n                }\n\n                if(_this.style.arcFill){\n\n                    _this.arc.attrAssign({\n                        fill: \"var(--accent)\"\n                    })\n\n                } else {\n\n                    _this.arc.attrAssign({\n                        fill: \"transparent\",\n                        stroke: \"var(--accent)\",\n                        \"stroke-linecap\": _this.style.arcRounded? \"round\": \"butt\",\n                        \"stroke-width\": _this.style.arcWidth + \"%\"\n                    })\n                    _this.element.style.setProperty(\"--knob-stroke-width\", _this.element.getBoundingClientRect().height * (_this.style.arcWidth/100) + \"px\")\n                }\n\n                _this.arc.show()\n            } else if (_this.arc) {\n                _this.arc.hide()\n            }\n\n            if(_this.style.arcBackground && !_this.back){\n                _this.back = O(document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\"));\n                _this.back.setAttribute(\"fill\", \"transparent\")\n                _this.arc.addBefore(_this.back)\n            }\n\n            if(_this.style.arcBackground){\n                _this.back.class(\"ls-knob-arc-full\")\n                _this.back.setAttribute(\"d\", _this.Arc(false, _this.style.arcGap[1]))\n            }\n\n            _this.element.get(\".ls-knob-stator\").class(\"ls-knob-glow\", _this.style.pointerGlow ? 1 : 0)\n        }\n\n        setStyle(style, quiet = false){\n            if(typeof style === \"string\"){\n                let styleName = style;\n                style = gl.presets[style] || {}\n                style.name = styleName\n            }\n        \n            _this.style = {...gl.defaultStyles, ...style};\n\n            if(!quiet) _this.updateStyle()\n        }\n\n        updateStyle(opt = {}){\n            Object.assign(_this.style, opt)\n            _this.element.attrAssign({\"knob-preset\": _this.style.name})\n            _this.element.attrAssign({\"knob-pointer\": _this.style.pointer})\n            _this.updateOptions()\n        }\n\n        updateOptions(opt = {}){\n            Object.assign(_this.options, opt)\n            _this.drawInit()\n            _this.draw()\n\n            setTimeout(() => {_this.drawInit(); _this.draw()}, 4)\n        }\n\n        Arc(fill = true, ang = _this.arcAngle){\n            if( ang % 180 == 0 ) ang-- ; // Lazy fix\n            return describeArc(100, 100, _this.style.arcSpread, 100 - (_this.style.arcFill? 0 : _this.style.arcWidth), _this.style.arcGap[0], ang, fill)\n        }\n    }\n},"],"from":"ls-js/knob.js"},{"segment":"multiselect","content":["MultiSelect(gl){\n    return _this=>class LS_Multiselect{\n        constructor (id, element, options = {}) {\n            _this = this;\n            if(!element || !O(element))throw new Error(\"No element provided\");\n            this.element = O(element)\n            let handle = LS.Util.touchHandle(this.element, {exclude: options.passthrough || false, buttons: [0]});\n            handle.cursor = \"none\";\n            this.handle = handle;\n            this.enabled = true;\n            \n            this.mask = O(\"#ls-multiselect-mask\");\n            if(!this.mask) {\n                this.mask = N({id: \"ls-multiselect-mask\"})\n                O().add(this.mask)\n            }\n\n            let initial = [];\n\n            function draw(){\n                let\n                    rect = _this.element.getBoundingClientRect(),\n                    reverseX = initial[0] > M.x,\n                    reverseY = initial[1] > M.y,\n                    px = reverseX ? innerWidth - initial[0] : initial[0],\n                    py = reverseY ? innerHeight - initial[1] : initial[1],\n                    width = reverseX ? initial[0] - M.x : M.x - initial[0],\n                    height = reverseY ? initial[1] - M.y : M.y - initial[1]\n                ;\n\n                _this.mask.style = `${reverseX?\"right\":\"left\"}:${px}px;${reverseY?\"bottom\":\"top\"}:${py}px;width:${width}px;height:${height}px`\n            }\n\n            handle.on(\"start\", ()=>{\n                initial = [M.x, M.y]\n                this.mask.style.opacity = \"1\"\n                draw()\n            })\n            handle.on(\"move\", draw)\n            handle.on(\"end\", ()=>{\n                this.mask.style.opacity = \"0\"\n            })\n        }\n    }\n},"],"from":"ls-js/multiselect.js"},{"segment":"workspace","content":["Workspace(gl){\n    return _this => class LS_WorkSpace{\n        constructor (id, element, options = {}) {\n            _this = this;\n            this.id = id || M.GlobalID;\n            this.content = O(element || N());\n            this.content.class(\"ls-workspace-content\")\n            this.element = N({class: \"ls-workspace\"})\n            this.content.wrapIn(this.element);\n\n            this.options = {\n                maxZoom: 5,\n                minZoom: 0,\n                ...options\n            }\n\n            this.__x = 0;\n            this.__y = 0;\n\n            this.originCorrection = [0, 0];\n\n            this.__scale = 1;\n            this.hover = false;\n\n            let handle = LS.Util.touchHandle(this.element, {exclude: true, buttons: [1]});\n            handle.cursor = \"grabbing\";\n\n            this.define(this)\n\n            document.addEventListener('wheel', (event) => {\n                if (event.ctrlKey && this.element.matches(\":hover\")) {\n                    event.preventDefault();\n\n                    let zoomFactor = this.scale * .01\n                    let scale = _this.scale - (event.deltaY > 0 ? zoomFactor : -zoomFactor)\n\n                    let mouse = _this.mousePoint;\n                    this.content.style.transformOrigin = `${mouse.x}px ${mouse.y}px`\n                    // this.originCorrection = [scale*mouse.x, scale*mouse.y]\n                    this.correctPosition()\n\n\n                    this.scale = scale;\n                    \n                    // this.x -= M.x\n                }\n            }, { passive: false });\n\n            let initialX, initialY, initialWX, initialWY;\n            \n            handle.on(\"start\", ()=>{\n                initialX = M.x;\n                initialY = M.y;\n                initialWX = this.x;\n                initialWY = this.y;\n            })\n\n            handle.on(\"move\", (x, y, e)=>{\n                this.x = initialWX + (x - initialX)\n                this.y = initialWY + (y - initialY)\n            })\n\n            handle.on(\"end\", ()=>{\n\n            })\n        }\n\n        define(scope){\n            Object.defineProperty(scope, \"mousePoint\",{\n                get(){ return _this.relativePoint(M.x, M.y) }\n            })\n            Object.defineProperty(scope, \"scale\",{\n                get(){ return _this.__scale },\n                set(v){\n                    if(v < 0 || v < _this.options.minZoom || v > _this.options.maxZoom) return;\n                    _this.__scale = v;\n                    _this.content.style.transform = \"scale(\" + v + \")\"\n                }\n            })\n            Object.defineProperty(scope, \"x\",{\n                get(){ return _this.__x },\n                set(v){\n                    _this.__x = v;\n                    _this.correctPosition()\n                }\n            })\n            Object.defineProperty(scope, \"y\",{\n                get(){ return _this.__y },\n                set(v){\n                    _this.__y = v;\n                    _this.correctPosition()\n                }\n            })\n        }\n\n        move(x = _this.x, y = _this.y){\n            _this.x = x\n            _this.y = y\n        }\n\n        correctPosition(){\n            this.content.style.left = this.__x - _this.originCorrection[0] + \"px\"\n            this.content.style.top = this.__y - _this.originCorrection[1] + \"px\"\n        }\n\n        relativePoint(ax = M.x, ay = M.y){\n            // Gives you relative positions from an absolute one\n            let rect = _this.element.getBoundingClientRect(),\n                x = ax - rect.x,\n                y = ay - rect.y\n            ;\n            return {\n                x, y,\n                canvasX: _this.x + x,\n                canvasY: _this.y + y,\n                canvasXr: x - _this.x,\n                canvasYr: y - _this.y,\n            }\n        }\n\n        isInBounds(x = M.x, y = M.y){\n            let rect = _this.element.getBoundingClientRect(),\n                point = _this.relativePoint()\n            ;\n            return //TODO: Do the magic\n        }\n    }\n},"],"from":"ls-js/workspace.js"},{"segment":"toast","content":["Toast(gl)if(LS.v && LS.v >= 5)\r\n\r\nLS.LoadComponent(class Toast extends LS.Component {\r\n    constructor(){\r\n        super()\r\n\r\n        let container = this.container = N({\r\n            class: \"ls-toast-layer\"\r\n        });\r\n\r\n        LS.once(\"body-available\", () => {\r\n            LS._topLayer.add(container);\r\n        })\r\n    }\r\n\r\n    closeAll(){\r\n        this.invoke(\"close-all\")\r\n    }\r\n\r\n    show(content, options = {}){\r\n        let toast = N({\r\n            class: \"ls-toast\",\r\n            accent: options.accent || \"auto\",\r\n\r\n            inner: [\r\n                options.icon? N(\"i\", {class: options.icon}) : null,\r\n\r\n                N({inner: content, class: \"ls-toast-content\"}),\r\n\r\n                !options.uncancellable? N(\"button\", {\r\n                    class: \"elevated circle ls-toast-close\",\r\n                    inner: \"&times;\",\r\n\r\n                    onclick(){\r\n                        methods.close()\r\n                    }\r\n                }): null\r\n            ]\r\n        })\r\n\r\n        let methods = {\r\n            element: toast,\r\n\r\n            update(content){\r\n                toast.get(\".ls-toast-content\").set(content)\r\n            },\r\n\r\n            close(){\r\n                toast.class(\"open\", 0);\r\n                setTimeout(()=>{\r\n                    if(!options.keep) toast.remove()\r\n                }, 150)\r\n            }\r\n        }\r\n\r\n        this.once(\"close-all\", methods.close)\r\n\r\n        this.container.add(toast);\r\n\r\n        if(options.timeout) setTimeout(()=>{\r\n            methods.close()\r\n        }, options.timeout)\r\n        \r\n        setTimeout(()=>{\r\n            toast.class(\"open\")\r\n        }, 1)\r\n\r\n        return methods\r\n    }\r\n}, { global: true, singular: true })\r\n\r\nelse { throw \"You need to upgrade to LS v5 to use this version of the module or downgrade to an older release!\" },"],"from":"ls-js/toast.js"},{"segment":"sheet","content":["Sheet(gl){\n    return(_this) => class Sheet {\n        constructor(id, options = {}){\n            _this = this;\n\n            this.element = N({\n                class: \"ls-sheet-wrapper\"\n            })\n\n            this.container = N({\n                class: \"ls-sheet-container\"\n            })\n\n            this.element.add(this.container)\n\n            this.options = options = LS.Util.defaults({\n                element: N()\n            }, options)\n\n            this.container.add(this.options.element)\n\n            this.handle = LS.Util.touchHandle(this.container)\n\n            LS._topLayer.add(this.element)\n        }\n\n        open(){\n            _this.element.class(\"open\")\n        }\n        \n        close(){\n            _this.element.class(\"open\", false)\n        }\n    }\n},"],"from":"ls-js/sheet.js"},{"segment":"native","content":["Native(gl)\n/*\n\n[ About LS-Native ]\n\nLS-Native is an attempt at a cross-platform, fast and light-weight UI system that works well with mobile devices and desktops alike.\nIt combines navigation via keyboard shortcuts and gestures for seamless experience and familiarity.\n\nIt aims at being tiny in size, easy to deploy in any environment (thus its written in vanilla JavaScript and CSS), and is free and open-source!\n\nIt also has extensions made for seamless integration with other platforms like Android (material v3) and GTK on Linux.\nThis includes the synchronisation of color schemes, and of course dark/light themes, among other things.\n\n*/\n\n\n{\n    gl.conf = {\n        batch: false,\n        singular: true\n    }\n\n    return _this => class LSNative {\n        constructor(id, element) {\n            this.platform = window.LSNative_Android_Proxy? \"android\": window.arc? \"arc\": \"web\";\n\n            this.global = {\n                close(){\n                    switch(this.platform){\n                        case \"web\":\n                            return close()\n                        case \"android\":\n                            return LSNative_Android_Proxy.handle_void_void(\"close\")\n                        case \"arc\":\n                            return arc.closeWindow()\n                    }\n                }\n            }\n        }\n\n        connectAndriod(callback){\n            if(this.android) return this.android;\n\n            return new Promise((resolve, reject)=>{\n                if(typeof callback !== \"function\") throw \"Callback must be a function.\";\n    \n                let tools, timeout = 0;\n    \n                tools = {\n                    Resolve(event, data, options = {}){\n                        if(typeof options == \"string\") options = {type: options};\n\n                        let method = (\"handle_\" + ((data === null || typeof data == \"undefined\")? \"void\" : typeof data) + \"_\" + (options.type || \"void\")).toLowerCase().trim();\n\n                        if(!LSNative_Android_Proxy[method]) throw `Unsupported method (${method}). Make sure you have types set right.`;\n\n                        return LSNative_Android_Proxy[method](event)\n                    },\n\n                    showToast(text){\n                        return tools.Resolve(\"android.toast\", text)\n                    },\n    \n                    DynamicColors: {\n                        get isAvailable(){\n                            return tools.Resolve(\"dynamicColors.isAvailable\", null, \"boolean\")\n                        },\n    \n                        get isLightMode(){\n                            return tools.Resolve(\"dynamicColors.isLight\", null, \"boolean\")\n                        },\n    \n                        getColor(){\n                            return JSON.parse(tools.Resolve(\"dynamicColors.getColor\", null, \"string\"))\n                        },\n    \n                        getPalette(){\n                            return JSON.parse(tools.Resolve(\"dynamicColors.getPalette\", null, \"string\"))\n                        },\n    \n                        getMain(){\n                            return JSON.parse(tools.Resolve(\"dynamicColors.getMain\", null, \"string\"))\n                        },\n                    \n                        applyTheme(){\n                            let isLight = tools.DynamicColors.isLightMode;\n    \n                            O().attrAssign({\"ls-theme\": isLight? \"light\": \"dark\"})\n                            LS._topLayerInherit()\n                        },\n    \n                        applyAccent(){\n                            let colors = tools.DynamicColors.getMain();\n\n                            LS.Color.add(\"dynamicColor\", colors.primary)\n                            LS.Color.setAccent(\"dynamicColor\")\n                        }\n                    }\n                }\n    \n                function checkAvailability(){\n                    if(window.LSNative_Android_Proxy){\n    \n                        this.android = tools;\n                        this.platform = \"android\";\n                        resolve(tools)\n                        if(callback) callback(tools)\n                        clearInterval(awaiting)\n    \n                    } else {\n    \n                        timeout++\n                        if(timeout > 10){\n                            clearInterval(awaiting)\n                            resolve(null)\n                            if(callback) callback(null)\n                            throw new Error(\"Could not estabilish communication with the Java backend. Make sure you have setup your WebView properly and are using the latest version of the proxy library!\")\n                        }\n    \n                    }\n                }\n    \n                let awaiting = setInterval(checkAvailability, 50)\n                checkAvailability()\n            })\n\n        }\n    }\n}\n\n/*\n\nLS.Native.connectAndriod(async android => {\n    with(android){\n        DynamicColors.apply()\n    }\n})\n\n*/,"],"from":"ls-js/native.js"},{"segment":"automationgrapheditor","content":["AutomationGraphEditor(gl){\n\n    return _this => {\n        return class AutomationGraphEditor {\n            constructor(id, element, options = {}){\n                _this = this;\n\n                this.element = element;\n\n                this.element.class(\"ls-automationgraph\")\n\n                this.options = LS.Util.defaults({\n                    scaleX: 1,\n                    scaleY: 1,\n\n                    width: 460,\n                    height: 100,\n\n                    valueOffset: 0,\n\n                    editableCurvature: true,\n                    switcherTypes: [\"square\", \"linear\", \"curve\"],\n\n                    rightClickToCreate: true,\n\n                    defaultNewPoint: {\n                        type: \"square\"\n                    },\n\n                    values: {\n                        start: 0,\n                        points: []\n                    }\n                }, options)\n\n                this.uid = M.uid()\n\n                this.containerElement = N({\n                    class: \"ls-automationgraph-container\"\n                });\n\n                Object.defineProperty(this, \"values\", {\n                    get() {\n                        return _this.options.values || {start: 0, points: []}\n                    },\n\n                    set(newValues) {\n                        _this.options.values = newValues\n                        _this.redrawPoints()\n                    }\n                })\n\n                this.containerElement.on(\"contextmenu\", event => {\n                    if(_this.options.rightClickToCreate){\n                        event.preventDefault()\n\n                        if(O(event.target).hasClass(\"ls-automationgraph-point-handle\")) return;\n\n                        let box = this.containerElement.getBoundingClientRect()\n                        \n                        let point = {\n                            ..._this.options.defaultNewPoint,\n                            offset: ReverseTranslatePointX(event.clientX - box.x),\n                            value: ReverseTranslatePointY(event.clientY - box.y)\n                        }\n\n                        if(_this.values.points.find(_point => _point.offset === point.offset)) return;\n\n                        _this.values.points.push(point)\n                        _this.currentView.updateScale()\n                    }\n                })\n\n                this.element.add(this.containerElement)\n\n                this.startRenderer()\n            }\n\n            addPoint(point = {}, updateScreen = true){\n                _this.values.points.push({\n                    ..._this.options.defaultNewPoint,\n                    value: _this.values.start,\n                    offset: 0,\n                    ...point\n                })\n\n                if(updateScreen) _this.currentView.updateScale()\n            }\n\n            removePoint(index, updateScreen = true){\n                if(typeof index === \"string\"){\n                    index = _this.values.points.findIndex(point => point.id === index)\n                }\n\n                _this.values.points[index] = null\n\n                if(updateScreen) _this.currentView.updateScale()\n            }\n\n            destroy(){\n                if(_this.currentView) _this.currentView.destroy()\n            }\n\n            updateScale(x, y){\n                if(_this.currentView) _this.currentView.updateScale(x, y)\n            }\n\n            updateSize(newWidth, newHeight){\n                if(_this.currentView) _this.currentView.updateSize(newWidth, newHeight)\n            }\n\n            restartRenderer(){\n                _this.startRenderer()\n            }\n\n            redrawPoints(){\n                if(_this.currentView) _this.currentView.redrawPoints()\n            }\n\n            startRenderer(){\n                if(_this.currentView){\n                    _this.currentView.destroy()\n                }\n\n                let handles = {}, uniquePoints = new Set;\n\n                let current = {\n                    get values(){\n                        return _this.options.values\n                    }\n                }\n\n                _this.currentView = {\n                    destroy(){\n                        for(let handle in handles){\n                            if(handles[handle] && handles[handle].destroy){\n                                handles[handle].target.remove()\n                                handles[handle].destroy()\n                                delete handles[handle]\n                            }\n                        }\n\n                        handles = null;\n\n                        _this.containerElement.clear()\n                        _this.currentView = null\n                    },\n\n                    redrawPoints(){\n                        redrawAllPoints()\n                        draw()\n                    },\n\n                    updateScale(x, y){\n                        _this.options.scaleX = x || _this.options.scaleX\n                        _this.options.scaleY = y || _this.options.scaleY\n\n                        svgWidth = _this.options.width * _this.options.scaleX\n                        svgHeight = _this.options.height * _this.options.scaleY\n\n                        _this.containerElement.get(\"svg\").applyStyle({\n                            width: svgWidth +\"px\",\n                            height: svgHeight +\"px\",\n                        })\n\n                        _this.currentView.redrawPoints()\n                    },\n\n                    updateSize(newWidth, newHeight){\n                        _this.options.width = newWidth || _this.options.width\n                        _this.options.height = newHeight || _this.options.height\n\n                        _this.currentView.updateScale()\n                    }\n                }\n\n                let [svgWidth, svgHeight] = [_this.options.width * _this.options.scaleX, _this.options.height * _this.options.scaleY]\n\n                _this.containerElement.set(`<svg width=\"${svgWidth}\" height=\"${svgHeight}\"><defs><linearGradient id=\"lineGradient_${_this.uid}\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\"><stop offset=\"0%\" style=\"stop-color:var(--accent);stop-opacity:12%\" /><stop offset=\"100%\" style=\"stop-color:var(--accent);stop-opacity:4%\" /></linearGradient></defs><path class=\"ls-graph-stroke\" fill=\"none\" stroke=\"var(--accent)\" /><path class=\"ls-graph-fill\" fill=\"url(#lineGradient_${_this.uid})\" /></svg>`)\n\n                let pointSegments = []; // Move to the starting point\n\n                function getPath(){\n                    return `M 0 ${TranslatePointY(current.values.start)} ${pointSegments.join(\" \")}`\n                }\n        \n                function generatePoint(i){\n                    let point = current.values.points[i];\n                    \n                    let value = TranslatePointY(point.value)\n                    let offset = TranslatePointX(point.offset)\n                    if(!point.curvature) point.curvature = 0;\n\n                    const previousPoint = getPreviousPoint(i)\n\n                    switch(point.type){\n                        case \"curve\":\n                            // Curved line\n\n                            let controlPoints = _this.calculateCurvatureControlPoint(point.curvature, offset, value, previousPoint.x, previousPoint.y)\n            \n                            pointSegments[i] = `Q${controlPoints.x},${controlPoints.y} ${offset},${value}`\n                        break;\n\n                        case \"linear\":\n                            // Straight line\n\n                            pointSegments[i] = `L${offset},${value}`;\n                        break;\n\n                        default:\n                            // Straight jump\n                            pointSegments[i] = `L${offset},${previousPoint.y} L${offset},${value}`;\n                    }\n\n                    if (i === current.values.points.length -1){\n                        pointSegments[i] += ` L${_this.options.width * _this.options.scaleX},${value}`\n                    }\n\n                    return pointSegments[i]\n                }\n\n                function getPreviousPoint(i){\n                    return {\n                        x: i === 0 ? 0 : TranslatePointX(current.values.points[i - 1].offset),\n                        y: i === 0 ? TranslatePointY(current.values.start) : TranslatePointY(current.values.points[i - 1].value)\n                    }\n                }\n\n                function getNextPoint(i){\n                    return {\n                        x: i === current.values.points.length - 1 ? svgWidth : TranslatePointX(current.values.points[i + 1].offset),\n                        y: TranslatePointY(current.values.points[i].value)\n                    }\n                }\n\n                function redrawAllPoints(){\n                    let j = -1;\n\n                    current.values.points = current.values.points.filter(_ => _).sort((a, b) => a.offset - b.offset)\n\n                    pointSegments = []\n\n                    for (const point of current.values.points) {\n                        j++;\n\n                        if(!point.id) {\n                            point.id = M.uid()\n                            uniquePoints.add(point.id)\n                        }\n\n                        generatePoint(j)\n                        \n                        if(!handles.hasOwnProperty(point.id)){\n                            let i = +j;\n\n                            let value = TranslatePointY(point.value)\n                            let offset = TranslatePointX(point.offset)\n\n                            let handleElement = N({\n                                class: \"ls-automationgraph-point-handle\"\n                            });\n\n                            let controlPointHandleElement = N({\n                                class: \"ls-automationgraph-curve-handle\",\n                                style: \"display: none\"\n                            });\n            \n                            updateHandle()\n\n                            let handle = LS.Util.touchHandle(handleElement, {\n                                cursor: \"none\",\n                                buttons: [0]\n                            })\n\n                            let controlPointHandle = LS.Util.touchHandle(controlPointHandleElement, {\n                                cursor: \"none\",\n                                buttons: [0],\n                                pointerLock: true\n                            })\n            \n                            handles[point.id] = handle;\n                            handles[point.id + \"_control\"] = controlPointHandle;\n            \n                            function updateHandle(valuesChanged, updatedIndex){\n\n                                if(!valuesChanged){\n                                    value = TranslatePointY(point.value)\n                                    offset = TranslatePointX(point.offset)\n\n                                    i = typeof updatedIndex === \"number\"? updatedIndex: current.values.points.findIndex(_point => _point.id === point.id)\n                                }\n\n                                handleElement.style.setProperty(\"--bottom\", (svgHeight - value) + \"px\")\n                                handleElement.style.left = offset + \"px\";\n                                handleElement.style.top = value + \"px\";\n\n                                if(_this.options.editableCurvature){\n                                    let center, previousPoint, nextPoint;\n\n                                    switch(point.type){\n                                        case \"curve\":\n                                            previousPoint = getPreviousPoint(i)\n                                            \n                                            let controlPoints = _this.calculateCurvatureControlPoint(point.curvature, offset, value, previousPoint.x, previousPoint.y)\n\n                                            center = _this.calculatePathPoint(previousPoint.x, previousPoint.y, controlPoints.x, controlPoints.y, offset, value)\n                                            break\n\n                                        case \"linear\":\n                                            previousPoint = getPreviousPoint(i)\n\n                                            center = {\n                                                x: (previousPoint.x + offset) / 2,\n                                                y: (previousPoint.y + value) / 2,\n                                                r: Math.atan2(previousPoint.y - value, previousPoint.x - offset) * 180 / Math.PI\n                                            }\n                                            break\n\n                                        default:\n                                            previousPoint = getPreviousPoint(i)\n\n                                            center = {\n                                                x: offset + ((previousPoint.x - offset) / 2),\n                                                y: previousPoint.y\n                                            }\n                                    }\n\n                                    // controlPointHandleElement.style.opacity = Math.abs(center.x - offset) < 20? \".1\": \".5\"\n                                    controlPointHandleElement.style.left = center.x + \"px\";\n                                    controlPointHandleElement.style.top = center.y + \"px\";\n                                    controlPointHandleElement.style.display = \"block\";\n                                    controlPointHandleElement.style.transform = `translate(-50%, -50%) rotate(${center.r || 0}deg)`;\n\n                                } else controlPointHandleElement.style.display = \"none\";\n                            }\n\n                            handles[point.id].updateHandle = updateHandle;\n            \n                            handle.on(\"start\", () => {\n                                if(!current.values.points[i]){\n                                    handle.target.remove()\n                                    handle.destroy()\n                                    return\n                                }\n\n                                handleElement.class(\"active\")\n                                _this.invoke(\"handle.grab\", i, ReverseTranslatePointX(offset), ReverseTranslatePointY(value))\n                            })\n\n                            handle.on(\"move\", (x, y) => {\n                                let box = _this.containerElement.getBoundingClientRect();\n            \n                                let [newX, newY] = [x - box.x, y - box.y];\n            \n                                let prev = getPreviousPoint(i), next = getNextPoint(i);\n\n                                newX = Math.max(prev.x, Math.min(next.x, newX))\n                                newY = Math.max(0, Math.min(svgHeight, newY))\n            \n                                offset = newX;\n                                value = newY;\n\n                                updateHandle(true)\n\n                                if(current.values.points[i + 1] && handles[current.values.points[i + 1].id] && handles[current.values.points[i + 1].id].updateHandle) handles[current.values.points[i + 1].id].updateHandle(true)\n                                if(_this.options.editableCurvature && current.values.points[i - 1] && handles[current.values.points[i - 1].id] && handles[current.values.points[i - 1].id].updateHandle) handles[current.values.points[i - 1].id].updateHandle(true)\n\n                                current.values.points[i].offset = ReverseTranslatePointX(offset);\n                                current.values.points[i].value = ReverseTranslatePointY(value);\n                                _this.invoke(\"handle.change\", i, current.values.points[i].offset, current.values.points[i].value)\n                                    \n                                generatePoint(i)\n                                if(i !== current.values.points.length -1) generatePoint(i +1)\n                                draw()\n                            })\n            \n                            handle.on(\"end\", () => {\n                                handleElement.class(\"active\", false)\n                                _this.invoke(\"handle.release\", i, offset, value)\n                            })\n\n                            let _initialY = null, _initialValue;\n\n                            // controlPointHandle.on(\"start\", () => {\n                            //     _initialY = M.y\n                            //     _initialValue = current.values.points[i].curvature || 0\n                            // })\n\n                            // controlPointHandle.on(\"move\", (x, y) => {\n                            //     current.values.points[i].curvature = _initialValue + (y - _initialY);\n\n                            //     updateHandle(true)\n                            //     generatePoint(i)\n\n                            //     draw()\n                            // })\n\n                            controlPointHandle.on(\"start\", (x, y) => {\n                                let index = _this.options.switcherTypes.indexOf(point.type || \"square\") + 1\n\n                                if(index < 0) index = 0;\n                                if(index > _this.options.switcherTypes.length) index = 0;\n\n                                _this.values.points[i].type = _this.options.switcherTypes[index]\n\n                                _this.redrawPoints()\n                            })\n\n                            _this.containerElement.add(handleElement, controlPointHandleElement)\n\n                        } else {\n                            handles[point.id].updateHandle(null, j)\n                        }\n                    }\n\n                    let currentSet = new Set(current.values.points.map(point => point.id));\n\n                    for(let id in handles){\n                        if(!currentSet.has(id) && !id.endsWith(\"_control\")){\n                            // Point removed!\n\n                            // uniquePoints.delete(id)\n\n                            if(handles[id]) {\n                                handles[id].target.remove()\n                                handles[id].destroy()\n                                delete handles[id]\n                            }\n\n                            if(handles[id + \"_control\"]) {\n                                handles[id + \"_control\"].target.remove()\n                                handles[id + \"_control\"].destroy()\n                                delete handles[id + \"_control\"]\n                            }\n                        }\n                    }\n                }\n\n                function draw(){\n                    let path = getPath();\n\n                    _this.containerElement.get(\".ls-graph-stroke\").attr(\"d\", path)\n        \n                    path += ` L${_this.options.width * _this.options.scaleX},${svgHeight} `;\n                    path += `L0,${svgHeight} Z`;\n\n                    _this.containerElement.get(\".ls-graph-fill\").attr(\"d\", path)\n                }\n\n                redrawAllPoints()\n                draw()\n\n                return this.currentView\n            }\n\n            calculateCurvatureControlPoint(curvature, x1, y1, x2, y2) {\n\n                if(y1 > y2){\n                    let _x = x1, _y = y1;\n                    y1 = y2\n                    x1 = x2\n                    y2 = _y\n                    x2 = _x\n                }\n\n                return {\n                    x: x1 - (x1 - x2) / 2,\n                    y: y2 + (curvature || 0) * (x1 - x2) / 100\n                }\n            }\n\n            calculatePathPoint(x1, y1, x2, y2, x3, y3, t = .5) {\n                return {\n                    x: (1 - t) * (1 - t) * x1 + 2 * (1 - t) * t * x2 + t * t * x3, y: (1 - t) * (1 - t) * y1 + 2 * (1 - t) * t * y2 + t * t * y3,\n                    r: Math.atan2(y3 - y1, x3 - x1) * 180 / Math.PI\n                }\n            }\n        }\n\n        function TranslatePointY(point){\n            point = point - _this.options.valueOffset\n            return (100 - point) * _this.options.scaleY\n        }\n    \n        function TranslatePointX(point){\n            return point * _this.options.scaleX\n        }\n    \n        function ReverseTranslatePointY(point){\n            return (100 - (point / _this.options.scaleY)) +  _this.options.valueOffset\n        }\n    \n        function ReverseTranslatePointX(point){\n            return point / _this.options.scaleX\n        }\n    }\n},"],"from":"ls-js/automationgraph.js"},{"segment":"dialog","content":["Dialog(gl){\n    gl.conf.isFunction=!0;\n    return(_this)=>(opt={})=>{\n        opt=Object.assign({\n            title:\"Alert\",\n            content:\"\",\n            cancelable:true,\n            buttons:[\n                {text:\"OK\"},\n                {text:\"Cancel\",color:\"gray\"},\n            ],\n            loading:false,\n            keep:!1,\n            use:!1\n        },opt);\n        let m=new LS.Modal.new(null,!opt.use?N('div',{\n            inner:[\n                N('span',{\n                    inner:[N(\"b\",opt?.title?opt.title+\"<br>\":\"\"),N(\"span\",opt?.content?.trim?.())]\n                }),\n                N('div',{\n                    inner:opt.loading?[N(\"div\",{attr:[\"ls-load\"]})]:opt.buttons?.map?.(b=>N('button',Object.assign({attr:[\"ls\",\"fluent\",b.color?\"ls-\"+b.color:'ls-blue'],inner:b.text},(b?.element||{})))),\n                    attr:[\"dialog_bottom\"]\n                })\n            ],\n            attr:[\"ls-dialog-body\",\"ls-modal-body\"]\n        }):opt.use,opt);\n        m.buttonClose=(index)=>{\n            m.close();\n            if(opt.onclose)opt.onclose(index);\n            m.invoke(\"button_press\",index)\n        }\n        m.element.getAll(\"button\").forEach((e,i)=>e.on(\"click\",function(){m.buttonClose(i)}))\n        setTimeout(()=>m.show(),20);\n        return {\n            element:m.element,\n            close:m.hide,\n            hide:m.close,\n            open:m.show,\n            show:m.open,\n            destroy:m.destroy\n        }\n    }\n},"],"from":"ls-js/deprecated/dialog.js"},{"segment":"terminal","content":["Terminal(gl){\n    return(_this)=>class Console{\n        constructor(id,e=O(\"console\"),options={}){\n            if(!e)throw\"No element found for Terminal.\";\n            _this=this;\n            this.element=O(e);\n            this.input=N(\"textarea\",{style:\"opacity:0;position:fixed;bottom:0\",class:\"ls-console-inputarea\"});\n            this.input.on(\"focus\", \"blur\", (e)=>{\n                this.element.class(\"focus\", e.type == \"focus\")\n            })\n            this.cursor=N({class:\"ls-console-cursor\"});\n            this.container=N({class:\"ls-console-line-container\"});\n            let input;\n            Object.defineProperty(this, \"activeInput\", {\n                get(){\n                    return input\n                },\n                set(v){\n                    input = v\n                    this.inputPrev = \"\"\n                    this.input.value = this.data[v] || \"\"\n                    this.updateCursor()\n                    this.input.dispatchEvent(new Event('input'))\n                }\n            })\n            Object.defineProperty(this, \"em\", {\n                get(){\n                    return parseFloat(getComputedStyle(_this.container).fontSize)\n                }\n            })\n            Object.defineProperty(this, \"rows\", {\n                get(){\n                    return Math.round(_this.container.clientHeight/(1.32*_this.em))\n                }\n            })\n            Object.defineProperty(this, \"cols\", {\n                get(){\n                    return Math.round(_this.container.clientWidth/(_this.em*.6))\n                }\n            })\n            this.input.on(\"keypress\",\"input\",\"keydown\",\"keyup\",(event)=>{\n                if(event.type==\"keydown\"){\n                    if (event.ctrlKey && (event.key === 'c' || event.key === 'x' || event.key === 'v')) {\n                        _this.invoke(\"ctrl\"+event.key)\n                        event.preventDefault();\n                    }\n                    if (event.ctrlKey && event.shiftKey) {\n                        if (event.key === 'C') {\n                            document.execCommand('copy');\n                        } else if (event.key === 'V') {\n                            document.execCommand('paste');\n                        } else if (event.key === 'X') {\n                            document.execCommand('cut');\n                        }\n                    }            \n                }\n                this.updateCursor()\n            })\n            this.input.on(\"input\", ()=>{\n                if(this.activeInput&&this.element.has(\"#i_\"+this.activeInput)){\n                    let lines = this.input.value.split(\"\\n\"), element = this.element.get(\"#i_\"+this.activeInput+\" .text\");\n                    if(lines.length>this.inputPrev.split(\"\\n\").length)this.invoke(\"newline\",this.activeInput,this.inputPrev)\n                    if(\n                        (this.inputSize[0]!=\"*\"&&lines[0].length>+this.inputSize[0]) ||\n                        (this.inputSize[1]!=\"*\"&&lines.length>+this.inputSize[1])\n                    ){\n                        this.input.value=this.inputPrev\n                        return\n                    }\n                    this.data[this.activeInput]=this.input.value\n                    element.set(this.input.value)\n                    if(this.inputSize[1]!==\"*\"){\n                        for(let i=0;i<Math.max((+this.inputSize[1])-lines.length,0);i++){\n                            element.add(N(\"br\"))\n                        }\n                    }\n                    this.invoke(\"input\",this.activeInput,this.input.value)\n                    this.inputPrev=this.input.value\n                }\n            })\n            this.element.add(this.input, this.cursor, this.container).class(\"ls-console\")\n            ;(new ResizeObserver(e => {\n                this.updateSize()\n            })).observe(_this.container);\n            this.element.on(\"click\", ()=>this.input.focus())\n            this.lines = 0;\n            this.inputPrev = \"\";\n            this.data = {}\n            this.opt = Object.assign({proxy:!1,style:!0,overwrite:!1,highlightJS:!0,scroll:!0,max_lines:350},options)\n            if(this.opt.overwrite){this._console=Object.assign(console,this.__proto__);console=this};\n        }\n        addLine(opt,...lines){\n            if(_this.lines>=_this.opt.max_lines){_this.container.child().remove();_this.lines--;};\n\n            let ts = \"\";\n\n            opt=Object.assign({proxy:\"log\",nl:1},opt);\n            if(_this.opt.proxy)_this._console[opt.proxy](...lines);\n\n            //Parse type\n            lines=lines.map(v=>typeof v==\"object\"?JSON.stringify(v,null,4):typeof v==\"function\"?\"<i>%{#aaa}\"+v.toString()+\"%{/}</i>\":typeof v==\"number\"?\"%{#35f}\"+v+\"%{/}\":typeof v==\"boolean\"?(\"%{#a5f}\"+(v?\"true\":\"false\")+\"%{/}\"):v)\n            \n            //Parse styling\n            let styles=0, input = 0;\n            for(const [i,line] of lines.entries()){\n                lines[i]=line.split(\"%{\").map(c=>{\n                    let i=c.indexOf(\"}\");\n                    if(i!=-1){\n                        let s=c.split(\"}\")[0];\n                        if(s==\"/\"){\n                            return (styles>0?(styles--)+1&&\"</span>\":\"\")+c.substring(i+1)\n                        }\n                        if(s.startsWith(\"!\")){\n                            let id=s.split(\"!\")[1] || M.GlobalID, size = [\"*\",\"*\"]\n                            if(id.startsWith(\"[\")&&id.includes(\"]\")){\n                                size=(id.split(\"]\")[0].slice(1)).split(\",\")\n                                id=id.split(\"]\")[1]\n                            }\n                            let existing = this.element.get(\"#i_\"+id);\n                            if(existing){\n                                existing.id=\"\"\n                            }\n                            _this.data[id] = \"\";\n                            _this.inputSize = size;\n                            input = id;\n                            return `<span class=\"ls-console-inputfield\" id=\"i_${id}\"><span class=text></span></span>`\n                        }\n                        styles++;\n                        return\"<span style=\\\"\"+s.split(\";\").map(s=>{\n                            if(!s.includes(\":\")){return s.split(\",\").map((v,i)=>`${[\"color\",\"background\",\"outline\",\"font-style\",\"font-weight\",\"text-decoration\",\"cursor\"][i]||\"color\"}:${v||\"unset\"}`).join(\";\")}else{return s}\n                        }).join(\";\")+\"\\\">\"+c.substring(i+1)\n                    }\n                    return c;\n                }).join(\"\")\n            }\n\n            //Add icon\n            ts=(opt.proxy!==\"log\"?` <i class=bi-${{error:'x-circle-fill',info:'info-circle-fill',warn:'exclamation-triangle-fill',success:'check-circle-fill'}[opt.proxy]||\"\"}></i> `:\"\")+ts;\n            \n            let date=new Date;\n            let result=N(\"span\",{\n                inner: `<span style=color:${opt.color||_this.opt.color||'inherit'}>${ts}${lines.join(opt.nl?\"\\n\":\"\")}${opt.nl?\"\\n\":\"\"}`+(\"</span>\".repeat(styles+1)),\n                title: `${date.getMonth()+1}.${date.getDate()}.${date.getFullYear()} ${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}`\n            });\n\n            _this.container.add(result)\n            _this.invoke(\"line\",result.textContent)\n            if(_this.opt.scroll)_this.element.scroll(0,_this.element.scrollHeight+5000);\n            _this.lines++;\n            if(input)_this.activeInput=input;\n        }\n        updateCursor(){\n            if(_this.activeInput&&_this.element.has(\"#i_\"+_this.activeInput)){\n                _this.element.get(\"#i_\"+_this.activeInput)\n                _this.cursor.show();\n                _this.cursor.addTo(_this.element.get(\"#i_\"+_this.activeInput))\n\n                let start = _this.input.selectionStart,\n                    end = _this.input.selectionEnd,\n                    lbc = _this.input.value.substring(0, start).split('\\n'),\n                    direction = _this.input.selectionDirection == \"forward\",\n                    row = lbc.length,\n                    column = lbc[lbc.length - 1].length + 1\n                ;\n\n                _this.cursor.style=`top:${(row-1)*1.32}em;left:${(column-1)*.6}em;width:${.6*Math.abs(direction?end-start:start-end)+.6}em`\n                return\n            }\n            _this.cursor.hide();\n        }\n        updateSize(){\n            _this.invoke(\"resize\",_this.rows,_this.cols)\n        }\n        write(...t){_this.addLine({nl:0},...t)}\n        print(...t){_this.write(...t)}\n        log(...t){_this.addLine({},...t)}\n        clear(){_this.container.clear();_this.lines=0;if(_this.opt.proxy)_this._console.clear();_this.invoke(\"clear\")}\n        get(){}\n        error(...t){_this.addLine({proxy:\"error\",color:\"#f55\"},...t)}\n        warn(...t){_this.addLine({proxy:\"warn\",color:\"#fb2\"},...t)}\n        success(...t){_this.addLine({proxy:\"success\",color:\"#5f5\"},...t)}\n        info(...t){_this.addLine({proxy:\"info\",color:\"#5ff\"},...t)}\n    }\n},"],"from":"ls-js/deprecated/terminal.js"},{"segment":"editor","content":["Editor(gl){\n    gl.set(\"themes\",{\n        base:{\n            textarea:\"all:revert;position:absolute;inset:0;outline:none;background:#0000;color:#0000;resize:none;border:none\"\n        },\n        light:{\n            body:\"background:#fff;color:#000;woú:0\"\n        },\n        dark:{\n            include:\"base\",\n            body:\"background:#232a2f;color:#eee\"\n        },\n    });\n    return(_this)=>class Editor{\n        constructor(id,e,opt){\n            this.opt=Object.assign({indent:\"    \"},opt);\n            this.element=O(e||N(\"editor\"));\n            S(this.element,{\n                position:\"relative\",\n                width:this.element.attr(\"width\")||\"400px\",\n                height:this.element.attr(\"height\")||\"250px\",\n                display:\"block\"\n            });\n            this.element.className=\"ls-editor-body\";\n            _this=this;\n            this.style(gl.themes.dark);\n            this.element.set([\n                N(\"div\",{className:\"ls-editor-inner\",style:S({position:\"absolute\",display:\"block\",width:\"100%\",height:\"100%\"}),inner:[\n                    N(\"div\",{className:\"ls-editor-overlay\",style:S({\n                        position:\"absolute\",\n                        \"pointer-events\":\"none\",\n                        inset:\"0\",\n                        \"white-space\":\"pre\"\n                    })}),\n                    N(\"textarea\",{className:\"ls-editor-edit ls-editor-text\",inner:[\"hi\"],oninput:function(){\n                        _this.element.get(\".ls-editor-overlay\").innerHTML=this.value\n                    }})\n                ]})\n            ])\n\n        }\n        style(theme){\n            let r={};\n            function get(obj){\n                if(!obj)return;\n                Object.keys(obj).forEach(k=>{\n                    let t={};\n                    if(k==\"include\"){\n                        return obj[k].split(\",\").forEach(k=>get(gl.themes[k]))\n                    }\n                    r[k]=r[k]||{};\n                    obj[k].split(\";\").map(e=>e.split(\":\").map(e=>e.trim())).forEach(k=>t[k[0]]=k[1]);\n                    Object.assign(r[k],t)\n                })\n            }\n            get(theme);\n            Object.keys(r).forEach(k=>{console.warn(_this.element.querySelectorAll(\"*\"));(k==\"body\"?[_this.element]:_this.element.querySelectorAll(k)).forEach(e=>{console.log(1,e,r[k]);S(e,r[k])})})\n            console.log(r);\n        }\n        addTheme(key,theme){gl.themes[key]=theme}\n        set(){\n\n        }\n        get(){\n\n        }\n    }\n},"],"from":"ls-js/deprecated/editor.js"},{"segment":"fragment","content":["Fragment(gl){\n    let elementClass = class extends HTMLElement {\n        constructor(){\n            super();\n        }\n        connectedCallback(){\n            this.ls = LS.Fragment(this.id || M.GlobalID, this)\n            this.ls.load()\n        }\n    }\n    customElements.define('ls-fragment', elementClass);\n\n    return _this=>class LS_Fragment{\n        constructor(id, element, src){\n            _this = this;\n\n            this.element = O(element);\n            this.source = src || this.element.attr(\"src\");\n        }\n        async load(){\n            fetch(_this.source)\n                .then(response => response.text())\n                .then(html => {\n                    _this.element.innerHTML = html;\n                });\n        }\n    }\n},"],"from":"ls-js/deprecated/fragment.js"},{"segment":"form","content":["Form(gl){\n    return(_this)=>class FormItems{\n        constructor(id,e=O(\"form\"),options={}){\n            this.values={};\n            this.e=O(e);\n            this.opt=Object.assign({qs:\"[option],[option-radio]\",observe:false,autoUpdate:false},options);\n            _this=this;\n        }\n        _init(){\n            _this.update();\n            if(_this.opt.observe)E(_this.e,()=>{\n                _this.update()\n            })\n        }\n        update(){\n            for(const e of _this.e.getAll(_this.opt.qs)){\n                if(!e.hasAttr(\"option-radio\")||e._ls_form_checked)continue;\n                e._ls_form_checked=!0;\n                e.on(\"click\",()=>{\n                    let group=e.findParent(\"group[options]\"),name=_this._getName(group),value=_this._getValue(e);\n                    group.getAll(\"[option-radio].selected\").forEach(_e=>_e!=e&&_e.class(\"selected\",0))\n                    e.class(\"selected\",group.hasAttr(\"not-optional\")?1:2);\n                    if(!e.hasClass(\"selected\")){\n                        value=null\n                    }\n                    group[value?\"attr\":\"delAttr\"](\"ls-form-value\",value)\n                    if(_this.opt.autoUpdate)_this.get();\n                    _this.invoke(\"change\",name,value,\"radio\",e,group);\n                })\n            }\n        }\n        _getName(e){\n            return e.attr(\"option\")||e.attr(\"options\")||e.attr(\"name\")||e.attr(\"id\")||e.attr(\"title\")\n        }\n        _getValue(e){\n            return e.value||e.attr(\"value\")||e.attr(\"option\")||e.attr(\"option-radio\")||e.attr(\"title\")\n        }\n        get(){\n            for(const e of _this.e.getAll(_this.opt.qs+\",group[options]\")){\n                if(e.hasAttr(\"option-radio\"))continue;\n                _this.values[_this._getName(e)]=e.attr(\"ls-form-value\")||e.value||e.src\n            }\n            _this.invoke(\"values_changed\",_this.values)\n            return _this.values\n        }\n        reset(){\n            _this.values={};\n            _this.e.getAll(\"[option-radio].selected\").forEach(d=>d.classList.remove(\"selected\"));\n            for(const e of _this.e.getAll(_this.opt.qs+\",[default]\")){\n                O(e);\n                if(e.hasAttr(\"option-radio\"))continue;\n                if(e.matches(\"group[options]\")){e.attr(\"ls-form-value\",e.attr(\"default\"));continue};\n                e[{IMG:\"src\"}[e.tagName]||\"value\"]=e.attr(\"default\")\n            }\n        }\n    }\n},"],"from":"ls-js/deprecated/form.js"},{"segment":"steps","content":["Steps(gl){\n    gl.conf.requires=[\"Tabs\",\"Form\"];\n    return(_this)=>class Steps{\n        constructor(id, element = O(\"steps\"), o = {}){\n            console.warn(\"LS.Steps is currently outdated, thus may break, have performance or functional issues and is subject to a big change in the future\")\n\n            _this = this;\n            element = O(element);\n\n            this.opt = Object.assign({\n                listElement: null,\n                doneText: \"Done\",\n                select: \"ls-step, step\",\n                style: \"wizzard\",\n                buttons: true,\n                clickable: false,\n                bar: true\n            }, o);\n\n            this.form = LS.Form(\"steps_form_\" + id, element, {autoUpdate: true, observe: true});\n\n            this.tabs = LS.Tabs.new(\"step_tabs_\"+id, element, {\n                listClass: \"ls-steps ls-steps-\"+this.opt.style,\n                select: this.opt.select,\n                listItemClass: this.opt.listItemClass||\"ls-steps-item\",\n                noStyle: true,\n                infinite: false,\n                listClickable: this.opt.clickable,\n                listElement: this.opt.listElement,\n                mode: this.opt.mode,\n                bar: this.opt.list,\n                ...this.opt.tabOptions\n            });\n\n            this.element = element;\n            this.stack=[];\n            this.values={};\n            this.step=0;\n            this.stepIndex=this.tabs.tab;\n\n            if(this.opt.buttons){\n                if(this.opt.buttons.back !== false){\n                    if(!Array.isArray(this.opt.buttons.back)) this.opt.buttons.back = [this.opt.buttons.back];\n                    this.opt.buttons.back.forEach(element => this.setBackButton(element || null))\n                }\n                if(this.opt.buttons.next !== false){\n                    if(!Array.isArray(this.opt.buttons.next)) this.opt.buttons.next = [this.opt.buttons.next];\n                    this.opt.buttons.next.forEach(element => this.setNextButton(element || null))\n                }\n            }\n\n            this.tabs.on(\"tab_changed\", (i, tab)=>{\n                this.stepIndex = i;\n                this.invoke(\"step_changed\", i, tab);\n                let isRequired = this.tabs.tabs[tab].attr(\"required\");\n                this.setCanContinue(!(isRequired&&!this.values[isRequired]));\n                let last = i == this.tabs.order.indexOf(this.stack.at(-1));\n                this.invoke(\"last_step_\" + (last? \"enter\" : \"leave\"))\n\n                if(this.opt.buttons){\n                    this.element.getAll(\".ls-steps-next[finish-text]\").all(element => element.set(last? element.attr(\"finish-text\") || \"Done\" : \"Next\" ))\n                    S(this.element.getAll(\".ls-steps-previous\"), {opacity: i!=0?\"1\":\".4\" });\n                }\n            })\n\n            this.form.on(\"values_changed\",v=>{\n                this.values = v;\n            })\n\n            this.form.on(\"change\",(key,value,type,element,group)=>{\n                if(type !== \"radio\")return;\n                let rq = group.findParent(\"step\").attr(\"required\");\n\n                if(rq)_this.setCanContinue(!!_this.values[rq]);\n                _this.updateStack();\n            })\n        }\n        _init(){\n            this.reset();\n        }\n        getValues(){\n            return _this.form.get()\n        }\n        setCanContinue(v=!0){\n            if(this.opt.buttons)S(_this.opt.nextBtn,{opacity:v?\"1\":\".4\",\"pointer-events\":v?\"all\":\"none\"});\n        }\n        next(){\n            if(_this.step == this.stack.length-1) {\n                _this.invoke(\"done\",_this.form.get())\n            }\n\n            _this.updateStack()\n            if(_this.step<_this.stack.length-1) {\n                _this.tabs.setActive(_this.stack[(_this.step++)+1])\n            }\n        }\n        previous(){\n            _this.updateStack()\n            if(!_this.step<1) {\n                _this.tabs.setActive(_this.stack[(_this.step--)-1])\n            }\n        }\n        updateStack(){\n            _this.stack=[];\n            for(const tab of _this.tabs.order){\n                let e = _this.tabs.tabs[tab];\n                let pass=!(e.attr(\"if\")?e.attr(\"if\").split(\";\").map(c=>c.split(\"=\")).find(a=>_this.values[a[0]]==a[1]):!0);\n                if(_this.tabs.list)_this.tabs.list[tab].style.display=pass?\"none\":\"\";\n                if(pass){continue}\n                _this.stack.push(tab)\n            }\n            if(_this.tabs.list) _this.stack.forEach((e,i)=>{\n                e=_this.tabs.list[e];\n                e.class([\"last-child\",\"only-child\",\"first-child\"],0);\n                if(_this.stack.length<2){e.class(\"only-child\");return};\n                if(i==0)e.class(\"first-child\");\n                if(i==_this.stack.length-1)e.class(\"last-child\");\n            })\n        }\n        reset(){\n            _this.setCanContinue(!0);\n            _this.step=0;\n            _this.tabs.setActive(0,1);\n            _this.form.reset();\n            _this.updateStack()\n        }\n        setNextButton(element){\n            if(!element){\n                element = N(\"button\", {innerText: \"Next\", attr: {\"finish-text\": \"Done\"}});\n                _this.element.add(element)\n            }\n            element.class(\"ls-steps-next\")\n            element.on(\"click\", ()=>{\n                _this.next()\n            })\n        }\n        setBackButton(element){\n            if(!element){\n                element = N(\"button\", \"Previous\");\n                _this.element.add(element)\n            }\n            element.class(\"ls-steps-previous\")\n            element.on(\"click\", ()=>{\n                _this.previous()\n            })\n        }\n    }\n},"],"from":"ls-js/deprecated/steps.js"},{"segment":"debugger","content":["Debugger(gl){\n    return(_this)=>class ASD{\n        constructor(id,conf){\n            _this=this;\n            this.paused=0;\n            this.tickDelay=50;\n            setInterval(()=>{\n                if(this.paused)return;\n                this.invoke(\"tick\")\n            },this.tickDelay)\n        }\n        virtualElement(e,inherits=['borderRadius']){\n            let virtual=N({\n                style:{\n                    background: \"#4287ec45\",\n                    border:\"1px solid #505dfd\",\n                    position: \"fixed\",\n                    zIndex: 90000,\n                    pointerEvents: \"none\"\n                }\n            });\n            O().add(virtual)\n            _this.on(\"tick\",()=>{\n                let cs = S(e),\n                    rect = e.getBoundingClientRect()\n                S(virtual,{\n                    width:rect.width+\"px\",\n                    height:rect.height+\"px\",\n                    top:rect.top+\"px\",\n                    left:rect.left+\"px\",\n                })\n                for(const rule of inherits){\n                    virtual.style[rule]=cs[rule];\n                }\n            })\n        }\n    }\n},"],"from":"ls-js/deprecated/debugger.js"},{"segment":"chips","content":["Chips(gl){\n    return(_this)=>class Chips{\n        constructor(id,e=O(\"chips\"),options={}){\n            e=O(e);\n            this.options=Object.assign({},options)\n            if(!e)throw\"No element selected/found!\";\n            _this=this;\n            this.e=e;\n            this.id=id;\n            this.updateChips();\n            this.filter();\n        }\n        updateChips(){\n            _this.chips=_this.e.getAll(\"[ls-chip]\");\n            _this.chips.forEach(c=>c.onclick=function(){_this.chips.filter(a=>a!=this).forEach(e=>e.removeAttribute(\"selected\"));this.toggleAttribute(\"selected\");_this.filter()})\n        }\n        getSelected(){\n            return _this.chips.filter(e=>typeof e.attr(\"selected\")==\"string\").map(e=>e.attr(\"ls-chip\"))\n        }\n        filter(){\n            if(_this.getSelected().length<1)this.chips[0].attr(\"selected\",\"\");\n            Q(\"[ls-chip-filter*=\\\"\"+_this.id+\":\\\"]\").forEach(e=>{\n                e.style.display=_this.getSelected().find(s=>e.attr(\"ls-chip-filter\").match(/:(.*)/)[1].split(\",\").includes(s))?\"unset\":\"none\"\n            })\n        }\n    }\n},"],"from":"ls-js/deprecated/chips.js"},{"segment":"notif","content":["Notif(gl){\n    return(_this)=>class Notif{\n        constructor(id,opt={}){\n            this.el=N({class:\"ls-notif-area\",style:`width:${opt.width||300}px`,inner:[N({class:\"ls-notif-scroll\",inner:N({class:\"ls-notif-container\"})}),N({class:\"ls-notif-hide\",inner:\"<i class=bi-caret-down-fill></i>\",onclick:()=>{_this.el.classList.toggle(\"hidden\")}})]})\n            O().add(this.el)\n            _this=this;\n        }\n        push(c){\n            return new Promise(r=>{\n                if(typeof c==\"string\")c={content:c};\n                c=Object.assign({},c);\n                let e=N({class:\"ls-notif\",inner:[(c.title?N(\"b\",c.title+\"<br>\"):\"\"),c.content],style:\"color:var(--color-bg)\",attr:[c.color?\"ls-\"+c.color:\"\"]});\n                _this.el.get(\".ls-notif-container\").add(e);\n                let sc=setInterval(()=>_this.el.get(\".ls-notif-scroll\").scroll(0,_this.el.get(\".ls-notif-scroll\").scrollHeight),1);\n                setTimeout(()=>{e.classList.add(\"shown\");setTimeout(()=>{clearInterval(sc);r()},200)},10);\n            })\n        }\n        revoke(){\n\n        }\n    }\n},"],"from":"ls-js/deprecated/notif.js"},{"segment":"nanoreact","content":["NanoReact(gl){\n    gl.Group=function(obj){}\n    return(_this)=>class Reactor{\n        constructor(id){\n            _this=this;\n            console.warn(\"LS.NanoReact is currently outdated, thus may break, have performance or functional issues and is subject to a big change in the future\")\n            this.id=id;\n            this.list={};\n        }\n        apply(s){\n            Q(`[ls-react=\"${_this.id};${s}\"]`).all(e=>{\n                e.innerText = _this.list[s]\n            })\n        }\n        NewGlobal(name,initial){\n            _this.Register(window,name,initial)\n        }\n        RegisterNew(scope=window,init=null){\n            for(const e of Q(`[ls-react^=\"${_this.id};\"]`)){\n                let a=(e.attr(\"ls-react\")).split(\";\").at(-1);\n                if(a in _this.list)return;\n                _this.Register(scope,a,scope[a]||init)\n            }\n        }\n        RegisterBatch(scope=window,batch,init){\n            for(const a of batch){\n                if(a in _this.list)return;\n                _this.Register(scope,a,scope[a]||init)\n            }\n        }\n        Register(scope,name,initial=null){\n            let listName=name;\n            _this.list[listName]=initial;\n            Object.defineProperty(scope,name,{\n                get() {\n                    return _this.list[listName];\n                },\n                set(value) {\n                    _this.list[listName] = value;\n                    _this.apply(name);\n                }\n            });\n            _this.apply(name);\n        }\n    }\n},"],"from":"ls-js/deprecated/react.js"},{"segment":"menubar","content":["Menubar(gl){\n    return(_this)=>class Menubar{\n        constructor(id,e=O(\"menubar\"),options={}){\n            if(!e)throw\"No element found for menubar.\";\n            this.element=O(e);\n\n        }\n    }\n},"],"from":"ls-js/deprecated/menubar.js"},"\n});\n\n",{"segment":"knob","content":["\ncustomElements.define('ls-knob', class extends HTMLElement {\n    constructor(){\n        super();\n    }\n\n    connectedCallback(){\n        if(O(this).attr(\"ls-component\")) return;\n        if(O(this).hasClass(\"manual-init\")) return this.class(\"manual-init\", false);\n\n        this.ls = LS.Knob(this.id || M.GlobalID, this)\n    }\n});\n"]},{"segment":"menu","content":["\ncustomElements.define('ls-nav', class extends HTMLElement {\n    constructor(){\n        super();\n    }\n\n    connectedCallback(){\n        if(O(this).attr(\"ls-component\")) return;\n        if(O(this).hasClass(\"manual-init\"))return this.class(\"manual-init\", false);\n\n        this.ls = LS.Nav(this.id || M.GlobalID, this)\n    }\n});\n\nM.on(\"load\", ()=>{\n    Q(\"[ls-not-ready]\").all(e=>e.ready())\n})\n"]}]}