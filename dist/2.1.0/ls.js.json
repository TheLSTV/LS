{"components":["graphgl","accentmanager","eventresolver"],"content":[{"segment":"default","content":["\nString.prototype.replaceAll||(String.prototype.replaceAll=function(a,b){return\"[object regexp]\"===Object.prototype.toString.call(a).toLowerCase()?this.replace(a,b):this.replace(new RegExp(a,\"g\"),b)});\nif(!LS){\n    let isWeb = typeof window !== 'undefined', global = isWeb?window:global;\n    if(!global.hasOwnProperty(\"Globalise\")){global.Globalise=(...b)=>b.map(a=>typeof(a)=='string'?(()=>global[a]=global?.[a]||null)():Array.isArray(a)?a.map(v=>global[v]=global?.[v]||null):Object.keys(a).map(v=>global[v]=a[v]))}\n    var LS={\n        isWeb,\n        CDN: \"http://cdn.extragon.test\",\n        Util:{\n            resolve(...a){\n                return a.flat(Infinity).map(i=>{\n                    if(i?.tagName)return i;\n                    return [...N(\"temp\",i).childNodes];\n                }).flat();\n            },\n            objectPath(o,s,v,splitter,strict=false){\n                s=s.replace(/\\[(\\w+)\\]/g,splitter+'$1');\n                s=s.replace(new RegExp(\"^\\\\\"+splitter),'').replace(new RegExp(\"\\\\\"+splitter+\"+\",\"g\"),splitter);\n                if(s==\"\")return o;\n                let a=s.split(splitter);\n                for(let [i,k] of a.entries()){\n                    if(k in o){\n                        o=o[k];\n                    }else{\n                        if(strict)return null;\n                        o[k]=(i==a.length-1)?v||{}:{};o=o[k];\n                        if(i==a.length-1)return o;\n                    }\n                }\n                return o;\n            },\n            flatten(obj){\n\n            },\n            copy(text) {\n                return new Promise(r=>{\n                    if (navigator.clipboard && navigator.clipboard.writeText) {\n                    navigator.clipboard.writeText(text)\n                        .then(() => {\n                            r(!0)\n                        })\n                        .catch(error => {\n                            r(!1, error)\n                        })\n                    } else {\n                        //deprecated\n                        const _ = N('textarea',{value:text})\n                        O().add(_)\n                        _.select()\n                        D().execCommand('copy')\n                        O().removeChild(_)\n                        r(!0)\n                    }\n                })\n            },\n            ",{"segment":"manipulator","content":["Manipulate(str,mapper=\" *:\",options){\n    if(!mapper)return [str];\n    //Many of you may be confused on what this is.\n    //Remember the pain of learning regexp?\n    \n    //#~\\n{$>+\": \"} splits string by \\n, for each segment, add a \": \"\n    \">?/::/,\\\\*:/,[/+]*:/\";\n    let d=\"\";\n    let opt={\n        regMatch:/\\[(.*?)\\]/g,\n        blockMatch:/\\{(.*?)\\}/g,\n        stringMatch:/\"(.*?)\"|'(.*?)'|\\[\\[(.*?)\\]\\]/g,\n        bracketID:/\\((.*?)\\)/,\n        cases:{\n            a:\"toLowerCase\",\n            A:\"toUpperCase\",\n            b4:(str)=>btoa(str),\n            Aa:(str)=>str.split(\".\").map(s=>s.replace(/[a-zA-Z]/,l=>l.toUpperCase())).join(\".\"),\n            n:(str)=>+(str.match(/[0-9-]/g)||['0']).join(''),\n            uE:(str)=>encodeURIComponent(str),\n            uD:(str)=>decodeURIComponent(str),\n        },\n        ...options\n    };\n\n    function matchingBracket(){\n\n    }\n\n    let rx={};\n    \n    function getRegex(id,flags){\n        let m=id.match(opt.bracketID);\n        if(m)id=m[1];\n        return new RegExp(rx[id],flags)\n    }\n\n    function parseMapper(mapperString){\n        let _rx=mapperString.match(opt.regMatch),i=[],j=0;\n        _rx=_rx?_rx.map(e=>e.slice(1,-1)):[];\n        for(const regexp of _rx){\n            let id=M.GlobalID;\n            rx[id]=regexp;\n            i.push(id);\n        }\n        console.log(rx);\n        mapperString=mapperString.split(\",\").map(o=>o.replace(opt.stringMatch,()=>'$S('+(i[j++])+')')).map(o=>o.replace(opt.regMatch,()=>'$R('+(i[j++])+')'));\n        return mapperString\n    }\n\n    function block(o,str){\n        console.log(o);\n        if(o.length<1)return str;\n        if(o==\"t\"){\n            return str.trim();\n        }\n        if(opt.cases[o]){\n            if(typeof opt.cases[o]==\"function\"){\n                return str=opt.cases[o](str);\n            }\n            /*-->explanation*/d+=opt.cases[o]+\"\\n\";\n            return str=str[opt.cases[o]]();\n        }\n        if(['>','<','*'].includes(o[0])&&o[1]!=\":\"){\n            if(o[1]==\"?\"){\n                let c=o.slice(2).split(\":\"),i=str[o[0]==\">\"?\"startsWith\":\"endsWith\"](c[0]),r=str[o[0]==\">\"?\"indexOf\":\"lastIndexOf\"](c[0]);\n                if(o[0]==\">\"){\n                    str=str.slice(r<0?0:r);\n                    str=(i?c[1]:c[2])+str\n                }\n                if(o[0]==\"<\"){\n                    str=str.slice(0,r<0?Infinity:r+1)\n                    str+=i?c[1]:c[2];\n                }\n            }\n            return str;\n        }\n        if(o.startsWith(\"at(\")){\n            return str.at(opt.cases.n(o))\n        }\n        let cmd=\"replace\";\n        if(o[0]==\"-\"){\n            if(o[1]==\"*\"){\n                cmd=\"replaceAll\";\n                o=o.slice(1);\n            }\n            o=[o.slice(1),'']\n        }else{\n            o=o.split(\":\");\n            if(o[0].at(-1)==\"*\"){\n                cmd=\"replaceAll\";\n                o[0]=o[0].slice(0,-1);\n            }\n        }\n        if(o[0].startsWith(\"$R\"))o[0]=getRegex(o[0],cmd==\"replaceAll\"?\"g\":\"\");\n        \n        /*-->explanation*/d+=cmd+\" '\"+o[0]+\"' with '\"+o[1]+\"'\\n\";\n        str=str[cmd](o[0],o[1])\n        return str\n    }\n\n    for(const o of parseMapper(mapper)){\n        str=block(o,str);\n    }\n    return str||[str,d]\n}"],"from":"ls-js/manipulator.js"},"\n        },\n        ",{"segment":"tiny","content":["\n        TinyFactory(r){\n            return{\n                _affected:!0,\n                isElement:!0,\n                attr(specific=!1,value=!1){\n                    if(value){r.setAttribute(specific,value);return value};\n                    if(specific)return r.getAttribute(specific);\n                    let a = r.attributes,\n                        c = {};\n                    Object.keys(a).map(b => c[a[b].nodeName] = a[b].nodeValue);\n                    return specific ? c[specific] : c\n                },\n                attrAssign(a){\n                    if(typeof a==\"string\")a={Array:[a]};\n                    if(Array.isArray(a))a={Array:a};\n                    Object.keys(a).forEach(k=>{\n                        if(k=='Array'){\n                            a[k].map(_=>_&&r.setAttribute(_,''));\n                            return\n                        }\n                        (k&&r.setAttribute(k,a[k]||''))\n                    })\n                },\n                hasAttr:r.hasAttribute,\n                delAttr(...a){a=a.flat(2);a.forEach(a=>r.removeAttribute(a))},\n                class(names,action=1){\n                    if(typeof names==\"undefined\")return [...r.classList];\n                    if(typeof names==\"string\")names=names.split(\" \");\n                    for(let c of names){\n                        r.classList[(action==\"add\"||(!!action&&action!==\"remove\"))?(action==2||action==\"toggle\")?\"toggle\":\"add\":\"remove\"](c)\n                    }\n                    return r\n                },\n                hasClass(...names){\n                    let h=!0;\n                    names=names.flatMap(c=>{\n                        if(!r.classList.contains(c))h=!1\n                    })\n                    return h\n                },\n                get:(t='*')=>O(r, t),\n                getChildern:q=>Q(r.query()+'>'+q||'*'),\n                child:i=>r.children[i||0],\n                getAll: (t = '*') => Q(r, t),\n                add(...a){\n                    r.append(...LS.Util.resolve(...a));\n                    return r.self\n                },\n                addBefore(a){\n                    LS.Util.resolve(a).forEach(e=>r.parentNode.insertBefore(e,r))\n                    return r\n                },\n                addAfter(a){\n                    LS.Util.resolve(a).forEach(e=>r.parentNode.insertBefore(e,r.nextSibling))\n                    return r\n                },\n                addTo(a){\n                    O(a).add(r)\n                    return r\n                },\n                setTo(a){\n                    O(a).set(r)\n                    return r\n                },\n                move: r.addTo,\n                wrapIn(e){\n                    r.addAfter(e);\n                    e.appendChild(r);\n                    return r\n                },\n                addOnce(a){\n                    if (!O('#' + a.id)) r.add(a)\n                },\n                on(...events){\n                    let func=events.find(e=>typeof e==\"function\");\n                    for(const evt of events){\n                        if(typeof evt!=\"string\")continue;\n                        r.addEventListener(evt,func);\n                    }\n                    return r.self\n                },\n                hide(){r.style.display=\"none\"},\n                show(c){r.style.display=c||\"inherit\"},\n                applyStyle:(...a)=>S(r.self, ...a),\n                getStyle:_=>S(r.self),\n                set:(...a)=>{\n                    r.innerHTML = '';\n                    return r.add(...a)\n                },\n                clear(){r.innerHTML='';return r},\n                setText:(a)=>{\n                    r.innerText=a\n                },\n                has(...a){\n                    return !!a.find(l => r.get(l))\n                },\n                watch:c=>E(r, c),\n                parent: (n = 0) => r.tagName == 'BODY' ? r.parentElement : (n > 0 ? O(r.parentElement).parent(n - 1) : r.parentElement),\n                findParent(match,limit='html'){\n                    return r.path().reverse().find(e=>e.matches(match)||e.matches(limit))\n                },\n                self:r,\n                path:()=>{\n                    let p=[r],\n                        i=0;\n                    while(p[p.length - 1]?.tagName != 'HTML') {\n                        p.push(r.parent(i));\n                        i++\n                    }\n                    return p.reverse()\n                },\n                query:()=>r.path().map(r => r.tagName + (r.className ? '.' + r.className.replace(/\\s/g, '.') : '') + (r.id ? '#' + r.id : '')).join('>'),\n                queryPath: r.query\n            }\n        },\n        Tiny:{\n            Q: (e, q) => {\n                let elements = (e?.tagName && !q ? [e] : [...(e?.tagName ? e : D()).querySelectorAll(e?.tagName ? !q ? '*' : q : typeof e == 'string' ? e : '*')])?.map(r => {\n                    if(!r._affected){\n                        Object.assign(r,LS.TinyFactory(r));\n                        if(r.tagName==\"BR\")r.removeAttribute(\"clear\");\n                        Object.defineProperty(r, \"loading\", {\n                            get(){return r.hasAttribute(\"load\")},\n                            set(v){r[v?\"setAttribute\":\"removeAttribute\"](\"load\",\"\")},\n                        });\n                    }\n                    return r.self\n                }),bulk={\n                    all(prop){\n                        if(prop)for(const [i,a] of elements.entries()){\n                            prop(a,i)\n                        }\n                        if(!prop){\n                            function each(func,...attr){\n                                elements.forEach(e=>e[func](...attr))\n                            }\n                            let r={};\n                            for(const name of ['class','attr','add','set','clear','applyStyle','attrAssign','delAttr','on']){\n                                r[name]=function(...attr){each(name,...attr)}\n                            }\n                            return r;\n                        }\n                    }\n                };\n                return Object.assign(elements,bulk)\n            },\n            O: (...e) => {\n                e=e.length<1?['body']:e;\n                return Q(...e)[0]\n            },\n            D: () => document,\n            N:(e='div',o)=>{\n                if(typeof e!=\"string\"){o=e;e=\"div\"}\n                o=(typeof o=='string'?{innerHTML:o}:Array.isArray(o)?{inner:o}:o)||{};\n                let tmp={};\n                if(o.class){tmp.class=o.class;delete o.class}\n                if(o.ns){tmp.ns=o.ns;delete o.ns}\n                let n=O(Object.assign(D()[tmp.ns?\"createElementNS\":\"createElement\"](tmp.ns?tmp.ns:e,tmp.ns?e:null),o));\n                if(o.attr)n.attrAssign(o.attr);\n                if(tmp.class&&n.class)n.class(tmp.class);\n                if(o.style&&typeof o.style==\"object\")S(n,o.style);\n                if(o.inner||o.content)n.add(o.inner||o.content);\n                return n\n            },\n            S:(e,s)=>\n                !s?!e?O():(e.id!==void 0)?getComputedStyle(e):\n                typeof e=='string'?O(e):Object.keys(e).map(f => f + ':' + e[f]).join(';'):\n\n                (Array.isArray(e) ? e : !e ? [O()] : [e]).forEach(m => {\n                    m = typeof m == 'string' ? O(m) : m;\n                    Object.assign(m.style, s)\n                })\n            ,\n            E: (b, c) => {\n                if (typeof c != 'function') {\n                    let _c=c,\n                        _b=b;\n                    c=()=>{\n                        try {\n                            O(Q(_b), _c)\n                        }catch(e){}\n                    };\n                    b = O()\n                }\n                new(window.MutationObserver || window.WebKitMutationObserver)(r => {\n                    c([...r[0].addedNodes].map(n => O(n)), [...r[0].removedNodes].map(n => O(n)))\n                }).observe(b, {\n                    childList: !0,\n                    subtree: !0\n                });\n                return O(b)\n            },\n            T: (fn, fb, onerror = e => {}) => {\n                let r;\n                try {\n                    r = fn()\n                } catch (e) {\n                    r = fb;\n                    onerror(e)\n                }\n                return r\n            },\n            U(url=location.href){\n                return Object.assign(new URL(url),{\n                    goTo(){location.href=url},\n                    open(){open(url)},\n                    get segments(){return location.pathname.split(\"/\").filter(s=>s)},\n                    async fetch(opt){return await fetch(url,opt)},\n                    reload(){location.replace(url)},\n                    params(specific=!1){if(!url.includes('?')){return specific?null:{}}let o={};url.replaceAll(/(.*?)\\?/gi,'').split('&').forEach(e=>{e=e.split('=');o[e[0]]=decodeURIComponent(e?.[1]).replace(/#(.*)/g,\"\")});return specific?o[specific]:o}\n                })\n            },\n            M:{x:0,y:0,_GlobalID:{count:0,prefix:Math.round(Math.random()*1e3)},lastKey:null,ShiftDown:!1,ControlDown:!1,mouseDown:!1,on(...events){let func=events.find(e=>typeof e==\"function\");for(const evt of events){if(typeof evt!=\"string\")continue;global.addEventListener(evt,func)}return M},\n                get GlobalIndex(){\n                    M._GlobalID.count++;\n                    return +((\"\"+M._GlobalID.prefix)+(\"\"+M._GlobalID.count))\n                },\n                get GlobalID(){return M.GlobalIndex.toString(36)},\n                Style(url){\n                    return new Promise((r,j)=>{\n                        O(\"head\").add(N(\"link\",{rel:\"stylesheet\",href:url,onload(){r()},onerror(e){j(e.toString())}}))\n                    })\n                },\n                Script(url){\n                    return new Promise((r,j)=>{\n                        O(\"head\").add(N(\"script\",{src:url,onload(){r()},onerror(e){j(e.toString())}}))\n                    })\n                },\n                Component(...list){\n                    list = list.filter(c=>!LS[c])\n                    if(list.length<1)return;\n                    return M.Script(LS.CDN+\"/ls/js/2/@Bare,\"+list.join(\",\").replaceAll(/[ \\n/?]/g,\"\"))\n                },\n                StyleComponent(...list){\n                    return M.Style(LS.CDN+\"/ls/css/2/@Bare,\"+list.join(\",\").replaceAll(/[ \\n/?]/g,\"\"))\n                },\n                Document(url, target){\n                    return new Promise((r,j)=>{\n                        fetch(url)\n                            .then(async q=>{\n                                q = await q.text();\n                                (O(target)||O()).add(q);\n                                r()\n                            })\n                            .catch(e=>j(e.toString()))\n                    })\n                },\n                loop(t,...f){\n                    for(let i=0;i<t;i++){\n                        for(const fn of f){\n                            fn(i)\n                        }\n                    }\n                }\n            }\n        },\n        "]},"\n        async LoadComponents(c){\n            for(const D of Object.keys(c)){\n                if(LS[D]){console.warn(\"[LS] Duplicate component name \\\"\"+D+\"\\\"\");continue};\n                function instance(...a){\n                    if(LS[D].conf.isFunction)return (LS[D].class({}))(...a);\n                    if(a[0] instanceof Element)a[0]=a[0].id||\"default\";\n                    return LS[D].list[a[0]||\"default\"]||LS[D].new(...a);\n                }\n                LS[D]=function Component(...a){return instance(...a)};\n                LS[D].new=function(id,...a){\n                    if(a[0] instanceof Element){\n                        a[0]=O(a[0]);\n                        if(a[0].attr(\"ls-component\")==D.toLowerCase())return LS[D].list[id]||undefined;\n                        a[0].attr(\"ls-component\",D.toLowerCase())\n                    }\n                    let i=new((LS[D].class)({}))(id,...a);\n                    if(LS[D].conf.events)i.Events=new (LS.EventResolver())(i);\n                    if(i._init)i._init();\n                    if(id)LS[D].list[id]=i;\n                    return i\n                }\n                LS[D].set=function(key,value){LS[D][key]=value};\n                LS[D].list={};\n                LS[D].conf={};\n                LS[D].class=((c[D])(LS[D]));\n                let dp=LS[D].conf?.requires;\n                if(Array.isArray(dp)){\n                    for(const dep of dp){\n                        if(!LS[dep]||!c[dep]){\n                            if(LS._disableAutomaticDownloading){\n                                delete LS[D];\n                                LS[D]=false;\n                                console.error(`[LS Framework] Unmet dependency of \"${D}\": \"${dep}\" ${dp.length>1?`(All dependencies are: ${dp.map(d=>'\"'+d+'\"').join(\", \")})`:''}\\nThis component will not work until the dependencies are met.`);\n                                break\n                            }\n                            await M.Component(dep)\n                        }\n                    }\n                    if(!LS[D])break;\n                }\n                LS[D].conf=Object.assign({batch:!0,events:!0},LS[D].conf);\n                if(LS[D].conf.events)LS[D].Events=new (LS.EventResolver())(LS[D]);\n                if(LS[D].conf.singular){\n                    if(LS[D].conf.becomeClass){LS[D]=LS[D].class;continue};\n                    LS[D]=LS[D].new(\"global\");\n                }else if(LS[D].conf.batch){\n                    LS[D].batch=(e,conf,unique=!0)=>{\n                        if(typeof e==\"string\")e=Q(e);\n                        if(!Array.isArray(e))e=[...O(e).children];\n                        for(const m of e){\n                            new LS[D].new((unique?m.id:null)||\"auto_\"+M.GlobalID,m,conf)\n                        }\n                    }\n                    LS[D].registerGroup=LS[D].batch;\n                    LS[D].observe=(selector,previous,parent=O())=>{\n                        if(previous)LS[D].batch(selector);\n                        E(parent,async(a,r)=>{\n                            for(const m of a){\n                                if(m.matches(selector)){\n                                    LS[D].new((await LS[D].invoke(\"observer_element_added\",m)).filter(h=>h)[0]||m.id||\"observed_\"+M.GlobalID,m)\n                                }\n                            }\n                        })\n                        return\"Observer added for \\\"\"+D+\"\\\" looking for any \"+selector;\n                    }\n                }\n                if(LS.invoke){\n                    LS.invoke(\"componentLoad\", D)\n                    LS.invoke(\"componentLoad:\"+D)\n                }\n            }\n        }\n    }\n    ",{"segment":"tiny","content":["\n    if(isWeb){\n        Globalise(LS.Tiny);\n        Object.assign(U,U())\n        M.on(\"mousemove\",e=>{M.x=e.clientX;M.y=e.clientY}).on(\"keydown\",e=>{M.lastKey=e.key;if(e.key==\"Shift\")M.ShiftDown=!0;if(e.key==\"Control\")M.ControlDown=!0}).on(\"keyup\",e=>{M.lastKey=e.key;if(e.key==\"Shift\")M.ShiftDown=!1;if(e.key==\"Control\")M.ControlDown=!1}).on(\"mousedown\",e=>M.mouseDown=!0).on(\"mouseup\",e=>M.mouseDown=!1);\n        O(D().documentElement)\n        \n\n        if(!global?.dialog)global.dialog=LS.Dialog;\n        if(!global?.modal)global.modal=dialog;\n        Globalise({\n            alert:(m,opt={})=>\n                new Promise((r)=>modal(Object.assign({content:m,buttons:[{text:\"OK\"}],onclose:r},opt))),\n            confirm:(m,opt={})=>\n                new Promise((r)=>modal(Object.assign({content:m,buttons:[{text:\"OK\"},{text:\"Cancel\"}],onclose:b=>r(!b)},opt))),\n            prompt:(m,opt={})=>\n                new Promise((r)=>modal(Object.assign({content:m+\"<br><input placeholder='Enter data' class=ls-modal-prompt type=text ls fluent>\",buttons:[{text:\"OK\"},{text:\"Cancel\",color:\"gray\"}],onclose:(c,m)=>r(c!==0?null:m.element.get(\"input\").value)},opt)))\n        })\n        let loading, loaded;\n        M.on(\"keydown\", async(event) => {\n            if(loading)return;\n            if (event.ctrlKey && event.altKey && event.key === \"c\") {\n                if(!LS.ToolBox && !loaded){\n                    loading = true;\n                    LS._debugToolBoxShow = true;\n                    await M.Component(\"toolbox\")\n                    loading = false;\n                    loaded = true\n                    return\n                }\n                LS.ToolBox.toggle();\n            }\n        });\n    }\n    "]},"\n}\n"]},{"segment":"manipulator","content":["\nString.prototype.manipulate=function(mapper=\" *:\"){return LS.Util.Manipulate(\"\"+this,mapper)}\nString.prototype.manip=String.prototype.manipulate;\n"]},"\n\nLS.LoadComponents({\n    ",{"segment":"eventresolver","content":["EventResolver(gl){\n    gl.conf = {\n        batch: false,\n        events: false,\n        singular: true,\n        becomeClass: true\n    }\n    return(_this)=>class EventClass{\n        constructor(target = null){\n            this.listeners = [];\n            this.events = [];\n            _this = this;\n            if(target){\n                Object.assign(target, {\n                    emit: this.invoke,\n                    invoke: this.invoke,\n                    on: this.on,\n                    once: this.once,\n                    off: this.off\n                })\n            }\n        }\n        async invoke(evt, ...a){\n            let ReturnValues=[];\n            if(!_this.events.includes(evt)) _this.events.push(evt);\n\n            for(const e of _this.listeners){\n                if(!e || e.for !== evt) continue;\n                ReturnValues.push(await e.f(...a));\n                if(e.once)delete _this.listeners[e.i];\n            }\n            return ReturnValues\n        }\n        on(type, evt, extra){\n            let index = _this.listeners.length;\n            _this.invoke(\"event-listener-added\", index)\n            _this.listeners.push({\n                for: type,\n                f: evt,\n                i: index,\n                id: M.GlobalID,\n                ...extra\n            })\n            return _this\n        }\n        once(type, evt, extra){\n            _this.on(type, evt, {\n                once: true,\n                ...extra\n            })\n            return _this\n        }\n        off(type, evt){\n            for(const e of _this.listeners){\n                if(e.f == evt) return delete _this.listeners[e.i];\n            }\n            return false\n        }\n        onChain(...events){\n            let func=events.find(e=>typeof e==\"function\");\n            for(const evt of events){\n                _this.on(evt,func);\n            }\n        }\n    }\n},"],"from":"ls-js/eventresolver.js"},{"segment":"modal","content":["Modal(gl){\n    return(_this)=>class Modal{\n        constructor(id,content=N(),opt={}){\n            _this=this;\n            this.options=Object.assign({target:O()},opt);\n            this.isOpen=false;\n            this.contentElement=content;\n            this.element=N(\"div\",{\n                attr:{\"ls-modal\":\"true\"},\n                className:\"closed\",\n                style:opt.style,\n                onclick:e=>{if(opt.cancelable&&O(e.target).attr(\"ls-modal\"))this.hide()},\n                inner:[content]\n            });\n            (this.options.target||O()).add(this.element);\n            this.open=_this.show;\n            this.close=_this.hide;\n        }\n        show(){\n            _this.element.style.zIndex=LS.Modal.layer||5000;\n            LS.Modal.layer=(LS.Modal.layer||5000)+1;\n            _this.invoke(\"open\");\n            _this.element.class('closed',0);\n            _this.isOpen=!0;\n        }\n        hide(){\n            _this.invoke(\"close\");\n            _this.element.class(\"closed\");\n            _this.isOpen=!1;\n            if(_this.options.keep===!1){setTimeout(()=>_this.destroy(),1000)};\n        }\n        destroy(){\n            _this.element.remove()\n        }\n    }\n},"],"from":"ls-js/modal.js"},{"segment":"dialog","content":["Dialog(gl){\n    gl.conf.isFunction=!0;\n    return(_this)=>(opt={})=>{\n        opt=Object.assign({\n            title:\"Alert\",\n            content:\"\",\n            cancelable:true,\n            buttons:[\n                {text:\"OK\"},\n                {text:\"Cancel\",color:\"gray\"},\n            ],\n            loading:false,\n            keep:!1,\n            use:!1\n        },opt);\n        let m=new LS.Modal.new(null,!opt.use?N('div',{\n            inner:[\n                N('span',{\n                    inner:[N(\"b\",opt?.title?opt.title+\"<br>\":\"\"),N(\"span\",opt?.content?.trim?.())]\n                }),\n                N('div',{\n                    inner:opt.loading?[N(\"div\",{attr:[\"ls-load\"]})]:opt.buttons?.map?.(b=>N('button',Object.assign({attr:[\"ls\",\"fluent\",b.color?\"ls-\"+b.color:'ls-blue'],inner:b.text},(b?.element||{})))),\n                    attr:[\"dialog_bottom\"]\n                })\n            ],\n            attr:[\"ls-dialog-body\",\"ls-modal-body\"]\n        }):opt.use,opt);\n        m.buttonClose=(index)=>{\n            m.close();\n            if(opt.onclose)opt.onclose(index);\n            m.invoke(\"button_press\",index)\n        }\n        m.element.getAll(\"button\").forEach((e,i)=>e.on(\"click\",function(){m.buttonClose(i)}))\n        setTimeout(()=>m.show(),20);\n        return {\n            element:m.element,\n            close:m.hide,\n            hide:m.close,\n            open:m.show,\n            show:m.open,\n            destroy:m.destroy\n        }\n    }\n},"],"from":"ls-js/dialog.js"},{"segment":"tabs","content":["Tabs(gl){\n    return(_this)=>class Tabs{\n        constructor(id, e=O(\"tabs\"), opt={}){\n            this.element = O(e);\n            if(!e)throw\"No element provided\";\n            _this=this;\n            this.tabs = {};\n            this.order=[];\n            this.opt = Object.assign({\n                list: true,\n                listClass: \"\",\n                listItemClass: \"\",\n                listClickable: true,\n                hide: true,\n                noStyle: false,\n                mode: \"default\",\n                listElement: null,\n                infinite: true\n            }, T(() => JSON.parse(_this.element.attr(\"tab-options\")), {}), opt);\n            if(this.opt.listElement)_this.opt.listElement.className=_this.opt.listElement.className+\" tablist \"+_this.opt.listClass;\n            this.hasList = !!this.opt.list;\n            if(this.opt.list){\n                this.list={};\n                this.listElement=_this.opt.listElement||N(\"div\",{className:\"tablist \" + _this.opt.listClass + (_this.opt.noStyle?\"\":\" tablist-style\")})\n                if(!this.opt.listElement)O(e).prepend(this.listElement)\n            }\n            \n            (this.opt.select?\n                O(e).getAll(this.opt.select):\n                [...O(e).children]\n            ).forEach(t=>{\n                if(O(t).hasClass(\"tablist\"))return;\n                this.addExisting(t)\n            })\n        }\n        _init(){\n            _this.setActive(0);\n        }\n        setActive(tab, force=false){\n            if(typeof tab==\"number\"){\n                tab=_this.order[tab]\n            }\n\n            let element = _this.tabs[tab],\n                index = _this.order.indexOf(tab)\n\n            if(!element)return false;\n            if(_this.activeTab==tab&&!force)return true;\n\n            if(_this.opt.list){\n                Object.keys(_this.list).forEach(t=>{\n                    _this.list[t].class(\"active\",tab == t)\n                })\n            }\n\n            for(const _tab in _this.tabs){\n                let _element = O(_this.tabs[_tab]);\n                if(!_element || _tab == tab){\n                    continue\n                }\n                _element.class(\"tab-active\",0)\n                if(_this.opt.hide && _this.opt.mode!=\"presentation\")_element.hide()\n            }\n\n            element.style.display=\"\"\n            element.class(\"tab-active\")\n\n            _this.element.attr(\"active-tab\", tab)\n            _this.activeTab = tab\n            _this.tab = index\n            _this.invoke(\"tab_changed\", index, tab)\n            return true\n        }\n        addExisting(element, opt = {}){\n            return _this.add(null, element, {isReady: true, ...opt})\n        }\n        add(title, content = N(), opt = {}){\n            let e = opt.isReady&&content ?O(content): N(\"tab\",{\n                inner:content,\n                attr:{\"tab-title\":title}\n            });\n\n            if(!e.hasAttr(\"tab-title\"))e.attr(\"tab-title\", title)\n\n            let id = opt.id||(typeof opt==\"string\"&&opt)||content.id||e.attr(\"tab-id\")||\"tab_\"+M.GlobalID;\n            e.attr(\"tab-id\", id)\n\n            if(!opt.isReady)_this.element.add(e);\n            _this.tabs[id] = e;\n            _this.order.push(id);\n\n            _this.addToList(id);\n            return id;\n        }\n        addToList(tab){\n            //FIXME: Make it more like \"updateList\" that updates the order\n            if(!_this.opt.list)return;\n            let element = _this.tabs[tab], nt=N(\"div\",{\n                innerHTML:element.attr(\"tab-title\")||tab,\n                attr:{for:tab},\n                className:\"_tab \"+(_this.opt.noStyle?\"\":\"_tab_style \")+_this.opt.listItemClass,\n                onclick(){if(_this.opt.listClickable)_this.setActive(tab)}\n            });\n            _this.list[tab] = nt\n            _this.listElement.add(nt)\n        }\n        remove(id){\n        }\n        next(){\n            _this.tab=_this.tab>_this.length()-2?_this.opt.infinite?0:_this.tab:_this.tab+1;\n            _this.setActive(_this.tab)\n        }\n        previous(){\n            _this.tab=_this.tab<1?_this.opt.infinite?_this.length()-1:_this.tab:_this.tab-1;\n            _this.setActive(_this.tab)\n        }\n        length(){\n            return _this.tabs.length\n        }\n    }\n},"],"from":"ls-js/tabs.js"},{"segment":"form","content":["Form(gl){\n    return(_this)=>class FormItems{\n        constructor(id,e=O(\"form\"),options={}){\n            this.values={};\n            this.e=O(e);\n            this.opt=Object.assign({qs:\"[option],[option-radio]\",observe:false,autoUpdate:false},options);\n            _this=this;\n        }\n        _init(){\n            _this.update();\n            if(_this.opt.observe)E(_this.e,()=>{\n                _this.update()\n            })\n        }\n        update(){\n            for(const e of _this.e.getAll(_this.opt.qs)){\n                if(!e.hasAttr(\"option-radio\")||e._ls_form_checked)continue;\n                e._ls_form_checked=!0;\n                e.on(\"click\",()=>{\n                    let group=e.findParent(\"group[options]\"),name=_this._getName(group),value=_this._getValue(e);\n                    group.getAll(\"[option-radio].selected\").forEach(_e=>_e!=e&&_e.class(\"selected\",0))\n                    e.class(\"selected\",group.hasAttr(\"not-optional\")?1:2);\n                    if(!e.hasClass(\"selected\")){\n                        value=null\n                    }\n                    group[value?\"attr\":\"delAttr\"](\"ls-form-value\",value)\n                    if(_this.opt.autoUpdate)_this.get();\n                    _this.invoke(\"change\",name,value,\"radio\",e,group);\n                })\n            }\n        }\n        _getName(e){\n            return e.attr(\"option\")||e.attr(\"options\")||e.attr(\"name\")||e.attr(\"id\")||e.attr(\"title\")\n        }\n        _getValue(e){\n            return e.value||e.attr(\"value\")||e.attr(\"option\")||e.attr(\"option-radio\")||e.attr(\"title\")\n        }\n        get(){\n            for(const e of _this.e.getAll(_this.opt.qs+\",group[options]\")){\n                if(e.hasAttr(\"option-radio\"))continue;\n                _this.values[_this._getName(e)]=e.attr(\"ls-form-value\")||e.value||e.src\n            }\n            _this.invoke(\"values_changed\",_this.values)\n            return _this.values\n        }\n        reset(){\n            _this.values={};\n            _this.e.getAll(\"[option-radio].selected\").forEach(d=>d.classList.remove(\"selected\"));\n            for(const e of _this.e.getAll(_this.opt.qs+\",[default]\")){\n                O(e);\n                if(e.hasAttr(\"option-radio\"))continue;\n                if(e.matches(\"group[options]\")){e.attr(\"ls-form-value\",e.attr(\"default\"));continue};\n                e[{IMG:\"src\"}[e.tagName]||\"value\"]=e.attr(\"default\")\n            }\n        }\n    }\n},"],"from":"ls-js/form.js"},{"segment":"steps","content":["Steps(gl){\n    gl.conf.requires=[\"Tabs\",\"Form\"];\n    return(_this)=>class Steps{\n        constructor(id,e=O(\"steps\"),o={}){\n            _this=this;\n            e=O(e);\n\n            this.opt = Object.assign({\n                listElement: null,\n                doneText: \"Done\",\n                select: \"ls-step, step\",\n                style: \"wizzard\",\n                buttons: true,\n                clickable: false,\n                bar: true\n            }, o);\n\n            this.form = LS.Form(\"steps_form_\"+id, e, {autoUpdate: true, observe: true});\n\n            console.log(\n                Q(this.opt.select)\n            );\n\n            this.tabs = LS.Tabs.new(\"step_tabs_\"+id, e, {\n                listClass: \"ls-steps ls-steps-\"+this.opt.style,\n                select: this.opt.select,\n                listItemClass: this.opt.listItemClass||\"ls-steps-item\",\n                noStyle: true,\n                infinite: false,\n                listClickable: this.opt.clickable,\n                listElement: this.opt.listElement,\n                mode: this.opt.mode,\n                bar: this.opt.list,\n                ...this.opt.tabOptions\n            });\n\n            this.element=e;\n            this.stack=[];\n            this.values={};\n            this.step=0;\n            this.stepIndex=this.tabs.tab;\n\n            if(this.opt.buttons){\n                if(this.opt.buttons.back!==false){\n                    if(!Array.isArray(this.opt.buttons.back))this.opt.buttons.back=[this.opt.buttons.back];\n                    this.opt.buttons.back.forEach(e => this.setBackButton(e || null))\n                }\n                if(this.opt.buttons.next!==false){\n                    if(!Array.isArray(this.opt.buttons.next))this.opt.buttons.next=[this.opt.buttons.next];\n                    this.opt.buttons.next.forEach(e => this.setNextButton(e || null))\n                }\n            }\n\n            this.tabs.on(\"tab_changed\", (i, tab)=>{\n                this.stepIndex = i;\n                this.invoke(\"step_changed\", i, tab);\n                let isRequired = this.tabs.tabs[tab].attr(\"required\");\n                this.setCanContinue(!(isRequired&&!this.values[isRequired]));\n                let last = i == this.tabs.order.indexOf(this.stack.at(-1));\n                this.invoke(\"last_step_\" + (last? \"enter\" : \"leave\"))\n                if(this.opt.buttons){\n                    this.element.getAll(\".ls-steps-next[finish-text]\").all(e=> e.set(last? e.attr(\"finish-text\") || \"Done\" : \"Next\" ))\n                    S(this.element.getAll(\".ls-steps-previous\"), {opacity: i!=0?\"1\":\".4\" });\n                }\n            })\n\n            this.form.on(\"values_changed\",v=>{\n                this.values = v;\n            })\n            this.form.on(\"change\",(key,value,type,element,group)=>{\n                if(type !== \"radio\")return;\n                let rq = group.findParent(\"step\").attr(\"required\");\n\n                if(rq)_this.setCanContinue(!!_this.values[rq]);\n                _this.updateStack();\n            })\n        }\n        _init(){\n            this.reset();\n        }\n        getValues(){\n            return _this.form.get()\n        }\n        setCanContinue(v=!0){\n            if(this.opt.buttons)S(_this.opt.nextBtn,{opacity:v?\"1\":\".4\",\"pointer-events\":v?\"all\":\"none\"});\n        }\n        next(){\n            if(_this.step == this.stack.length-1) {\n                _this.invoke(\"done\",_this.form.get())\n            }\n\n            _this.updateStack()\n            if(_this.step<_this.stack.length-1) {\n                _this.tabs.setActive(_this.stack[(_this.step++)+1])\n            }\n        }\n        previous(){\n            _this.updateStack()\n            if(!_this.step<1) {\n                _this.tabs.setActive(_this.stack[(_this.step--)-1])\n            }\n        }\n        updateStack(){\n            _this.stack=[];\n            for(const tab of _this.tabs.order){\n                let e = _this.tabs.tabs[tab];\n                let pass=!(e.attr(\"if\")?e.attr(\"if\").split(\";\").map(c=>c.split(\"=\")).find(a=>_this.values[a[0]]==a[1]):!0);\n                _this.tabs.list[tab].style.display=pass?\"none\":\"\";\n                if(pass){continue}\n                _this.stack.push(tab)\n            }\n            _this.stack.forEach((e,i)=>{\n                e=_this.tabs.list[e];\n                e.class([\"last-child\",\"only-child\",\"first-child\"],0);\n                if(_this.stack.length<2){e.class(\"only-child\");return};\n                if(i==0)e.class(\"first-child\");\n                if(i==_this.stack.length-1)e.class(\"last-child\");\n            })\n        }\n        reset(){\n            _this.setCanContinue(!0);\n            _this.step=0;\n            _this.tabs.setActive(0,1);\n            _this.form.reset();\n            _this.updateStack()\n        }\n        setNextButton(element){\n            if(!element){\n                element = N(\"button\", {innerText: \"Next\", attr: {\"finish-text\": \"Done\"}});\n                _this.element.add(element)\n            }\n            element.class(\"ls-steps-next\")\n            element.on(\"click\", ()=>{\n                _this.next()\n            })\n        }\n        setBackButton(element){\n            if(!element){\n                element = N(\"button\", \"Previous\");\n                _this.element.add(element)\n            }\n            element.class(\"ls-steps-previous\")\n            element.on(\"click\", ()=>{\n                _this.previous()\n            })\n        }\n    }\n},"],"from":"ls-js/steps.js"},{"segment":"navbar","content":["Navbar(gl){\n    return(_this)=>class Navbar{\n        constructor(id,e){\n            if(!e)e=O(\"nav[ls]\");\n            if(!e.get)e=O(e);\n            e.attr(\"tabindex\",\"-1\");\n            e.getAll(\"group\").forEach(e=>e.attr(\"tabindex\",\"-1\"));\n            e.getAll(\"items\").forEach(i=>{\n                i.attr(\"itemgroup-id\",M.GlobalID)\n            })\n            e.getAll(\"nav>dropdown,nav>group>dropdown\").map(d=>{\n                let s=d.tagName;\n                d.onmouseenter=()=>{\n                    if(typeof d.attr(\"no-drop\")==\"string\")return;\n                    e.getAll(s).forEach(q=>q.classList.remove(\"active\"));\n                    d.classList.add(\"active\")\n                }\n            })\n        }\n    }\n},"],"from":"ls-js/navbar.js"},{"segment":"list","content":["List(gl){\n    return(_this)=>class List{\n        constructor(id,e,options={data:\" .\".repeat(20).split(\".\").filter(e=>e).map((e,i)=>i+1)}){\n            this.element=O(e);\n            _this=this;\n            this.data=options.data;\n            this.opt=Object.assign({\n                rowHeight: 20,\n                height: 200,\n                element: {\n                    class: \"ls-list-row\",\n                    attr: \"chv\"\n                }\n            },options);\n            this.elements=[];\n            this.element.style.height=this.opt.height+\"px\";\n            let container=N({class:\"ls-list-container\"}),\n                roll=N({class:\"ls-list-roller\"}),\n                fill=N({class:\"ls-list-fill\"});\n            this.view = [];\n            this.fill=fill;\n            this.roll=roll;\n            this.container=container;\n            this.updateSize(0);\n            this.fixElements();\n            this.element.class(\"ls-list\");\n            this.roll.add(container)\n            this.element.add(fill,roll);\n            let prev=0,prevfs=0;\n\n            this.buffer = 0;\n            async function handleShift(){\n                if(_this.buffer>1)return console.error(\"BUFFERED\");\n                if(_this.up){\n                    // _this.container.prepend(_this.elements.at(-1));\n                    // _this.elements.unshift(_this.elements.pop());\n                    // _this.elements[0].innerText=fs;\n                    _this.view.unshift(_this.view.pop());\n                    _this.view[0]=fs;\n                }else{\n                    // _this.container.add(_this.elements[0]);\n                    // _this.elements.push(_this.elements.shift());\n                    // _this.elements.at(-1).innerText=fs+1+_this.visibleElements;\n                    _this.view.push(_this.view.shift());\n                    _this.view[_this.view.length-1]=fs+3+_this.visibleElements;\n                }\n                // console.clear()\n                // _this.updateContent()\n                console.log(_this.view);\n                if(_this.buffer>0)_this.buffer--\n            }\n            this.element.on(\"scroll\",async e=>{\n                _this.buffer++\n                let fs=Math.floor(_this.element.scrollTop/_this.opt.rowHeight);\n                _this.up=_this.element.scrollTop<prev;\n\n                _this.container.style.transform=\"translateY(\"+((_this.element.scrollTop)-(_this.element.scrollTop%_this.opt.rowHeight)-(_this.opt.rowHeight*2))+\"px)\";\n                prev=_this.element.scrollTop;\n\n                _this.container.style.overflow=_this.element.scrollTop>=(_this.fullHeight-_this.opt.height)?\"hidden\":\"visible\"\n                console.log(_this.buffer);\n                if(fs!=prevfs)await handleShift();\n                prevfs=fs;\n            })\n            // handleScroll();\n            this.update();\n        }\n        updateContent(){\n            for(let i=0;i<this.drawAmount;i++){\n                //Update elements:\n                \n                this.elements[i].innerText=this.data[Math.round(this.element.scrollTop/this.opt.rowHeight)+i-1];\n            }\n        }\n        update(){\n            this.updateSize();\n            this.updateContent();\n        }\n        updateSize(updateElements=true){\n            this.fullHeight=this.data.length*this.opt.rowHeight;\n            this.visibleElements=Math.round(this.opt.height/this.opt.rowHeight);\n            this.drawAmount=this.visibleElements+4;\n            this.fill.style.height=(this.data.length*this.opt.rowHeight)+\"px\";\n            this.container.style.height=((this.drawAmount-2)*this.opt.rowHeight)+\"px\"\n            if(updateElements)this.fixElements();\n        }\n        fixElements(){\n            if(this.elements.length<this.drawAmount){\n                //Add elements if missing:\n                let n=this.drawAmount-this.elements.length;\n                for(let i=0;i<n;i++){\n                    this.elements.push(N({...this.opt.element}));\n                    this.view.push(i)\n                    this.container.add(this.elements.at(-1))\n                    console.log(\"element added\"+i)\n                }\n            }\n            if(this.elements.length>this.drawAmount){\n                //Remove elements if there is too much:\n                for(let i=0;i<this.elements.length-this.drawAmount;i++){\n                    this.elements.pop().remove();\n                    console.log(\"element removed\"+i)\n                }\n            }\n        }\n    }\n},"],"from":"ls-js/list.js"},{"segment":"select","content":["Select(gl){\n    customElements.define('ls-select', class extends HTMLElement {\n        constructor(){\n            super();\n        }\n        connectedCallback(){\n            if(this.hasAttribute(\"compatibility\"))return;\n            this.setAttribute(\"ls-not-ready\", \"\")\n            let isReady = false;\n            this.ready = () => {\n                if(isReady) return;\n                isReady = true;\n                this.ls = LS.Select(this.id || M.GlobalID, this)\n                this.delAttr(\"ls-not-ready\")\n            }\n            setTimeout(() => {\n                if(!isReady)console.warn(\"[ LS Note ] You are using the ls-select custom element. Due to browser limitations, you have to call .ready() on the element after your options are available!\")\n            }, 2000);\n        }\n    });\n    return(_this)=>class Select{ \n        constructor(id, e, values){\n            if(!e)e=O(\"select\");\n            if(!e)throw \"[ LS Error ] No element provided for the select component\";\n\n            e = O(e);\n\n            _this = this;\n            this.id = id;\n            this.options = []\n            this.value = null\n\n            let native = e.tagName==\"SELECT\";\n            this.element = native? N(\"ls-select\", {attr:[\"compatibility\"]}) : e;\n\n            this.element.attrAssign({tabindex: 2, title: e.attr(\"title\"), \"ls-h-scroll\": ''})\n\n            if(native){\n                // Backwards compatibility with <select>\n                e.style.display=\"none\";\n                e.addAfter(this.element)\n                e.on(\"change\",() => this.set(this.options.find(o=> o.value = e.value)));\n            }\n            this.menu = N({\n                class: \"ls-select-menu\",\n                inner: [\n                    N(\"input\", {\n                        placeholder: \"Search\",\n                        oninput(){\n                            _this.menu.getAll(\".ls-select-options > *\").forEach(e=>e.style.display=e.innerText.toLowerCase().replace(/[\\s\\n:|_]/g,'').includes(this.value.toLowerCase().replace(/[\\s\\n:|_]/g,''))?\"block\":\"none\")\n                        }\n                    }),\n                    \"<hr style=margin-top:0>\",\n                    N({class: \"ls-select-options\"})\n                ]\n            });\n\n            _this.menuContainer = _this.menu.get(\".ls-select-options\")\n            O().add(this.menu);\n\n            M.on(\"resize\",()=>{if(this.shown) this.position()})\n            M.on(\"scroll\",()=>{if(this.shown) this.position()}, !0)\n            this.shown=!1;\n            this.element\n                .on(\"mousedown\", () => this.toggle())\n                .on(\"keydown\", (e)=>{\n                    switch(e.keyCode){\n                        case 27: this.hide(); break\n                        case 13: this.toggle(); break\n                        case 40:case 9: this.show(); this.getOptions()[0].element.focus(); break\n                    }\n                });\n            addEventListener(\"mousedown\", (e)=>{\n                if(this.shown&&e.target!==this.element){\n                    let r=this.menu.getBoundingClientRect();\n                    if(!(M.x>r.left&&M.x<r.right&&M.y>r.top&&M.y<r.bottom))this.hide()\n                }\n            })\n            if(!values){\n                this.loadFromElements(native?e:this.element);\n                this.updateElements()\n            }else{\n                this.updateElements(values)\n            }\n            if(this.options.length > 0) this.set(this.getOptions()[0])\n        }\n        get(){\n            return _this.value\n        }\n        set(opt){\n            let option = typeof opt==\"object\"?opt: _this.options[opt];\n            if(!option)return new Error(opt+\" is an invalid option!\");\n            _this.value = option.value;\n            _this.element.setText(option.label || option.value);\n            if(opt.element)O(opt).attrAssign(\"selected\");\n\n            if(_this.invoke)_this.invoke(\"change\", option.value, option)\n            _this.hide()\n        }\n        updateElements(values){\n            if(values)_this.options=values;\n\n            let existing = _this.menuContainer.getAll();\n\n            let i = -1;\n            for(const opt of _this.options){\n                i++\n                if(typeof opt==\"string\"){\n                    let label = N(\"ls-label\", {attr: {title: opt}, innerText: opt});\n                    _this.menuContainer.add(label)\n                    _this.options[i] = {type: \"label\", element: label}\n                    continue\n                }\n                let \n                    existed = !!opt.element,\n                    optElement = opt.element || N(\"ls-option\");\n\n                if(!optElement.hasClass(\"rich\") && opt.type!==\"plain\")optElement.innerHTML = opt.label || opt.value;\n                optElement.class(\"indent\", opt.indent? 1:0)\n\n                if(opt.type == \"option\"){\n                    optElement.attrAssign({tabindex: \"1\"})\n                    optElement.onmouseup = ()=> _this.set(opt)\n                    optElement.onkeydown = (e)=>{\n                        if(e.keyCode==13)_this.set(opt)\n                    }\n                }\n\n                _this.options[i].element = optElement\n                _this.menuContainer.add(optElement)\n            }\n        }\n        getOptions(){\n            return _this.options.filter(o=>o.type==\"option\")\n        }\n        exportOptions(){\n            return _this.options.map(o=>{\n                return {type: o.type, label: o.label, value: o.value, indent: o.indent}\n            })\n        }\n        updateFromElements(){\n            //...\n        }\n        loadFromElements(source = _this.menuContainer){\n            _this.options = []\n            for(const opt of source.getAll()){\n                let parent = opt.parentElement.tagName;\n                if(!parent.includes(\"SELECT\") && !parent.includes(\"OPTGROUP\")) continue;\n                let option = \n                    opt.tagName.includes(\"OPTGROUP\")? opt.attr(\"label\"):\n                    opt.tagName.includes(\"OPTION\")?\n                    {\n                        type: \"option\",\n                        indent: !!(parent.includes(\"OPTGROUP\")?1:0),\n                        label: opt.innerHTML,\n                        value: opt.attr(\"value\") || opt.innerHTML\n                    }:\n                    {\n                        type: \"plain\",\n                        element: opt\n                    }\n                ;\n                if(opt.tagName==\"LS-OPTION\") option.element = opt;\n                this.options.push(option)\n            }\n            console.log(this.options);\n        }\n        toggle(){\n            _this[_this.shown?\"hide\":\"show\"]()\n        }\n        show(){\n            if(_this.shown)return;\n            _this.shown=!0;\n            _this.position();\n            _this.element.class(\"open\")\n        }\n        position(){\n            let r = _this.element.getBoundingClientRect();\n            _this.menu.style=`left:${r.left}px;width:${r.width}px;top:${r.top+r.height}px;max-height:${Math.min(innerHeight-(r.top+r.height+20),400)}px;display:block`;\n        }\n        hide(){\n            if(!_this.shown)return;\n            _this.shown=!1;\n            _this.menu.hide()\n            _this.element.focus()\n            _this.element.class(\"open\", 0)\n        }\n    }\n},"],"from":"ls-js/select.js"},{"segment":"debugger","content":["Debugger(gl){\n    return(_this)=>class Tooltips{\n        constructor(id,conf){\n            _this=this;\n            this.paused=0;\n            this.tickDelay=50;\n            setInterval(()=>{\n                if(this.paused)return;\n                this.invoke(\"tick\")\n            },this.tickDelay)\n        }\n        virtualElement(e,inherits=['borderRadius']){\n            let virtual=N({\n                style:{\n                    background: \"#4287ec45\",\n                    border:\"1px solid #505dfd\",\n                    position: \"fixed\",\n                    zIndex: 90000,\n                    pointerEvents: \"none\"\n                }\n            });\n            O().add(virtual)\n            _this.on(\"tick\",()=>{\n                let cs = S(e),\n                    rect = e.getBoundingClientRect()\n                S(virtual,{\n                    width:rect.width+\"px\",\n                    height:rect.height+\"px\",\n                    top:rect.top+\"px\",\n                    left:rect.left+\"px\",\n                })\n                for(const rule of inherits){\n                    virtual.style[rule]=cs[rule];\n                }\n            })\n        }\n    }\n},"],"from":"ls-js/debugger.js"},{"segment":"tooltips","content":["Tooltips(gl){\n    return(_this)=>class Tooltips{\n        constructor(id,conf){\n            this.element=N({class:\"ls-tootlip-layer\"});\n            this.contentElement=N({class:\"ls-tooltip-content\"});\n            this.element.add(this.contentElement);\n            O().add(this.element)\n            let selector=\"[ls-tootlip],[ui-tooltip],[tooltip]\";\n            setInterval(()=>{\n                Q(selector).filter(e=>!e._tt).forEach(e=>this.setup(e))\n            },400)\n        }\n        setup(e){\n            e._tt=!0;\n            e.on(\"mouseenter\",()=>{\n                this.element.class(\"shown\");\n                this.contentElement.set(e.attr(\"ls-tooltip\")||e.attr(\"ui-tooltip\")||e.attr(\"tooltip\"));\n            })\n            e.on(\"mousemove\",()=>{\n                let box=e.getBoundingClientRect(),cbox=this.contentElement.getBoundingClientRect();\n                this.contentElement.applyStyle({\n                    left:(\n                        Math.min(Math.max(box.left+(box.width/2)-(cbox.width/2),4),innerWidth-(cbox.width))\n                    )+\"px\",\n                    maxWidth:(innerWidth-8)+\"px\",\n                    top:\"calc(\"+(box.top-cbox.height)+\"px - var(--ui-tooltip-rise,5px))\"\n                })\n            })\n            e.on(\"mouseleave\",()=>{\n                this.element.class(\"shown\",0)\n            })\n        }\n    }\n},"],"from":"ls-js/tooltips.js"},{"segment":"chips","content":["Chips(gl){\n    return(_this)=>class Chips{\n        constructor(id,e=O(\"chips\"),options={}){\n            e=O(e);\n            this.options=Object.assign({},options)\n            if(!e)throw\"No element selected/found!\";\n            _this=this;\n            this.e=e;\n            this.id=id;\n            this.updateChips();\n            this.filter();\n        }\n        updateChips(){\n            _this.chips=_this.e.getAll(\"[ls-chip]\");\n            _this.chips.forEach(c=>c.onclick=function(){_this.chips.filter(a=>a!=this).forEach(e=>e.removeAttribute(\"selected\"));this.toggleAttribute(\"selected\");_this.filter()})\n        }\n        getSelected(){\n            return _this.chips.filter(e=>typeof e.attr(\"selected\")==\"string\").map(e=>e.attr(\"ls-chip\"))\n        }\n        filter(){\n            if(_this.getSelected().length<1)this.chips[0].attr(\"selected\",\"\");\n            Q(\"[ls-chip-filter*=\\\"\"+_this.id+\":\\\"]\").forEach(e=>{\n                e.style.display=_this.getSelected().find(s=>e.attr(\"ls-chip-filter\").match(/:(.*)/)[1].split(\",\").includes(s))?\"unset\":\"none\"\n            })\n        }\n    }\n},"],"from":"ls-js/chips.js"},{"segment":"tree","content":["Tree(gl){\n    return(_this)=>class Tree{\n        constructor(id,e,data,options={}){\n            _this=this;\n            this.options=Object.assign({\n                class:\"tree-view\"\n            },options);\n            if(!data&&data!==null){data=e;e=null};\n            this.data={};\n            this.data_array=[];\n            this.element=O(e);\n            this.element.class(\"ls-tree\");\n            this.element.add(N({class:\"ls-tree-container\"}))\n        }\n        getElement(path){\n            return O(_this.element.get(\"[path=\\\"\"+path+\"\\\"]\")||_this.element.get(\".ls-tree-container\"))\n        }\n        addPath(path){\n            return Object.assign(LS.Util.objectPath(_this.data,path.replace(/\\./g,'__dot__').replace(/\\//g,'.')),{\n                __items__:[]\n            })\n        }\n        changeTitle(path,title){\n\n        }\n        get(path){\n            return LS.Util.objectPath(_this.data,path.replace(/\\./g,'__dot__').replace(/\\//g,'.'))\n        }\n        expand(path,items,deleteOld=false){\n            if(!Array.isArray(items))throw\"LSTree: No items array provided for expanding! Use the expand event and return the array trough it.\";\n            let _path=path.replace(/\\/\\//g,''),list=[];\n            for(const d of items){\n                let isExpandable=typeof d!==\"object\"||d.expandable,\n                path=_path+\"/\"+(d.path||d.inner||d).replace(/\\//g,\"\\\\/\");\n                list.push(path);\n                if(_this.element.has(\"[path=\\\"\"+path+\"\\\"]\"))continue;\n                let o=_this.get(path);\n                if(!Array.isArray(o.__items__))o=_this.addPath(path);\n                o.__expandable__=isExpandable;\n                o.__title__=d.inner||d.path||d;\n                o.__path__=path;\n                o.__isOpen__=false;\n\n                // console.log(_this.data_array);\n                let e=_this.getElement(_path);\n                e[e.hasClass(\"ls-tree-container\")?\"add\":\"addAfter\"](N(\"div\",{\n                    inner:N(\"span\",{inner:o.__title__}),\n                    attr:{\n                        path:path,\n                        tabindex:\"0\"\n                    },\n                    style:\"--ls-tree-indent:\"+(path.split(\"/\").length-1),\n                    class:\"ls-tree-item\"+(isExpandable?\" ls-tree-expandable\":\"\"),\n                    onclick:function(){_this._interact.call(this,path,isExpandable)}\n                }))\n            }\n            if(deleteOld){\n                _this.delete(_this.element.getAll(\"[path]\").filter(e=>!list.includes(e.attr(\"path\"))).map(e=>e.attr(\"path\").slice(1)))\n            }\n            return !0\n        }\n        delete(path,items){\n            if(Array.isArray(path)){items=path;path=\"\"};\n            path=path.replace(/\\/\\//g,'');\n            for(const d of items){\n                let e=_this.element.get(\"[path=\\\"\"+path+\"/\"+d.replace(/\\//g,\"\\\\/\")+\"\\\"]\");\n                if(!e)continue;\n                e.remove();\n            }\n        }\n        assign(path,items){\n            _this.expand(path,items,true)\n        }\n        remove(path){\n            let e=path._affected?path:_this.getElement(path);\n        }\n        refresh(){\n\n        }\n        async _interact(path,isExpandable){\n            if(!this._affected)throw\"Please do not call this directly!\";\n            let data=(await _this.invoke(\"data\",path,isExpandable)).flat();\n            if(isExpandable){\n                let refresh=(await _this.invoke(\"refresh\",path))[0]===true;\n                this.class(\"open\",2);\n                let isOpen=this.hasClass(\"open\");\n                if(this.hasAttribute(\"explored\")){\n                    S(_this.element.getAll(\"[path*=\\\"\"+path+\"/\\\"]\"),{display:isOpen?\"\":\"none\"})\n                    _this.get(path).__isOpen__=isOpen;\n                    _this.invoke(\"open\",path,isOpen)\n                    if(!refresh)return\n                }\n                this.attrAssign(\"explored\")\n                _this.expand(this.attr(\"path\"),data);\n            }\n        }\n    }\n},"],"from":"ls-js/tree.js"},{"segment":"menubar","content":["Menubar(gl){\n    return(_this)=>class Menubar{\n        constructor(id,e=O(\"menubar\"),options={}){\n            if(!e)throw\"No element found for menubar.\";\n            this.element=O(e);\n\n        }\n    }\n},"],"from":"ls-js/menubar.js"},{"segment":"present","content":["Present(gl){\n    gl.set(\"version\",2);\n    gl.conf.requires=[\"Steps\"];\n    return(_this)=>class PresentationView{\n        constructor(id,e=O(\"present\"),options={}){\n            if(!e)throw\"No element found for the presentation.\";\n            this.opt=Object.assign({resolution:[1280,720],select:\"slide\"},options);\n            e.class(\"ls-present-container\");\n            this.element=O(e).wrapIn(N({class:\"ls-present-body\"}));\n            _this=this;\n            if(this.opt.frameOnly){\n                //...\n            }else{\n                this.steps=LS.Steps(\"presentation_steps_\"+id,this.element,{listItemClass:\"ls-present-bar\",tabOptions:{hide:!1},select:options.select,buttons:0})\n            }\n            S(this.element,{width:this.opt.resolution[0]+\"px\",height:this.opt.resolution[1]+\"px\"});\n            this.fixResolution();\n            M.on(\"resize\",this.fixResolution);\n            (this.opt.fullscreen?O():e).on(\"keydown\",\"wheel\",this.handleEvent)\n            e.on(\"click\",this.handleEvent)\n        }\n\n        handleEvent(e){\n            if(_this.opt.ignoreEvents||(_this.lastTimer&&(Date.now()-_this.lastTimer)<((+_this.slideElement().attr(\"min-time\"))||500)))return;\n            _this.lastTimer=Date.now();\n            if(\n                (e.type==\"wheel\"&&e.deltaY<=0)||\n                (e.type==\"keydown\"&&[\"ArrowLeft\",\"ArrowUp\"].includes(e.key))\n            ){\n                _this.navigate(-1,false,true);\n                return\n            }\n            _this.navigate(1,false,true);\n        }\n        slideElement(id=null){\n            return _this.steps.tabs.list[_this.steps.tabs.order[id||_this.steps.stepIndex]]\n        }\n        fixResolution(){\n            let e=_this.element,\n            scale = Math.min(\n                (_this.opt.vpWidth?.()||window.innerWidth) / _this.opt.resolution[0],    \n                (_this.opt.vpHeight?.()||window.innerHeight) / _this.opt.resolution[1]\n            );\n            _this.scale=scale\n            e.style.transform=`translate(-50%,-50%) scale(${scale})`;\n        }\n        navigate(direction,jump=false,key=false){\n            if(!jump&&direction==0)return;\n            if(!jump&&typeof direction==\"string\")_this.steps.tabs.order.indexOf(direction);\n            let e=_this.slideElement();\n            \n            let stages=(e.attr(\"stages\")||\"\").split(\";\").map(_o=>{\n                let o={};\n                for(let e of _o.split(\",\")){\n                    if(e.length<1)continue;\n                    e=e.split(\":\");\n                    o[e[0]]=e[1];\n                }\n                return Object.keys(o).length<1?null:o\n            }).filter(c=>c),hold=false;\n\n            if(stages.length>0&&!jump){\n                let c=e.attr(\"stage\");\n                c=+(c||0);\n                console.log(c,stages.length,stages,direction);\n                if(\n                    direction>0?\n                        c!=stages.length\n                    :\n                        c>0\n                ){\n                    console.warn(\"asassa\");\n                    e.attrAssign({stage:c+direction})\n                    hold=true\n                }\n            }\n            if(!hold){\n                if(direction==1&&key&&e.hasAttr(\"no-action\"))return;\n                if(jump){\n                    Pr.steps.tabs.setActive(direction);\n                }else{\n                    _this.steps[direction>0?\"next\":\"previous\"]();\n                }\n            }else{\n                _this.invoke(\"stage\",_this.steps.stepIndex,direction,jump);\n            }\n            _this.invoke(\"change\",_this.steps.stepIndex,_this.steps.tabs.tabs.length,direction,jump);\n        }\n        next(){\n            _this.navigate(1)\n        }\n        slide(n=0){\n            _this.navigate(n,true)\n        }\n        back(){\n            _this.navigate(-1)\n        }\n        fullscreen(){\n            O().requestFullscreen()\n        }\n    }\n},"],"from":"ls-js/present.js"},{"segment":"notif","content":["Notif(gl){\n    return(_this)=>class Notif{\n        constructor(id,opt={}){\n            this.el=N({class:\"ls-notif-area\",style:`width:${opt.width||300}px`,inner:[N({class:\"ls-notif-scroll\",inner:N({class:\"ls-notif-container\"})}),N({class:\"ls-notif-hide\",inner:\"<i class=bi-caret-down-fill></i>\",onclick:()=>{_this.el.classList.toggle(\"hidden\")}})]})\n            O().add(this.el)\n            _this=this;\n        }\n        push(c){\n            return new Promise(r=>{\n                if(typeof c==\"string\")c={content:c};\n                c=Object.assign({},c);\n                let e=N({class:\"ls-notif\",inner:[(c.title?N(\"b\",c.title+\"<br>\"):\"\"),c.content],style:\"color:var(--color-bg)\",attr:[c.color?\"ls-\"+c.color:\"\"]});\n                _this.el.get(\".ls-notif-container\").add(e);\n                let sc=setInterval(()=>_this.el.get(\".ls-notif-scroll\").scroll(0,_this.el.get(\".ls-notif-scroll\").scrollHeight),1);\n                setTimeout(()=>{e.classList.add(\"shown\");setTimeout(()=>{clearInterval(sc);r()},200)},10);\n            })\n        }\n        revoke(){\n\n        }\n    }\n},"],"from":"ls-js/notif.js"},{"segment":"nanoreact","content":["NanoReact(gl){\n    gl.Group=function(obj){}\n    return(_this)=>class Reactor{\n        constructor(id){\n            _this=this;\n            this.id=id;\n            this.list={};\n        }\n        apply(s){\n            Q(`[ls-react=\"${_this.id};${s}\"]`).all(e=>{\n                e.innerText = _this.list[s]\n            })\n        }\n        NewGlobal(name,initial){\n            _this.Register(window,name,initial)\n        }\n        RegisterNew(scope=window,init=null){\n            for(const e of Q(`[ls-react^=\"${_this.id};\"]`)){\n                let a=(e.attr(\"ls-react\")).split(\";\").at(-1);\n                if(a in _this.list)return;\n                _this.Register(scope,a,scope[a]||init)\n            }\n        }\n        RegisterBatch(scope=window,batch,init){\n            for(const a of batch){\n                if(a in _this.list)return;\n                _this.Register(scope,a,scope[a]||init)\n            }\n        }\n        Register(scope,name,initial=null){\n            let listName=name;\n            _this.list[listName]=initial;\n            Object.defineProperty(scope,name,{\n                get() {\n                    return _this.list[listName];\n                },\n                set(value) {\n                    _this.list[listName] = value;\n                    _this.apply(name);\n                }\n            });\n            _this.apply(name);\n        }\n    }\n},"],"from":"ls-js/react.js"},{"segment":"resize","content":["Resize(gl){\n    let directions = [\"top\",\"bottom\",\"left\",\"right\"];\n    let cursor = [\"ns-resize\",\"ns-resize\",\"ew-resize\",\"ew-resize\"];\n    let values = [\"height\",\"height\",\"width\",\"width\"];\n    return(_this)=>class Console{\n        constructor(id, element, sides=[1,1,1,1]){\n            _this=this;\n            this.sides=sides;\n            this.values=[0,0,0,0];\n            this.element=O(element);\n            this.update();\n        }\n        update(sides=this.sides){\n            _this.sides=Array.isArray(sides)? sides.length < 4 ? [...sides, ...Array(4 - sides.length).fill(0)] : sides.slice(0, 4) : [1,1,1,1];\n            sides=_this.sides;\n            for(const [i,s] of sides.entries()){\n                if(i>3)break;\n                this[s?\"addHandle\":\"removeHandle\"](i)\n            }\n        }\n        addHandle(side){\n            let direction = directions[side];\n            if((side>4||side<0)||_this.element.has(\".ls-resize-bar-\"+direction))return;\n            let handle=N({\n                class: \"ls-resize-bar ls-resize-bar-\"+direction\n            });\n            function move(event) {\n                _this.invoke(\"resize\",direction)\n                _this.values[side]=((side==0?innerHeight-event.clientY:side==1?event.clientY:side==2?innerWidth-event.clientX:event.clientX))\n                _this.element.style[values[side]]=_this.values[side]+\"px\"\n            }\n            function release() {\n                _this.seeking=false;\n                D().documentElement.class(\"ls-dragging\",0)\n                D().removeEventListener(\"mousemove\", move);\n                D().removeEventListener(\"mouseup\", release);\n                D().removeEventListener(\"touchmove\", move);\n                D().removeEventListener(\"touchend\", release);\n                D().documentElement.style.cursor=\"\";\n                _this.invoke(\"resizeend\",direction)\n            }\n            handle.on(\"mousedown\",\"touchstart\",(e)=>{\n                if(e.target!==handle)return;\n                _this.seeking=true;\n                D().documentElement.class(\"ls-dragging\")\n                D().addEventListener(\"mousemove\", move);\n                D().addEventListener(\"mouseup\", release);\n                D().addEventListener(\"touchmove\", move);\n                D().addEventListener(\"touchend\", release);\n                D().documentElement.style.cursor=cursor[side];\n                _this.invoke(\"resizestart\",direction)\n            })\n            _this.element.add(handle)\n        }\n        removeHandle(side){\n            let direction = directions[side];\n            if((side>4||side<0)||!_this.element.has(\".ls-resize-bar-\"+direction))return;\n            _this.element.get(\".ls-resize-bar-\"+direction).remove();\n        }\n    }\n},"],"from":"ls-js/resize.js"},{"segment":"toolbox","content":["ToolBox(gl){\n    if(!LS.isWeb)return;\n    gl.conf={\n        batch:!1,\n        singular:!0,\n        requires:[\"Resize\"]\n    }\n    return(_this)=>class Console{\n        constructor(options={}){\n            M.StyleComponent(\"toolbox\", \"resize\")\n            _this=this;\n            this.isOpen=false;\n            this.config={};\n            this.bash={env:{PATH:\"/bin\",EDITOR:\"/bin/nano\"},pwd:\"/\",shell:0,ws:\"local\"};\n            this.localFS={\n                bin:{\n                    ls(...args){\n                        let path = args[1]||_this.bash.pwd, dir = _this.fsGet(path);\n                        if(!dir)return _this.error(\"No such file or directory (\\\"\"+path+\"\\\")\")\n                        if(!dir.dir)return _this.error(\"\\\"\"+path+\"\\\" is a file\")\n                        _this.log(Object.keys(dir.value).map(e=>typeof dir.value[e]!=\"object\"?`%{#35b1fb}${e}%{#fff}`:e).join(\"\\n\"))\n                        this.exit()\n                    },\n                    pwd(){\n                        _this.log(_this.bash.pwd)\n                        this.exit()\n                    },\n                    cd(f, path = \"\"){\n                        let dir = _this.fsGet(path);\n                        if(!dir||!dir.dir)return _this.error(\"\\\"\"+path+\"\\\" either doesnt exist or is not a directory\")\n                        _this.bash.pwd=path\n                        this.exit()\n                    },\n                    clear(){\n                        _this.lines.clear()\n                        this.exit()\n                    },\n                    mkdir(f, path){\n                        _this.fsGet(path, false);\n                        this.exit()\n                    },\n                    touch(f, path){\n                        this.exit()\n                    },\n                    env(){\n                        _this.log(Object.keys(_this.bash.env).map(e=>`${e}=${_this.bash.env[e]}`).join(\"\\n\"))\n                        this.exit()\n                    },\n                    export(f, e){\n                        e = e.split(\"=\")\n                        let name = e[0];\n                        e.shift()\n                        _this.bash.env[name]=e.join(\"=\")\n                        this.exit()\n                    },\n                    echo(f, ...v){\n                        _this.log(v.join(\" \"))\n                        this.exit()\n                    },\n                    make(f, file){\n                        this.exit()\n                    },\n                    nano(f, file){\n                        let filename=\"asd.txt\";\n                        function draw(){\n                            let helpSpacing = \" \".repeat(Math.max(0,(_this.lines.cols/2)-16));\n                            _this.exec(`clear && echo \"%{#000,#fff}  Text Editor  ${\" \".repeat((_this.lines.cols/2)-15)}${filename}${\" \".repeat(((_this.lines.cols/2)-(filename.length)))}%{/}\n%{![${_this.lines.cols},${_this.lines.rows-3}]editor-text}%{/}\n%{#000,#fff}^S%{/} Save${helpSpacing}%{#000,#fff}^Z%{/} Undo${helpSpacing}%{#000,#fff}^C%{/} Copy\n%{#000,#fff}^X%{/} Exit${helpSpacing}%{#000,#fff}^Y%{/} Redo${helpSpacing}%{#000,#fff}^V%{/} Paste\n\"`)\n                            _this.lines.once(\"resize\",draw)\n                        }\n                        draw();\n                    },\n                    async desktop(f, name){\n                        let de;\n                        function launch(){\n                            de\n                        }\n                        let list=[\n                            {id:\"LiDE 0.12.1\",dir:\"lide\",cdn:\"@lide?\"+Math.random()},\n                            {id:\"Gnome Lite\",dir:\"gnome-lite\",cdn:\"@gnome-lite\"}\n                        ],\n                        target = list.find(d=>d.id.toLowerCase().includes(name.toLowerCase())), bin;\n                        if(!target){\n                            _this.error(\"Desktop environment \\\"\"+name+\"\\\" not found.\")\n                            return this.exit()\n                        }\n                        de = _this.fsGet(\"/env/\"+target.dir)\n                        if(de){\n                            launch();\n                            return this.exit()\n                        }\n                        _this.lines.warn(\"Desktop environment \\\"\"+name+\"\\\" not installed, downloading\")\n                        _this.log(\"Preparing to download \"+target.id+\" to /env/\"+target.dir)\n                        fetch(LS.CDN+\"/file/\"+target.cdn)\n                            .then(async r=>{\n                                _this.log(\"Checking...\")\n                                bin = await r.json()\n                                if(bin.success===false){\n                                    _this.error(bin.error)\n                                }else{\n                                    _this.fsGet(\"/env/\"+target.dir,false,bin)\n                                    _this.log(\"All done! Launching.\")\n                                    de = _this.fsGet(\"/env/\"+target.dir)\n                                    launch()\n                                }\n                                this.exit()\n                            })\n                            .catch(e=>{\n                                _this.error(e.toString())\n                                this.exit()\n                            })\n                    }\n                }\n            }\n            this.fs=\"local\"\n            this.container = N(\"div\",{class:\"ls-debug-console\",inner:N(\"iframe\")}).addTo(O())\n            this.element = this.container.get(\"iframe\")\n            this.win = this.element.contentWindow\n            this.doc = this.element.contentDocument || this.win.document\n            LS.Resize(\"ls_console\",this.container,[1]).on(\"resizeend\",()=>{\n                this.updateConfig(\"height\",LS.Resize(\"ls_console\").values[0])\n            })\n        }\n        _init(){\n            this.load()\n        }\n        updateConfig(k,v){\n            if(k)_this.config[k]=v;\n            localStorage.lsDebugConsole=JSON.stringify(_this.config)\n        }\n        loadConfig(){\n            if(localStorage.lsDebugConsole){\n                _this.config=JSON.parse(localStorage.lsDebugConsole)\n            }\n            _this.container.style.height=_this.config.height+\"px\"\n            if(LS._debugToolBoxShow){\n                _this.open()\n                LS._debugToolBoxShow = false\n            }else{\n                _this[_this.config.open?\"open\":\"close\"]()\n            }\n            if(_this.win.loadConfig)_this.win.loadConfig()\n        }\n        load(){\n            _this.loadConfig()\n            _this.win.location.reload()\n            _this.win[\"_this\"]=_this;\n            _this.doc.open();\n            _this.doc.close();\n            _this.doc.querySelector(\"head\").appendChild(N(\"link\",{rel:\"stylesheet\",href:LS.CDN+\"/ls/css/0/Base,ls-sharp,toolbox-frame,tabs,present,progress\"}))\n            _this.doc.querySelector(\"head\").appendChild(N(\"link\",{rel:\"stylesheet\",href:\"https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.min.css\"}))\n            _this.doc.querySelector(\"head\").appendChild(N(\"script\",{src:LS.CDN+\"/ls/js/0/tiny,tabs,Terminal,AccentManager,Steps,Present,Progress,Form\",onload(){\n                _this.win.O().add(N(\"script\",`\n                    LS.Tabs('main')\n                    let lines = LS.Terminal(\"lines\", O(\".lines\"))\n                    _this.lines=lines\n                    _this.log=lines.log\n                    _this.print=lines.print\n                    _this.error=lines.error\n                    function loadConfig(){\n                        LS.AccentManager.setGlobal(_this.config.accent||\"blue\")\n                    }\n                    loadConfig()\n                    O(\".lines\").click();\n                    LS.Present(\"desktop\",O('#desktop'),{fullscreen:true,ignoreEvents:true})\n                `))\n                _this.log(\"[ %{red}Welcome%{/} ]\\n %{cyan}*%{/} List default commands with \\\"%{cyan}ls /bin%{/}\\\" or all commands \\\"%{cyan}ls -l : $PATH%{/}\\\"\\n %{cyan}*%{/} Access JS with \\\"%{cyan}js%{/}\\\" or \\\"%{cyan}eval ...%{/}\\\"\\n %{cyan}*%{/} Connect to a remote workspace: \\\"%{cyan}remote name@host%{/}\\\" (exclude host to use default server)\\n %{cyan}*%{/} You can edit files with nano, set variables including PATH etc. same way as in UNIX.\\n\\nFor more examples and tutorials, run \\\"%{cyan}man%{/}\\\".\\n\")\n                _this.win.O().add(N(\"style\",`\n                    :root{--color:#fff;--font:Montserrat,Rubik,sans}\n                    body{overflow:hidden;height:100vh}\n                    .ls-console{position:absolute;bottom:0;left:0;right:0;top:33px;padding:10px;width:calc(100% - 20px);height:unset;--font:\"JetBrains Mono\",monospace}\n                    .ls-console-timestamp{display:none}\n                    tab>div{height:calc(100% - 34px);overflow:auto}\n                    .setup img{width:130px;border-radius:8px;margin-bottom:10px;pointer-events:none}\n                    .setup-de>div{text-align:center;cursor:pointer;padding:10px;border-radius:10px;user-select:none}\n                    .setup-de>div:hover{background:#ffffff05}\n                    .setup-de>div:active{background:#0004}\n                    div .ls-present-body{display:none}\n                `))\n                _this.win.O().attrAssign([\"ls\",\"ls-sharp\"])\n                _this.exec(\"init\")\n                _this.lines.on(\"newline\",(i, v)=>{\n                    if(i == \"bash-command\"){\n                        _this.proccess(v)\n                    }\n                })\n            }}))\n            _this.doc.body.append(N(\"tabs\",{\n                inner:[\n                    N(\"tab\",{\n                        attr: {\"tab-title\":\"<i class=bi-terminal-fill></i> Terminal\"},\n                        inner: [N({class:\"lines\"})]\n                    }),\n                    N(\"tab\",{\n                        attr: {\"tab-title\":\"<i class=bi-wrench></i> Config\"},\n                        inner: []\n                    }),\n                    N(\"tab\",{\n                        attr: {\"tab-title\":\"<i class=bi-display></i> Desktop\"},\n                        inner: [N({\n                            attr: \"chv\",\n                            inner: \"<div class=setup ct><div ls-box ls-yellow><i class=bi-exclamation-triangle-fill></i> You do not have an available desktop yet.</div><br><h3 style=font-weight:100>Choose your desktop</h3><br><div style=gap:10px ch class=setup-de><div onclick=\\\"LS.Tabs('main').setActive(0);_this.exec('desktop lide',true)\\\"><img src=https://cdn.extragon.cloud/file/820d268e7d9c435a8fab082ff82c316d.svg><br>LiDE</div><div onclick=\\\"LS.Tabs('main').setActive(0);_this.exec('desktop gnome',true)\\\"><img src=https://cdn.extragon.cloud/file/275005127b56c088e7b7179e7695c194.svg><br>Gnome Lite</div></div></div><div id=desktop></div>\"\n                        })]\n                    })\n                ]\n            }))\n        }\n        open(){\n            if(_this.isOpen)return;\n            _this.isOpen=true\n            _this.container.class(\"open\")\n            _this.invoke(\"open\")\n            _this.updateConfig(\"open\",true)\n        }\n        close(){\n            if(!_this.isOpen)return;\n            _this.isOpen=false\n            _this.container.class(\"open\",0)\n            _this.invoke(\"closed\")\n            _this.updateConfig(\"open\",false)\n        }\n        toggle(){\n            _this[_this.isOpen?\"close\":\"open\"]()\n            return _this.isOpen\n        }\n        fsGet(path=\"/\", strict = true, sv = null){\n            if(path.endsWith(\"/\"))path=path.slice(0,-1)\n            let t = LS.Util.objectPath(_this.fs==\"local\"? _this.localFS : this.fs, path, sv, \"/\", strict)\n            return t?{dir: typeof t==\"object\"?1:0, value: t}:null\n        }\n        proccess(d){\n            switch(_this.bash.shell){\n                case 0:\n                    _this.exec(d, true)\n                break;\n                default:\n                    _this.handler\n            }\n        }\n        async exec(cmd, isShell){\n            if(cmd!=\"init\"){\n                //First, parse strings\n                let strings = [], inside=false, prev=\"\", str = \"\", result = \"\";\n                for(let char of cmd){\n                    if(char=='\"'&&prev!=\"\\\\\"){\n                        inside=!inside;\n                    }\n                    if(inside){\n                        if(char!='\"'||prev==\"\\\\\")str+=char\n                    }else if(str){\n                        strings.push(str)\n                        str=\"\"\n                        result += \"%{@}\"\n                    }else if(char!='\"'||prev==\"\\\\\"){\n                        result += char\n                    }\n                    prev=char\n                }\n                strings=strings.map(s=>s.replaceAll(\"\\\\\\\"\",\"\\\"\"))\n                cmd=result.replace(/#.*$/gm, '').split(\"&&\").map(c=>c.split(\" \").filter(g=>g)).filter(g=>g);\n                for(let c of cmd){\n                    c=c.map(s=>{\n                        if(s==\"%{@}\"){\n                            return strings.shift()\n                        }\n                        return s\n                    })\n                    let found=0\n                    for(let p of _this.bash.env.PATH.split(\":\")){\n                        let dir = _this.fsGet(p)\n                        if(!dir||!dir.dir)continue;\n                        if(Object.keys(dir.value).includes(c[0])&&typeof dir.value[c[0]]==\"function\"){\n                            try{\n                                await new Promise((r,j)=>{\n                                    _this.lines.once(\"ctrlc\",r)\n                                    dir.value[c[0]].call({\n                                        get exit(){return ()=>r(0)},\n                                        set exit(v){r(v)}\n                                    },...c)\n                                })\n                            }catch(e){_this.error(e.toString())}\n                            found=1\n                        }\n                    }\n                    if(!found){_this.error(c[0]+\" not found\");break}\n                }\n            }\n            if(isShell||cmd==\"init\")_this.log(`%{lime}[${_this.bash.ws} ${_this.bash.pwd}]#%{/} %{![*,1]bash-command}`)\n        }\n    }\n},"],"from":"ls-js/toolbox.js"},{"segment":"terminal","content":["Terminal(gl){\n    return(_this)=>class Console{\n        constructor(id,e=O(\"console\"),options={}){\n            if(!e)throw\"No element found for Terminal.\";\n            _this=this;\n            this.element=O(e);\n            this.input=N(\"textarea\",{style:\"opacity:0;position:fixed;bottom:0\",class:\"ls-console-inputarea\"});\n            this.input.on(\"focus\",\"blur\",(e)=>{this.element.class(\"focus\",e.type==\"focus\")})\n            this.cursor=N({class:\"ls-console-cursor\"});\n            this.container=N({class:\"ls-console-line-container\"});\n            let input;\n            Object.defineProperty(this, \"activeInput\", {\n                get(){\n                    return input\n                },\n                set(v){\n                    input = v\n                    this.inputPrev = \"\"\n                    this.input.value = this.data[v] || \"\"\n                    this.updateCursor()\n                    this.input.dispatchEvent(new Event('input'))\n                }\n            })\n            Object.defineProperty(this, \"em\", {\n                get(){\n                    return parseFloat(getComputedStyle(_this.container).fontSize)\n                }\n            })\n            Object.defineProperty(this, \"rows\", {\n                get(){\n                    return Math.round(_this.container.clientHeight/(1.32*_this.em))\n                }\n            })\n            Object.defineProperty(this, \"cols\", {\n                get(){\n                    return Math.round(_this.container.clientWidth/(_this.em*.6))\n                }\n            })\n            this.input.on(\"keypress\",\"input\",\"keydown\",\"keyup\",(event)=>{\n                if(event.type==\"keydown\"){\n                    if (event.ctrlKey && (event.key === 'c' || event.key === 'x' || event.key === 'v')) {\n                        _this.invoke(\"ctrl\"+event.key)\n                        event.preventDefault();\n                    }\n                    if (event.ctrlKey && event.shiftKey) {\n                        if (event.key === 'C') {\n                            document.execCommand('copy');\n                        } else if (event.key === 'V') {\n                            document.execCommand('paste');\n                        } else if (event.key === 'X') {\n                            document.execCommand('cut');\n                        }\n                    }            \n                }\n                this.updateCursor()\n            })\n            this.input.on(\"input\",()=>{\n                if(this.activeInput&&this.element.has(\"#i_\"+this.activeInput)){\n                    let lines = this.input.value.split(\"\\n\"), element = this.element.get(\"#i_\"+this.activeInput+\" .text\");\n                    if(lines.length>this.inputPrev.split(\"\\n\").length)this.invoke(\"newline\",this.activeInput,this.inputPrev)\n                    if(\n                        (this.inputSize[0]!=\"*\"&&lines[0].length>+this.inputSize[0]) ||\n                        (this.inputSize[1]!=\"*\"&&lines.length>+this.inputSize[1])\n                    ){\n                        this.input.value=this.inputPrev\n                        return\n                    }\n                    this.data[this.activeInput]=this.input.value\n                    element.set(this.input.value)\n                    if(this.inputSize[1]!==\"*\"){\n                        for(let i=0;i<Math.max((+this.inputSize[1])-lines.length,0);i++){\n                            element.add(N(\"br\"))\n                        }\n                    }\n                    this.invoke(\"input\",this.activeInput,this.input.value)\n                    this.inputPrev=this.input.value\n                }\n            })\n            this.element.add(this.input, this.cursor, this.container).class(\"ls-console\")\n            ;(new ResizeObserver(e => {\n                this.updateSize()\n            })).observe(_this.container);\n            this.element.on(\"mousedown\",\"keydown\",()=>this.input.focus())\n            this.lines=0;\n            this.inputPrev=\"\";\n            this.data={}\n            this.opt=Object.assign({proxy:!1,style:!0,overwrite:!1,highlightJS:!0,scroll:!0,max_lines:350},options)\n            if(this.opt.overwrite){this._console=Object.assign(console,this.__proto__);console=this};\n        }\n        addLine(opt,...lines){\n            if(_this.lines>=_this.opt.max_lines){_this.container.child().remove();_this.lines--;};\n\n            let ts = \"\";\n\n            opt=Object.assign({proxy:\"log\",nl:1},opt);\n            if(_this.opt.proxy)_this._console[opt.proxy](...lines);\n\n            //Parse type\n            lines=lines.map(v=>typeof v==\"object\"?JSON.stringify(v,null,4):typeof v==\"function\"?\"<i>%{#aaa}\"+v.toString()+\"%{/}</i>\":typeof v==\"number\"?\"%{#35f}\"+v+\"%{/}\":typeof v==\"boolean\"?(\"%{#a5f}\"+(v?\"true\":\"false\")+\"%{/}\"):v)\n            \n            //Parse styling\n            let styles=0, input = 0;\n            for(const [i,line] of lines.entries()){\n                lines[i]=line.split(\"%{\").map(c=>{\n                    let i=c.indexOf(\"}\");\n                    if(i!=-1){\n                        let s=c.split(\"}\")[0];\n                        if(s==\"/\"){\n                            return (styles>0?(styles--)+1&&\"</span>\":\"\")+c.substring(i+1)\n                        }\n                        if(s.startsWith(\"!\")){\n                            let id=s.split(\"!\")[1] || M.GlobalID, size = [\"*\",\"*\"]\n                            if(id.startsWith(\"[\")&&id.includes(\"]\")){\n                                size=(id.split(\"]\")[0].slice(1)).split(\",\")\n                                id=id.split(\"]\")[1]\n                            }\n                            let existing = this.element.get(\"#i_\"+id);\n                            if(existing){\n                                existing.id=\"\"\n                            }\n                            _this.data[id] = \"\";\n                            _this.inputSize = size;\n                            input = id;\n                            return `<span class=\"ls-console-inputfield\" id=\"i_${id}\"><span class=text></span></span>`\n                        }\n                        styles++;\n                        return\"<span style=\\\"\"+s.split(\";\").map(s=>{\n                            if(!s.includes(\":\")){return s.split(\",\").map((v,i)=>`${[\"color\",\"background\",\"outline\",\"font-style\",\"font-weight\",\"text-decoration\",\"cursor\"][i]||\"color\"}:${v||\"unset\"}`).join(\";\")}else{return s}\n                        }).join(\";\")+\"\\\">\"+c.substring(i+1)\n                    }\n                    return c;\n                }).join(\"\")\n            }\n\n            //Add icon\n            ts=(opt.proxy!==\"log\"?` <i class=bi-${{error:'x-circle-fill',info:'info-circle-fill',warn:'exclamation-triangle-fill',success:'check-circle-fill'}[opt.proxy]||\"\"}></i> `:\"\")+ts;\n            \n            let date=new Date;\n            let result=N(\"span\",{\n                inner: `<span style=color:${opt.color||_this.opt.color||'inherit'}>${ts}${lines.join(opt.nl?\"\\n\":\"\")}${opt.nl?\"\\n\":\"\"}`+(\"</span>\".repeat(styles+1)),\n                title: `${date.getMonth()+1}.${date.getDate()}.${date.getFullYear()} ${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}`\n            });\n\n            _this.container.add(result)\n            _this.invoke(\"line\",result.textContent)\n            if(_this.opt.scroll)_this.element.scroll(0,_this.element.scrollHeight+5000);\n            _this.lines++;\n            if(input)_this.activeInput=input;\n        }\n        updateCursor(){\n            if(_this.activeInput&&_this.element.has(\"#i_\"+_this.activeInput)){\n                _this.element.get(\"#i_\"+_this.activeInput)\n                _this.cursor.show();\n                _this.cursor.addTo(_this.element.get(\"#i_\"+_this.activeInput))\n\n                let start = _this.input.selectionStart,\n                    end = _this.input.selectionEnd,\n                    lbc = _this.input.value.substring(0, start).split('\\n'),\n                    direction = _this.input.selectionDirection == \"forward\",\n                    row = lbc.length,\n                    column = lbc[lbc.length - 1].length + 1\n                ;\n\n                _this.cursor.style=`top:${(row-1)*1.32}em;left:${(column-1)*.6}em;width:${.6*Math.abs(direction?end-start:start-end)+.6}em`\n                return\n            }\n            _this.cursor.hide();\n        }\n        updateSize(){\n            _this.invoke(\"resize\",_this.rows,_this.cols)\n        }\n        write(...t){_this.addLine({nl:0},...t)}\n        print(...t){_this.write(...t)}\n        log(...t){_this.addLine({},...t)}\n        clear(){_this.container.clear();_this.lines=0;if(_this.opt.proxy)_this._console.clear();_this.invoke(\"clear\")}\n        get(){}\n        error(...t){_this.addLine({proxy:\"error\",color:\"#f55\"},...t)}\n        warn(...t){_this.addLine({proxy:\"warn\",color:\"#fb2\"},...t)}\n        success(...t){_this.addLine({proxy:\"success\",color:\"#5f5\"},...t)}\n        info(...t){_this.addLine({proxy:\"info\",color:\"#5ff\"},...t)}\n    }\n},"],"from":"ls-js/terminal.js"},{"segment":"editor","content":["Editor(gl){\n    console.warn('","","')\n\n    gl.set(\"themes\",{\n        base:{\n            textarea:\"all:revert;position:absolute;inset:0;outline:none;background:#0000;color:#0000;resize:none;border:none\"\n        },\n        light:{\n            body:\"background:#fff;color:#000;wo:0\"\n        },\n        dark:{\n            include:\"base\",\n            body:\"background:#232a2f;color:#eee\"\n        },\n    });\n    return(_this)=>class Editor{\n        constructor(id,e,opt){\n            this.opt=Object.assign({indent:\"    \"},opt);\n            this.element=O(e||N(\"editor\"));\n            S(this.element,{\n                position:\"relative\",\n                width:this.element.attr(\"width\")||\"400px\",\n                height:this.element.attr(\"height\")||\"250px\",\n                display:\"block\"\n            });\n            this.element.className=\"ls-editor-body\";\n            _this=this;\n            this.style(gl.themes.dark);\n            this.element.set([\n                N(\"div\",{className:\"ls-editor-inner\",style:S({position:\"absolute\",display:\"block\",width:\"100%\",height:\"100%\"}),inner:[\n                    N(\"div\",{className:\"ls-editor-overlay\",style:S({\n                        position:\"absolute\",\n                        \"pointer-events\":\"none\",\n                        inset:\"0\",\n                        \"white-space\":\"pre\"\n                    })}),\n                    N(\"textarea\",{className:\"ls-editor-edit ls-editor-text\",inner:[\"hi\"],oninput:function(){\n                        _this.element.get(\".ls-editor-overlay\").innerHTML=this.value\n                    }})\n                ]})\n            ])\n\n        }\n        style(theme){\n            let r={};\n            function get(obj){\n                if(!obj)return;\n                Object.keys(obj).forEach(k=>{\n                    let t={};\n                    if(k==\"include\"){\n                        return obj[k].split(\",\").forEach(k=>get(gl.themes[k]))\n                    }\n                    r[k]=r[k]||{};\n                    obj[k].split(\";\").map(e=>e.split(\":\").map(e=>e.trim())).forEach(k=>t[k[0]]=k[1]);\n                    Object.assign(r[k],t)\n                })\n            }\n            get(theme);\n            Object.keys(r).forEach(k=>{console.warn(_this.element.querySelectorAll(\"*\"));(k==\"body\"?[_this.element]:_this.element.querySelectorAll(k)).forEach(e=>{console.log(1,e,r[k]);S(e,r[k])})})\n            console.log(r);\n        }\n        addTheme(key,theme){gl.themes[key]=theme}\n        set(){\n\n        }\n        get(){\n\n        }\n    }\n},"],"from":"ls-js/editor.js"},{"segment":"progress","content":["Progress(gl){\n    let elementClass = class extends HTMLElement {\n        constructor(){\n            super();\n        }\n        connectedCallback(){\n            this.ls = LS.Progress(this.id || M.GlobalID, this, {seeker: this.tagName == \"LS-SEEKER\"})\n            this.ls.define(this)\n        }\n    }\n    customElements.define('ls-seeker', elementClass);\n    customElements.define('ls-progress', class extends elementClass{constructor(){super()}});\n\n    return _this=>class ProgressBar{\n        constructor(id,element,options){\n            this.element = element = O(element)\n            if(!element)throw\"No element provided\";\n\n            _this=this;\n\n            element.class(\"ls-progress\");\n            element.attrAssign(\"chv\");\n\n            if(options.seeker)this.element.class(\"ls-seek\");\n            element.add(N({class:\"ls-progress-bar\"}),options.seeker?N({class:\"ls-seeker-thumb\"}):\"\",N({class:\"ls-progress-label\",inner:\"0 / 0\"}))\n\n            _this._min=options.min || +element.attr(\"min\") || 0;\n            _this._max=options.max || +element.attr(\"max\") || 100;\n            _this._progress=options.progress || 0;\n            _this._value=options.value || +element.attr(\"value\") || 0;\n\n            this.define(this)\n            this.options = options\n            if(options.progress&&options.value)throw(\"You can't define both the progress and value.\")\n        }\n        _init(){\n            _this.bar=_this.element.get(\".ls-progress-bar\");\n            _this.label=_this.element.get(\".ls-progress-label\");\n            if(_this.options.seeker){\n                _this.thumb=_this.element.get(\".ls-seeker-thumb\");\n                function moveThumb(event) {\n                    let rect = _this.element.getBoundingClientRect(),\n                        xOffset = (event.type == \"touchmove\" ? event.touches[0].clientX : event.clientX) - rect.left,\n                        newValue = (xOffset/rect.width)*_this.max\n                    ;\n                    if (newValue>=0&&newValue<=_this.max) {\n                        _this._value=newValue;\n                        _this.update(false,true)\n                    }\n                }\n                function releaseThumb() {\n                    _this.seeking=false;\n                    _this.element.class(\"is-dragging\", 0)\n                    O().class(\"ls-dragging\", 0)\n                    D().removeEventListener(\"mousemove\", moveThumb);\n                    D().removeEventListener(\"mouseup\", releaseThumb);\n                    D().removeEventListener(\"touchmove\", moveThumb);\n                    D().removeEventListener(\"touchend\", releaseThumb);\n                    _this.invoke(\"seekend\",_this._value,_this._max,_this._progress)\n                }\n                _this.element.on(\"mousedown\",\"click\",\"touchstart\",(e)=>{\n                    if(_this.element.hasAttr(\"disabled\"))return;\n                    if(e.target!==_this.element&&e.target!==_this.bar&&e.target!==_this.thumb)return;\n                    if(e.type==\"click\"){\n                        return moveThumb(e)\n                    }\n                    _this.seeking=true;\n                    _this.element.class(\"is-dragging\")\n                    O().class(\"ls-dragging\")\n                    D().addEventListener(\"mousemove\", moveThumb);\n                    D().addEventListener(\"mouseup\", releaseThumb);\n                    D().addEventListener(\"touchmove\", moveThumb);\n                    D().addEventListener(\"touchend\", releaseThumb);\n                    _this.invoke(\"seekstart\",_this._value,_this._max,_this._progress)\n                })\n            }\n            if(_this.options.progress&&!_this.options.value){_this.update(true)}\n            else if(_this.options.value&&!_this.options.progress){_this.update()}\n            else{_this.update()}\n        }\n        define(scope){\n            Object.defineProperty(scope,\"progress\",{\n                get(){return _this._progress},\n                set(value){_this._progress=value;_this.update(true)}\n            })\n            Object.defineProperty(scope,\"value\",{\n                get(){return _this._value},\n                set(value_){_this._value=value_;_this.update()}\n            })\n            Object.defineProperty(scope,\"max\",{\n                get(){return _this._max},\n                set(value){_this._max=value;_this.update()}\n            })\n        }\n        update(setPercentage,isSeeking){\n            if(_this.seeking&&!isSeeking)return;\n            if(!setPercentage){\n                _this._progress=(_this.value/_this.max)*100\n            }else{\n                _this._value=(_this._progress*_this.max)/100\n            }\n            if(_this.options.seeker){\n                _this.thumb.style.left=_this.progress+\"%\"\n                if(isSeeking)_this.invoke(\"seek\",_this._value,_this._max,_this._progress)\n            }\n            _this.bar.style.width=_this.progress+\"%\"\n            _this.label.set(_this.options.template?_this.options.template(this):_this.options.seeker?[N({innerText:String(_this.value)}),N({innerText:String(_this.max)})]:`${_this.value} / ${_this.max}${_this.options.metric?\" \"+_this.options.metric:\"\"}`)\n        }\n    }\n},"],"from":"ls-js/progress.js"},{"segment":"color","content":["Color(gl){\n    gl.conf={\n        batch:!1,\n        singular:!0\n    }\n    gl.default=[\"blue\",\"burple\",\"aquamarine\",\"green\",\"lime\",\"orange\",\"yellow\",\"red\",\"bright\",\"pink\",\"purple\",\"gray\",\"gray-light\",\"white\",\"black\"];\n    return _this=>class Color{\n        constructor(){\n            _this=this;\n            this.colors={};\n            this.style=O(\"#ls-accents\");\n            if(!this.style){\n                this.style=N(\"style\",{id:\"ls-accents\"});\n                if(!O()){\n                    M.on(\"load\",()=>O().add(this.style))\n                }else{O().add(this.style)}\n            }\n        }\n        add(name,r,g,b){\n            if(gl.default.includes(name)||_this.colors[name])return false;\n            const hex = r.match(/^#([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i);\n            if(hex){\n                r=parseInt(hex[1], 16);\n                g=parseInt(hex[2], 16);\n                b=parseInt(hex[3], 16);\n            }else if(typeof r!=\"number\"||typeof g!=\"number\"||typeof b!=\"number\"){\n                throw\"Invalid color. Supported: hex, rgb\"\n            }\n            _this.colors[name]=[r,g,b]\n            _this.style.add(`[ls-${name}],[ls-accent=\"${name}\"]{--accent-raw:${r},${g},${b};--accent-dark-raw:${Math.max(0,r-30)},${Math.max(0,g-30)},${Math.max(0,b-30)}}`)\n            return true\n        }\n        setGlobal(color){\n            D().documentElement.setAttribute(\"ls-accent\",color)\n        }\n    }\n},"],"from":"ls-js/color.js"},{"segment":"graphgl","content":["GraphGL(gl){\n    return _this=>class GraphGL{\n        constructor(id,element,_options={}){\n            _this=this;\n            this.id=id;\n            let options=Object.assign({\n                height:100,\n                width:300,\n                default:{shadow:{inner:{}}},\n                charts:[],\n                tooltip:true,\n                blur:20\n            },_options);\n            this.ns=\"http://www.w3.org/2000/svg\";\n            this.options=options;\n            this.element=O(element);\n            this.charts={};\n            this.container=N('div',{inner:[\n                N(\"svg\",{ns:this.ns,id:\"graphgl_graph_\"+id,class:\"ls-chart-vector\",attr:{viewBox:`0 0 ${options.width} ${options.height}`,width:options.width,height:options.height,xmlns:this.ns}}),\n                N({class:\"ls-chart-line\",attr:\"ns\"}),\n                N({class:\"ls-chart-tooltip\",attr:[\"ls-box\",\"ns\"],inner:\"some text<br>some more\"}),\n            ],class:\"ls-chart-container\",id:\"ls-chart-\"+id});\n            this.svg=this.container.get(\"svg\")\n            this.tooltip=this.container.get(\".ls-chart-tooltip\")\n            this.svg.add(N(\"defs\",{ns:this.ns,innerHTML:`<filter id=\"gr_blur_${id}\" x=\"-50%\" y=\"-50%\" width=\"200%\" height=\"200%\"><feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"${options.blur||0}\" /></filter>`}))\n            this.defs=this.container.get(\"svg defs\")\n            this.element.add(this.container);\n            this.container.on(\"mousemove\",\"touchmove\",event=>{\n                if(!this.points||!this.options.tooltip)return;\n                let rect=this.container.getBoundingClientRect(),content=[],index=Math.round((event.clientX-rect.left)/(this.options.width/this.points)),x=index*(this.options.width/this.points),y=event.clientY-rect.top;\n                this.container.get(\".ls-chart-line\").style.left=this.tooltip.style.left=x+\"px\"\n                this.tooltip.style.top=y+\"px\";\n                if(this.lastPoint==index)return;\n                this.lastPoint=index\n                if(this.options.labelsX)content.push(\"<div class='ls-chart-tooltip-top'>\"+this.options.labelsX[index]+\"</div>\");\n                for(let chart of Object.values(this.charts)){\n                    let point = this.container.get(\"#graphgl_point_\"+chart.id)\n                    let color = this.container.getAll(\"#gr_grad_\"+chart.id+\" stop\").map(e=>e.attr(\"stop-color\"))[index]\n                    if(point){\n                        point.style.top=chart.points[index][1]+\"px\"\n                        point.style.left=x+\"px\";\n                        point.style.background=color;\n                    }\n                    content.push(options.contentFunction?options.contentFunction(chart,index):`<div style=background:${color} class=ls-chart-dot></div> ${chart.options.values[index]/(chart.options.divide||0)}${chart.options.metric} ${chart.options.name||\"\"}`)\n                    this.tooltip.innerHTML=content.join(\"<br>\");\n                }\n            })\n            for(let g of options.charts){\n                g=Object.assign({\n                    values:[100,20,30,25,60,70,65,75,45,0],\n                    colors:[\"#42CF00\",\"#8DBD00\",\"#A68B00\",\"#A68B00\",\"#955102\",\"#823205\",\"#6D0808\"].reverse(),\n                    colorFunction:(v,i)=>{\n                        this.clamp(Math.round()-1)\n                        return `rgb(${240-(v/this.options.height)*240},${(v/this.options.height)*240},15)`\n                    },\n                    coloringMethod:\"function\",//gradient | function | static\n                    stroke:8,\n                    rounding:20,\n                    fluid: true\n                },options.default,g)\n                g.shadow=Object.assign({allowed:true,spread:7,position:\"0,10\",opacity:.4},g.shadow);\n                g.shadow.inner=Object.assign({allowed:true,y:2,opacity:.4},g.shadow.inner);\n                this.graphFactory(M.GlobalID, g);\n            }\n        }\n        graphFactory(id, options){\n            if(_this.charts[id])return _this.charts[id];\n            let gr;\n            return new(class LineGraph{\n                constructor(){\n                    _this.charts[id]=this;\n                    gr=this;\n                    gr.id=id;\n                    gr.options=options;\nlet chart=`\n<polyline fill=\"none\" id=\"graphgl_poly_${id}\"></polyline>\n<path id=\"graphgl_path_${id}\" fill=\"none\" stroke=\"url(#gr_grad_${id})\" stroke-width=\"${options.stroke}\" stroke-linecap=\"round\"></path>`;\n// _this.svg.innerHTML+=chart;\nlet group = N('g',{ns:_this.ns,innerHTML:chart,class:\"ls-chart-group\",id:\"ls-chart-\"+id});\n_this.svg.add(group)\n_this.defs.innerHTML+=`<linearGradient id=\"gr_grad_${id}\" x1=\"0\" y1=\"0\" x2=\"${_this.options.width}\" y2=\"0\" gradientUnits=\"userSpaceOnUse\">\n${options.values.map((v,i)=>`<stop offset=\"${(1/(options.values.length-1))*i}\" stop-color=\"${options.coloringMethod==\"gradient\"?options.colors[_this.clamp(Math.round((v/_this.options.height)*options.colors.length)-1,0,options.colors.length-1)]:options.coloringMethod==\"static\"?options.colors:options.colorFunction(v,i)}\"></stop>`).join(\"\")}\n</linearGradient>\n${options.shadow.inner.allowed?`<filter id=\"gr_inner_${id}\" x=\"-50%\" y=\"-50%\" width=\"200%\" height=\"200%\" filterUnits=\"userSpaceOnUse\" color-interpolation-filters=\"sRGB\">\n<feFlood flood-opacity=\"0\" result=\"BackgroundImageFix\"></feFlood>\n<feBlend mode=\"normal\" in=\"SourceGraphic\" in2=\"BackgroundImageFix\" result=\"shape\"></feBlend>\n<feColorMatrix in=\"SourceAlpha\" type=\"matrix\" values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0\" result=\"hardAlpha\"></feColorMatrix>\n<feOffset dy=\"${options.shadow.inner.y}\"></feOffset>\n<feComposite in2=\"hardAlpha\" operator=\"arithmetic\" k2=\"-1\" k3=\"1\"></feComposite>\n<feColorMatrix type=\"matrix\" values=\"0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 ${options.shadow.inner.opacity} 0\"></feColorMatrix>\n<feBlend mode=\"normal\" in2=\"shape\" result=\"effect1_innerShadow_253_365\"></feBlend>\n</filter>`:''}`\n                    _this.container.add(N({class:\"ls-chart-point\",attr:\"ns\",id:\"graphgl_point_\"+id}))\n                    gr.group = group;\n                    gr.line = group.get(\"#graphgl_path_\"+id);\n                    gr.poly = group.get(\"#graphgl_poly_\"+id);\n                    _this.points=gr.options.values.length-1;\n                    gr.updatePoints();\n                    gr.updateStyle()\n                }\n                calcPoints(values){\n                    if(values)gr.options.values=values;\n                    gr.maxPoint=gr.options.fluid?Math.max(...gr.options.values):100\n                    return gr.points = gr.options.values.map((v,i)=>[(_this.options.width/(gr.options.values.length-1))*i,_this.options.height-((v/gr.maxPoint)*_this.options.height)])\n                }\n                updatePoints(values){\n                    gr.calcPoints(values);\n                    if(options.poly){\n                        gr.poly.attrAssign({\n                            points: gr.points.join(\" \"),\n                            stroke: \"url(#gr_grad_\"+id+\")\",\n                            \"stroke-width\": options.stroke\n                        })\n                    }else{\n                        gr.path = _this.gPath(gr.points, options.rounding);\n                        gr.line.attr(\"d\",gr.path);\n                    }\n                }\n                updateStyle(){\n                    if(options.shadow.allowed&&!gr.group.get(\"#graphgl_shadow_\"+id)){\n                        gr.group.add({ns:_this.ns,innerHTML:gr.line.outerHTML.replace(\"_path_\",\"_shadow_\")});\n                        gr.shadow=gr.group.get(\"#graphgl_shadow_\"+id);\n                        gr.shadow.attrAssign({\n                            filter: \"url(#gr_blur_\"+_this.id+\")\",\n                            transform: \"translate(\"+options.shadow.position+\")\",\n                            \"stroke-width\":options.shadow.spread,\n                            style: \"opacity:\"+options.shadow.opacity\n                        })\n                    }\n                    gr.line[options.shadow.inner.allowed?\"attr\":\"delAttr\"](\"filter\",options.shadow.inner.allowed?\"url(#gr_inner_\"+id+\")\":0);\n                }\n            })\n        }\n        clamp(num,min,max){return Math.min(Math.max(num,min),max)}\n        gPath(e,b){\n            function getAngle(b,c){let d=c.x-b.x,e=c.y-b.y,f=Math.atan2(e,d);return f}\n            function removeEmptyElements(a){for(let b=0;b<a.length;b++)\"\"==a[b]&&a.splice(b,1);return a}\n            let f=`M${e[0][0]},${e[0][1]}`;\n            for(let d=1;d<e.length-1;d++){\n                let a=d-1,g=d+1,h={};\n                h.x=e[d][0],h.y=e[d][1];\n                let c={x:e[a][0],y:e[a][1]},i={};i.x=e[g][0],i.y=e[g][1];\n                let j=getAngle(h,c),k=getAngle(h,i),l=(h.x+b*Math.cos(j)).toFixed(3),m=(h.y+b*Math.sin(j)).toFixed(3),n=(h.x+b*Math.cos(k)).toFixed(3),o=(h.y+b*Math.sin(k)).toFixed(3);\n                f+=\"L\"+l+\",\"+m+\" Q\"+h.x+\",\"+h.y+\" \"+n+\",\"+o\n            }\n            return f+=`L${e[e.length-1][0]},${e[e.length-1][1]}`\n        }\n    }\n},"],"from":"ls-js/graphgl.js"},{"segment":"accentmanager","content":["\n    AccentManager(gl){\n        gl.conf = {\n            batch: !1,\n            singular: !0,\n            requires: [\"Color\"]\n        }\n        console.warn('","","')\n        return _this=>class AccentManager{\n            constructor(){\n                return LS.Color\n            }\n        }\n    }\n    "]},"\n});\n\n",{"segment":"eventresolver","content":["LS.GlobalEvents = new(LS.EventResolver())(LS)/*\n}\n\n*/\n\nM.on(\"load\", ()=>{\n    Q(\"[ls-not-ready]\").all(e=>e.ready())\n})"]}]}